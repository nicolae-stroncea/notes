{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"CSC309/","text":"Communication and Protocols Network 4-layer Model This is a layered server architecture system in which each layer is defined according to a specific function to perform. All four layers work collaboratively to transmit data from one layer to another For computers to communicate with each other they need: A method of communication between them(a language, a set of rules) Need an efficient multi-step system, since it is quite complicated: Application Layer(HTTP,FTP,SSH,SMTP,POP3). Allows access to network resources This is the layer at which applications live. Applications like a web browser directly interact with the Application layer. Web browsers use http / s if you're visiting a website, or smtp if you're checking your mail. Transport layer( TCP ,UDP) UDP is faster Internet Layer( IP ) Link Layer(Ethernet, Wifi) It starts from the bottom, and moves up, so first you go through the Link Layer, then through the Internet Layer, then through the Transport Layer, and lastly through Application Layer. Flow Application layer : Gets the data from whatever program you're using, and sends it to the transport layer through a specific port(each port can be assigned to a specific protocol). E.G most activity in web browser goes through port 80, which is what HTTP always uses. Transport Layer : Gets the data from the application layer through a port, chops it up into packets, and then sends them. Each packet individually takes the quickest route to get to where it needs to be. Provides data transport from a process on a client to a process on a destination system(server) Once packets are assembled, and TCP ensures they're error free, packets are pushed on the Internet layer. Internet Layer : Attaches Origin and Destination IP address so packet knows where it's going, and where it came from Network Layer : Sends to the machine on the correct machine on a physical network. Application Layer Example: Web browsers need a protocol to get and send data Provides applications with standardized protocols to exchange data when they're accessing network resources: Protocols include: HTTP, FTP, SSH, SMTP, POP3 Programs like web browser directly interact with the Application layer. This layer has protocols like http/s if you're visiting websites or smtp if you're checking your email.] Uses Helps identify communication partners, determining resource availability, synchronizing communication Allows users to log on to a remote host Provides various e-mail services Transport layer(TCP) Helps ensure that data units are delivered error-free and in the right sequence. Controls the reliability of a link through flow control, error control, segmentation or de-segmentation. TCP puts a header on each packet which contains instruction on the order in which to assemble the packets. Contains error checking information so receiver knows if packet has been corrupted. Offers an acknowledgement of successful data transmission and sends the next data in case no error occured. TCP is the best-known example of the transport layer. Bi-directional: both client and server acknowledge when they get the data Consists of a 3-way handshake: Client and server can send each other data, and must acknowledge when they receive something. If no acknowledgement that packet was received, packet is sent again. TCP is reliable, because it reacts to losing packets(which slows connection) UDP is not reliable, but doesn't react to packet loss(which is what makes it faster) Internet layer(IP) Once packets are assembled, and TCP ensures they're error free, packets are pushed on the Internet layer. Attaches Origin and Destination IP address so packet knows where it's going, and where it came from Data then sent to network layer Network Layer Takes care of MAC addressing so data goes to the right physical machine on a network Client-server + TCP/IP Client initiates request to server Server accepts or rejects the connection If a connection is established, data can flow until the connection terminates TCP/IP facilitates connections between client and server over many networks, i.e THE INTERNET Data is transported through TCP + IP, which enables the client-server interaction","title":"Communication and Protocols"},{"location":"CSC309/#communication-and-protocols","text":"","title":"Communication and Protocols"},{"location":"CSC309/#network-4-layer-model","text":"This is a layered server architecture system in which each layer is defined according to a specific function to perform. All four layers work collaboratively to transmit data from one layer to another For computers to communicate with each other they need: A method of communication between them(a language, a set of rules) Need an efficient multi-step system, since it is quite complicated: Application Layer(HTTP,FTP,SSH,SMTP,POP3). Allows access to network resources This is the layer at which applications live. Applications like a web browser directly interact with the Application layer. Web browsers use http / s if you're visiting a website, or smtp if you're checking your mail. Transport layer( TCP ,UDP) UDP is faster Internet Layer( IP ) Link Layer(Ethernet, Wifi) It starts from the bottom, and moves up, so first you go through the Link Layer, then through the Internet Layer, then through the Transport Layer, and lastly through Application Layer.","title":"Network 4-layer Model"},{"location":"CSC309/#flow","text":"Application layer : Gets the data from whatever program you're using, and sends it to the transport layer through a specific port(each port can be assigned to a specific protocol). E.G most activity in web browser goes through port 80, which is what HTTP always uses. Transport Layer : Gets the data from the application layer through a port, chops it up into packets, and then sends them. Each packet individually takes the quickest route to get to where it needs to be. Provides data transport from a process on a client to a process on a destination system(server) Once packets are assembled, and TCP ensures they're error free, packets are pushed on the Internet layer. Internet Layer : Attaches Origin and Destination IP address so packet knows where it's going, and where it came from Network Layer : Sends to the machine on the correct machine on a physical network.","title":"Flow"},{"location":"CSC309/#application-layer","text":"Example: Web browsers need a protocol to get and send data Provides applications with standardized protocols to exchange data when they're accessing network resources: Protocols include: HTTP, FTP, SSH, SMTP, POP3 Programs like web browser directly interact with the Application layer. This layer has protocols like http/s if you're visiting websites or smtp if you're checking your email.]","title":"Application Layer"},{"location":"CSC309/#uses","text":"Helps identify communication partners, determining resource availability, synchronizing communication Allows users to log on to a remote host Provides various e-mail services","title":"Uses"},{"location":"CSC309/#transport-layertcp","text":"Helps ensure that data units are delivered error-free and in the right sequence. Controls the reliability of a link through flow control, error control, segmentation or de-segmentation. TCP puts a header on each packet which contains instruction on the order in which to assemble the packets. Contains error checking information so receiver knows if packet has been corrupted. Offers an acknowledgement of successful data transmission and sends the next data in case no error occured. TCP is the best-known example of the transport layer. Bi-directional: both client and server acknowledge when they get the data Consists of a 3-way handshake: Client and server can send each other data, and must acknowledge when they receive something. If no acknowledgement that packet was received, packet is sent again. TCP is reliable, because it reacts to losing packets(which slows connection) UDP is not reliable, but doesn't react to packet loss(which is what makes it faster)","title":"Transport layer(TCP)"},{"location":"CSC309/#internet-layerip","text":"Once packets are assembled, and TCP ensures they're error free, packets are pushed on the Internet layer. Attaches Origin and Destination IP address so packet knows where it's going, and where it came from Data then sent to network layer","title":"Internet layer(IP)"},{"location":"CSC309/#network-layer","text":"Takes care of MAC addressing so data goes to the right physical machine on a network","title":"Network Layer"},{"location":"CSC309/#client-server-tcpip","text":"Client initiates request to server Server accepts or rejects the connection If a connection is established, data can flow until the connection terminates TCP/IP facilitates connections between client and server over many networks, i.e THE INTERNET Data is transported through TCP + IP, which enables the client-server interaction","title":"Client-server + TCP/IP"},{"location":"CSC309/http/","text":"The World Wide Web and HTTP Web: Global collection of resources, which are identifiable and linked together Web resource: any data we send through the internet Stored on web servers URL: Uniform Resource Locator A way to get the resources we want from their web servers. URL provides us with a way of specifying location of a web resource(\"web address\") Locate where they are on the web Identify and access each resource. HTTP(the protocol of the web) Part of the application layer Gives the client and server a mutual language at the application layer. http://google.com: (http) is the protocol, (google.com) is the hostname/domain name Hostnames translated to IP addresses by the Domain Name System(DNS). IP addresses can change but the name stays the same, so the DNS always stays updated. As long as you give it the right name, it will map it to the right IP address. That's why we don't necessarily want to go by the IP address, because that can change. HTTP works by request-response Request from client Response from server Request and response both originate from the application layer. An HTTP request includes: URL: to get the resource on the server that we want. You can add queries to it, to get a more specific resource.(http://facebook.com/john-doe/) HTTP Method:(GET,POST,PATCH/PUT, DELETE) Request Headers and Body (give additional info about the request) Example HTTP Request Say we want to retreive a resource(a web page). Therefore the request will look like this: Notice it includes: Method(GET) Resource: URL(/..../) HTTP version HTTP Response Consists of: Response code : give a status code which indicates success/failure/atuhentication error/etc. Headers : Gives information about response Body : Content of the resource, if available. Linking the web(HyperText Transfer Protocol) Similar resources are often linked together through hyperlinks (links to other resources) HTTP is \"Stateless\" Each request is independent . Doesn't care how many requests are sent at once. Illusion of state is created(There are other mechanisms through which state is maintained.)","title":"The World Wide Web and HTTP"},{"location":"CSC309/http/#the-world-wide-web-and-http","text":"","title":"The World Wide Web and HTTP"},{"location":"CSC309/http/#web-global-collection-of-resources-which-are-identifiable-and-linked-together","text":"Web resource: any data we send through the internet Stored on web servers","title":"Web: Global collection of resources, which are identifiable and linked together"},{"location":"CSC309/http/#url-uniform-resource-locator","text":"A way to get the resources we want from their web servers. URL provides us with a way of specifying location of a web resource(\"web address\") Locate where they are on the web Identify and access each resource.","title":"URL: Uniform Resource Locator"},{"location":"CSC309/http/#httpthe-protocol-of-the-web","text":"Part of the application layer Gives the client and server a mutual language at the application layer. http://google.com: (http) is the protocol, (google.com) is the hostname/domain name Hostnames translated to IP addresses by the Domain Name System(DNS). IP addresses can change but the name stays the same, so the DNS always stays updated. As long as you give it the right name, it will map it to the right IP address. That's why we don't necessarily want to go by the IP address, because that can change. HTTP works by request-response Request from client Response from server Request and response both originate from the application layer. An HTTP request includes: URL: to get the resource on the server that we want. You can add queries to it, to get a more specific resource.(http://facebook.com/john-doe/) HTTP Method:(GET,POST,PATCH/PUT, DELETE) Request Headers and Body (give additional info about the request)","title":"HTTP(the protocol of the web)"},{"location":"CSC309/http/#example","text":"","title":"Example"},{"location":"CSC309/http/#http-request","text":"Say we want to retreive a resource(a web page). Therefore the request will look like this: Notice it includes: Method(GET) Resource: URL(/..../) HTTP version","title":"HTTP Request"},{"location":"CSC309/http/#http-response","text":"Consists of: Response code : give a status code which indicates success/failure/atuhentication error/etc. Headers : Gives information about response Body : Content of the resource, if available.","title":"HTTP Response"},{"location":"CSC309/http/#linking-the-webhypertext-transfer-protocol","text":"Similar resources are often linked together through hyperlinks (links to other resources)","title":"Linking the web(HyperText Transfer Protocol)"},{"location":"CSC309/http/#http-is-stateless","text":"Each request is independent . Doesn't care how many requests are sent at once. Illusion of state is created(There are other mechanisms through which state is maintained.)","title":"HTTP is \"Stateless\""},{"location":"CSC309/lec3/","text":"__proto__ is property of an object that points to the object's prototype. Just normal delegate objects. prototoype is the property of a function that is used as the prototype to add to the new object when that function is called as a constructor. Every function has a prototype. Its only purpose is for when its used as a constructor. proto is the actual object that is used in the lookup chain to resolve methods, prototype is the object that is used to build proto when you create an object with new. Prototype is not available on the instances themselves (or other objects), but only on the constructor functions.","title":"Lec3"},{"location":"CSC309/midterm_preparation/","text":"Midterm Preparation Always consider hoisting(both for functions AND variables(except ignore it IFF its block variables )) Scopes Scopes determine the accessibility of variables inside a JS program. JS defines 3 kinds of scope: Functional Scope (local variables. Functions declared inside function(with var, or with let if you declare it at the beginning), can only be accessed from there) Global Scope Block Scope Hoisting Variables Hoisting All variable and function declarations are 'hoisted' up to the top of their function scope(or global scope) . Variable definitions stay in place console . log ( a ) var a = 3 // is hoisted up as: var a ; console . log ( a ); a = 3 ; var name = \"Baggins\" ; ( function () { // Outputs: \"Original name was undefined\" console . log ( \"Original name was \" + name ); var name = \"Underhill\" ; // Outputs: \"New name is Underhill\" console . log ( \"New name is \" + name ); })(); What happens if you use a = 3 instead of var a = 3 . In that case a is considered a global varaible. It now becomes avilable to everybody in the lexical scope, which is hard to manage. Function Hoisting Inner functions(and inner variables) are hoisted to the top of the function they're part of, which is why they're local, you can't reference them outside of that function's scope. Function name + Definition gets hoisted to the top // Outputs: \"Yes!\" isItHoisted (); function isItHoisted () { console . log ( \"Yes!\" ); } Notice that we can call isItHoisted before hand Hoisting only occurs for function declarations not function expression. The assignment part of a function expression is NOT hoisted, only the declaration is(and if it's a function declaration, its body is taken as well.) . so if you assign a function to a variable, it's not going to work. This is because function doesn't have a name, so the function is probably hoisted but you can't refer to it. variable definitionNotHoisted is also hoisted, but it is undefined at the top since it's not declared yet. // Outputs: \"Definition hoisted!\" definitionHoisted (); // TypeError: undefined is not a function definitionNotHoisted (); function definitionHoisted () { console . log ( \"Definition hoisted!\" ); } var definitionNotHoisted = function () { console . log ( \"Definition not hoisted!\" ); }; Here we give the function a name, test. This one below still doesn't work, because it's part of a function expression, it's not a direct function assignment. // Outputs: \"Definition hoisted!\" definitionHoisted (); // TypeError: undefined is not a function test (); function definitionHoisted () { console . log ( \"Definition hoisted!\" ); } var definitionNotHoisted = function test () { console . log ( \"Definition not hoisted!\" ); }; Class hoisting Class declarations are not hoisted. This is because they're actually function assignments. ( function () { //IIFE console . log ( hero ); //undefined var hero = \"Batman\" ; theFlash (); //TypeError: theFlash is not a function var theFlash = function (){ console . log ( \"Fastest Man alive\" ); } })(); This is interpreted as the below ( function () { //IIFE var hero ; //declarations are hoisted but NOT assignment var theFlash ; console . log ( hero ); //undefined hero = \"Batman\" ; theFlash (); //TypeError: theFlash is not a function theFlash = function (){ console . log ( \"Fastest Man alive\" ); } })(); Blocks This is what actually happens, but for all intents and purposes we can consider that block scope variables HAVE NO hoisting: In ECMAScript 2015, let and const keyword variable declarations will hoist the variable to top of the block. However, referencing the variable in the block before variable declaration results in ReferenceError . The difference between var / function declarations and let / const declarations is in the initialization portion. The former are initialized with undefined or generator function right when binding is created at top of the scope, while the latter stay uninitialized until let / const statement is run. The variable is called to be in a \u201ctemporal dead zone\u201d from start of the block until the declaration is executed. Minimize hoisting problems since we don't do hoisting anymore. Scope is block only(can only be used inside of the curly braces its declared in), and inside of the block you don't have hoisting, so you cannot use it before you declare it. A block is defined by a pair of curly braces Block variables(let and const) are not hoisted to the top of the block. You can only access block variables AFTER they have been declared . Until then, the variable is oconsidered to be in the \"Temporal Dead Zone\". If you try to access it, it will result in reference error. Both block and function(var) level variables are only available within their scope and in inner scopes. If you declare them at a global level, they're not available within functions. Might be because they're not actually in any {} , so they're not in any block. Const Needs to be declared immediately(b/c once you assign it a value, you cannot reassign it) You cannot reassign it to a different memory address, but you can change its properties. When you declare a variable using var on the root level, it is automatically declared on the global object. This does not happen with let or const. var foo = 42 ; console . log ( window . foo ) //42 When using let (and const ), this does not happen: let foo = 42 ; console . log ( window . foo ) //undefined Immediately Invoked Function Expression ( function () { var foo = 42 ; })(); console . log ( foo ); // ReferenceError: foo is not defined Lexical Scope Lexical Scope allows inner functions to access the scope of their outer functions. Functions Functions in javascript are first-class objects. This is becauseJS functions are actually types of objects This means the language supports constructing new functions during the execution of a program, storing them in data structures, passing them as arguments to other functions, and returning them as values of other functions. They can be stored in a variable, object or array Can be passed as an argument to a function Returned from a function. Creating Functions Function Declaration : // Named function declaration function myFunction ( parameters ) { /* logic here */ } Function Expression : // Assignment of a function expression to a variable var myFunction = function () { /* logic here */ }; var myFunction = function test () { /* statements */ } A function expression is similar to and has the same syntax as a function declaration (see function expression for details). A function expression may be a part of a larger expression. One can define \"named\" function expressions (where the name of the expression might be used in the call stack for example) or \"anonymous\" function expressions. Function expressions are not hoisted onto the beginning of the scope, therefore they cannot be used before they appear in the code. myFunction : function () { /* logic here */ } Function expression may be part of a larger expression. You can define named \"function expressions or anynonymous function expressions. Only the variable declaration is hoisted to the beginning of the scope. The function expresssion IS NOT. Arrow function Arrow function is an anonymous function(unless you assign it to a variable). arrow functions , do not have their own this , this retains the value of the enclosing lexical context's this (i.e binds this by itself). You also cannot override that with any calls to bind () , call () or apply () In global code, this will be set to the global object: ( params )=>{ statements } Cannot be used as constructors What ends up happening is that you call obj.bar(). That binds this to be the obj , because of runtime binding . The arrow function is permanently bound to the this of its enclosing function, therefore the moment you call obj . bar () , it arrow function this instantly becomes obj, since that's the this of the enclosing function. var obj = { bar : function () { var x = (() => this ); //x is not a value, but a function(anonymous one) return x ; } }; // Call bar as a method of obj, setting its this to obj // Assign a reference to the returned function to fn var fn = obj . bar (); // Call fn without setting this, would normally default // to the global object or undefined in strict mode console . log ( fn () === obj ); // true // But caution if you reference the method of obj without calling it. You haven't executed it yet, therefore this has not yet been bound var fn2 = obj . bar ; // You only execute the function now, which binds the this to global since it's not bound to any other object. It follows the this from fn2. console . log ( fn2 ()() == window ); // true Immediately Invoked Function Expressions IIFE : You invoke it immediately after. Any variables declared within the IFFE cannot be accessed outside the world We used to use it before EC6 in order to obtain block-level variables(those variables would only be defined inside of the IIFE) and after are not accessible. This is why it's immediately invoked. We can consider it as a block. We don't give it a name, because it's a one time thing. ( function foo () { // logic here })(); Closures A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment ). In other words, a closure gives you access to an outer function\u2019s scope from an inner function. In JavaScript, closures are created every time a function is created, at function creation time. To use a closure, define a function inside another function and expose it. To expose a function, return it or pass it to another function. The inner function will have access to the variables in the outer function scope, even after the outer function has returned. A closure is a function bundled together( enclosed ) with references to its surrounding state( lexical environment ). This is achieved by having the functio nbe an inner function(in which case it will have access to the variables inside of its parent function), and then returning it. ALlows function/block scopes to be preserved even once they finish executing. A closure gives you access to an outer function's scope from an inner function . Nested functions have access to the scope \"above\" them. Example below always returns 1, this is beacuse the coutner is initialized to 0 every time. function add (){ var counter = 0 ; function plus (){ counter += 1 ; } plus () } Example below is a correctly implemented counter. var add = ( function (){ var counter = 0 return function (){ counter += 1 ; return counter } })() This version also works function testPlus (){ var counter = 0 ; function plus (){ counter += 1 return counter } return plus } // advantage of this version over previous one is that you can essentially create multiple counters a = testPlus () b = testPlus () Inner functions preserve the scope of the outer functions, EVEN IF the outer functions finish. THEREFORE, we will define an IIFE(immediately invoked function expression) which will set up the scope and the variables, and will return an inner function. We can assign that to a variable, so we have the inner function now as a variable, and every time we call it, because it preserves the scope of the IIFE, it can modify it, even though the IIFE executed only once and finished executing. This makes JavaScript have \"private\" variables that can be modified, and stored. The counter is protected by the scope of the anonymous function, and can only be changed using the add function. Objects const student = { name : 'Jimmy' , year : 2 } // is the same as const student = { \"name\" : 'Jimmy' , \"year\" : 2 } // both of them get generated as // Object { name: \"Jimmy\", year: 2 } // objec tproperties are retrieved like student . name == student [ 'name' ] // can set those properties as student . year = 20 // function can be stored as a value, we can put them into objects student . sayName = function (){ console . log ( \"Hello\" + this . name ) } student . sayName () this keyword Value of this is determined by how a function is called(runtime binding: this is bound at runtime(during runtime)). this becomes whatever you call it on( in student . execfunction () this is student, if you don't call the function on any object, this is global. Starting with ES5, bind() can be used to set value of function's this regardless of how it's called. > Calling f . bind ( someObject ) creates a new function with the same body and scope as f , but where this occurs in the original function, in the new function it is permanently bound to the first argument of bind , regardless of how the function is being used. Now you can use call () , apply () and bind () to set the value of this to a particular value INDEPENDENT of the context it's in. So it doesn't matter what object you call it on, you override that with one of those 3 things. execFunc . bind ( obj ) global this : In web browsers, the window object is also the global object:), or global object if you're in node console. If we do use strict this becomes undefined when we're in an execution context(say inside of a function.) function add ( c , d ) { return this . a + this . b + c + d ; } var o = { a : 1 , b : 3 }; // The first parameter is the object to use as // 'this', subsequent parameters are passed as // arguments in the function call add . call ( o , 5 , 7 ); // 16 // The first parameter is the object to use as // 'this', the second is an array whose // members are used as the arguments in the function call add . apply ( o , [ 10 , 20 ]); // 34 new operator and Constructors JavaScript objects are bags of named properties you can read and set Functions are also objects(they can have properties and methods like any other objects). What distinguishes them from other objects is that they can be called. NOTE : They are Function objects. Every function in JavaScript is a Function object. Creates a new object . The type of the object is simply object It sets this new object's internal, inaccessible, [[prototype]] (i.e. proto ) property to be the constructor function's external, accessible, prototype object (every function object automatically has a prototype property). No clue what the hell this means Makes this variable point to newly created object Executes the constructor function(this is the function that new is called on), using the newly created object whenever this is mentioned. This is why it first creates the object, binds it, and now the constructor this calls refer to the new objects Returns the newly created object, unless the function returns a non-null object reference. function Hero ( heroName , realName ) { this . realName = realName ; this . heroName = heroName ; } const superman = Hero ( \"Superman\" , \"Clark Kent\" ); console . log ( superman ); If we run this code not in strict mode, then it will consider this as global. Otherwise it will consider this as undefined. This is a good thing because it prevents us from creating global variables This works const superman = new Hero ( \"Superman\" , \"Clark Kent\" ); console . log ( superman ); When a function is used as a constructor (with the new keyword), its this is bound to the new object being constructed. When we call new, a new object is created and set as the function's this argument. The object is then implicitly returned from the function, unless we explicitly return an object. The only scenario where the return statement doesn\u2019t overwrite the constructor call is if the return statement tries to return anything that is not an object. In this case, the object will contain the original values. Classes Instead of making 'instances' or copies of classes, JS works ona delegation framework. If a property cannot be found in an object, JS looks for that property in a delegate object . Delegate objects can be chained(think of this the same way as the inheritance chain.) Prototypes are objects that are used by other objects to add delegate properties They are not superclasses- no instances are created. An object will just have a reference to its prototype (i.e no instances are created, you just point to an existing prototype) Multple objects can have the same prototype object reference (so if you modify a prototype, that will change delegate properties for ALL of the objects which have that prototype.) An object can have multiple prototypes If you want to access an object property/methos, JS first looks at the object, if it can't find it in the object, looks at the prototype of the object, if can't find it in the prototype of the objec,t looks in the prototype of the prototype of the object, all the way till it gets to the Object Prototype.","title":"Midterm Preparation"},{"location":"CSC309/midterm_preparation/#midterm-preparation","text":"Always consider hoisting(both for functions AND variables(except ignore it IFF its block variables ))","title":"Midterm Preparation"},{"location":"CSC309/midterm_preparation/#scopes","text":"Scopes determine the accessibility of variables inside a JS program. JS defines 3 kinds of scope: Functional Scope (local variables. Functions declared inside function(with var, or with let if you declare it at the beginning), can only be accessed from there) Global Scope Block Scope","title":"Scopes"},{"location":"CSC309/midterm_preparation/#hoisting","text":"","title":"Hoisting"},{"location":"CSC309/midterm_preparation/#variables-hoisting","text":"All variable and function declarations are 'hoisted' up to the top of their function scope(or global scope) . Variable definitions stay in place console . log ( a ) var a = 3 // is hoisted up as: var a ; console . log ( a ); a = 3 ; var name = \"Baggins\" ; ( function () { // Outputs: \"Original name was undefined\" console . log ( \"Original name was \" + name ); var name = \"Underhill\" ; // Outputs: \"New name is Underhill\" console . log ( \"New name is \" + name ); })(); What happens if you use a = 3 instead of var a = 3 . In that case a is considered a global varaible. It now becomes avilable to everybody in the lexical scope, which is hard to manage.","title":"Variables Hoisting"},{"location":"CSC309/midterm_preparation/#function-hoisting","text":"Inner functions(and inner variables) are hoisted to the top of the function they're part of, which is why they're local, you can't reference them outside of that function's scope. Function name + Definition gets hoisted to the top // Outputs: \"Yes!\" isItHoisted (); function isItHoisted () { console . log ( \"Yes!\" ); } Notice that we can call isItHoisted before hand Hoisting only occurs for function declarations not function expression. The assignment part of a function expression is NOT hoisted, only the declaration is(and if it's a function declaration, its body is taken as well.) . so if you assign a function to a variable, it's not going to work. This is because function doesn't have a name, so the function is probably hoisted but you can't refer to it. variable definitionNotHoisted is also hoisted, but it is undefined at the top since it's not declared yet. // Outputs: \"Definition hoisted!\" definitionHoisted (); // TypeError: undefined is not a function definitionNotHoisted (); function definitionHoisted () { console . log ( \"Definition hoisted!\" ); } var definitionNotHoisted = function () { console . log ( \"Definition not hoisted!\" ); }; Here we give the function a name, test. This one below still doesn't work, because it's part of a function expression, it's not a direct function assignment. // Outputs: \"Definition hoisted!\" definitionHoisted (); // TypeError: undefined is not a function test (); function definitionHoisted () { console . log ( \"Definition hoisted!\" ); } var definitionNotHoisted = function test () { console . log ( \"Definition not hoisted!\" ); };","title":"Function Hoisting"},{"location":"CSC309/midterm_preparation/#class-hoisting","text":"Class declarations are not hoisted. This is because they're actually function assignments. ( function () { //IIFE console . log ( hero ); //undefined var hero = \"Batman\" ; theFlash (); //TypeError: theFlash is not a function var theFlash = function (){ console . log ( \"Fastest Man alive\" ); } })(); This is interpreted as the below ( function () { //IIFE var hero ; //declarations are hoisted but NOT assignment var theFlash ; console . log ( hero ); //undefined hero = \"Batman\" ; theFlash (); //TypeError: theFlash is not a function theFlash = function (){ console . log ( \"Fastest Man alive\" ); } })();","title":"Class hoisting"},{"location":"CSC309/midterm_preparation/#blocks","text":"This is what actually happens, but for all intents and purposes we can consider that block scope variables HAVE NO hoisting: In ECMAScript 2015, let and const keyword variable declarations will hoist the variable to top of the block. However, referencing the variable in the block before variable declaration results in ReferenceError . The difference between var / function declarations and let / const declarations is in the initialization portion. The former are initialized with undefined or generator function right when binding is created at top of the scope, while the latter stay uninitialized until let / const statement is run. The variable is called to be in a \u201ctemporal dead zone\u201d from start of the block until the declaration is executed. Minimize hoisting problems since we don't do hoisting anymore. Scope is block only(can only be used inside of the curly braces its declared in), and inside of the block you don't have hoisting, so you cannot use it before you declare it. A block is defined by a pair of curly braces Block variables(let and const) are not hoisted to the top of the block. You can only access block variables AFTER they have been declared . Until then, the variable is oconsidered to be in the \"Temporal Dead Zone\". If you try to access it, it will result in reference error. Both block and function(var) level variables are only available within their scope and in inner scopes. If you declare them at a global level, they're not available within functions. Might be because they're not actually in any {} , so they're not in any block.","title":"Blocks"},{"location":"CSC309/midterm_preparation/#const","text":"Needs to be declared immediately(b/c once you assign it a value, you cannot reassign it) You cannot reassign it to a different memory address, but you can change its properties. When you declare a variable using var on the root level, it is automatically declared on the global object. This does not happen with let or const. var foo = 42 ; console . log ( window . foo ) //42 When using let (and const ), this does not happen: let foo = 42 ; console . log ( window . foo ) //undefined","title":"Const"},{"location":"CSC309/midterm_preparation/#immediately-invoked-function-expression","text":"( function () { var foo = 42 ; })(); console . log ( foo ); // ReferenceError: foo is not defined","title":"Immediately Invoked Function Expression"},{"location":"CSC309/midterm_preparation/#lexical-scope","text":"Lexical Scope allows inner functions to access the scope of their outer functions.","title":"Lexical Scope"},{"location":"CSC309/midterm_preparation/#functions","text":"Functions in javascript are first-class objects. This is becauseJS functions are actually types of objects This means the language supports constructing new functions during the execution of a program, storing them in data structures, passing them as arguments to other functions, and returning them as values of other functions. They can be stored in a variable, object or array Can be passed as an argument to a function Returned from a function.","title":"Functions"},{"location":"CSC309/midterm_preparation/#creating-functions","text":"Function Declaration : // Named function declaration function myFunction ( parameters ) { /* logic here */ } Function Expression : // Assignment of a function expression to a variable var myFunction = function () { /* logic here */ }; var myFunction = function test () { /* statements */ } A function expression is similar to and has the same syntax as a function declaration (see function expression for details). A function expression may be a part of a larger expression. One can define \"named\" function expressions (where the name of the expression might be used in the call stack for example) or \"anonymous\" function expressions. Function expressions are not hoisted onto the beginning of the scope, therefore they cannot be used before they appear in the code. myFunction : function () { /* logic here */ } Function expression may be part of a larger expression. You can define named \"function expressions or anynonymous function expressions. Only the variable declaration is hoisted to the beginning of the scope. The function expresssion IS NOT.","title":"Creating Functions"},{"location":"CSC309/midterm_preparation/#arrow-function","text":"Arrow function is an anonymous function(unless you assign it to a variable). arrow functions , do not have their own this , this retains the value of the enclosing lexical context's this (i.e binds this by itself). You also cannot override that with any calls to bind () , call () or apply () In global code, this will be set to the global object: ( params )=>{ statements } Cannot be used as constructors What ends up happening is that you call obj.bar(). That binds this to be the obj , because of runtime binding . The arrow function is permanently bound to the this of its enclosing function, therefore the moment you call obj . bar () , it arrow function this instantly becomes obj, since that's the this of the enclosing function. var obj = { bar : function () { var x = (() => this ); //x is not a value, but a function(anonymous one) return x ; } }; // Call bar as a method of obj, setting its this to obj // Assign a reference to the returned function to fn var fn = obj . bar (); // Call fn without setting this, would normally default // to the global object or undefined in strict mode console . log ( fn () === obj ); // true // But caution if you reference the method of obj without calling it. You haven't executed it yet, therefore this has not yet been bound var fn2 = obj . bar ; // You only execute the function now, which binds the this to global since it's not bound to any other object. It follows the this from fn2. console . log ( fn2 ()() == window ); // true","title":"Arrow function"},{"location":"CSC309/midterm_preparation/#immediately-invoked-function-expressions","text":"IIFE : You invoke it immediately after. Any variables declared within the IFFE cannot be accessed outside the world We used to use it before EC6 in order to obtain block-level variables(those variables would only be defined inside of the IIFE) and after are not accessible. This is why it's immediately invoked. We can consider it as a block. We don't give it a name, because it's a one time thing. ( function foo () { // logic here })();","title":"Immediately Invoked Function Expressions"},{"location":"CSC309/midterm_preparation/#closures","text":"A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment ). In other words, a closure gives you access to an outer function\u2019s scope from an inner function. In JavaScript, closures are created every time a function is created, at function creation time. To use a closure, define a function inside another function and expose it. To expose a function, return it or pass it to another function. The inner function will have access to the variables in the outer function scope, even after the outer function has returned. A closure is a function bundled together( enclosed ) with references to its surrounding state( lexical environment ). This is achieved by having the functio nbe an inner function(in which case it will have access to the variables inside of its parent function), and then returning it. ALlows function/block scopes to be preserved even once they finish executing. A closure gives you access to an outer function's scope from an inner function . Nested functions have access to the scope \"above\" them. Example below always returns 1, this is beacuse the coutner is initialized to 0 every time. function add (){ var counter = 0 ; function plus (){ counter += 1 ; } plus () } Example below is a correctly implemented counter. var add = ( function (){ var counter = 0 return function (){ counter += 1 ; return counter } })() This version also works function testPlus (){ var counter = 0 ; function plus (){ counter += 1 return counter } return plus } // advantage of this version over previous one is that you can essentially create multiple counters a = testPlus () b = testPlus () Inner functions preserve the scope of the outer functions, EVEN IF the outer functions finish. THEREFORE, we will define an IIFE(immediately invoked function expression) which will set up the scope and the variables, and will return an inner function. We can assign that to a variable, so we have the inner function now as a variable, and every time we call it, because it preserves the scope of the IIFE, it can modify it, even though the IIFE executed only once and finished executing. This makes JavaScript have \"private\" variables that can be modified, and stored. The counter is protected by the scope of the anonymous function, and can only be changed using the add function.","title":"Closures"},{"location":"CSC309/midterm_preparation/#objects","text":"const student = { name : 'Jimmy' , year : 2 } // is the same as const student = { \"name\" : 'Jimmy' , \"year\" : 2 } // both of them get generated as // Object { name: \"Jimmy\", year: 2 } // objec tproperties are retrieved like student . name == student [ 'name' ] // can set those properties as student . year = 20 // function can be stored as a value, we can put them into objects student . sayName = function (){ console . log ( \"Hello\" + this . name ) } student . sayName ()","title":"Objects"},{"location":"CSC309/midterm_preparation/#this-keyword","text":"Value of this is determined by how a function is called(runtime binding: this is bound at runtime(during runtime)). this becomes whatever you call it on( in student . execfunction () this is student, if you don't call the function on any object, this is global. Starting with ES5, bind() can be used to set value of function's this regardless of how it's called. > Calling f . bind ( someObject ) creates a new function with the same body and scope as f , but where this occurs in the original function, in the new function it is permanently bound to the first argument of bind , regardless of how the function is being used. Now you can use call () , apply () and bind () to set the value of this to a particular value INDEPENDENT of the context it's in. So it doesn't matter what object you call it on, you override that with one of those 3 things. execFunc . bind ( obj ) global this : In web browsers, the window object is also the global object:), or global object if you're in node console. If we do use strict this becomes undefined when we're in an execution context(say inside of a function.) function add ( c , d ) { return this . a + this . b + c + d ; } var o = { a : 1 , b : 3 }; // The first parameter is the object to use as // 'this', subsequent parameters are passed as // arguments in the function call add . call ( o , 5 , 7 ); // 16 // The first parameter is the object to use as // 'this', the second is an array whose // members are used as the arguments in the function call add . apply ( o , [ 10 , 20 ]); // 34","title":"this keyword"},{"location":"CSC309/midterm_preparation/#new-operator-and-constructors","text":"JavaScript objects are bags of named properties you can read and set Functions are also objects(they can have properties and methods like any other objects). What distinguishes them from other objects is that they can be called. NOTE : They are Function objects. Every function in JavaScript is a Function object. Creates a new object . The type of the object is simply object It sets this new object's internal, inaccessible, [[prototype]] (i.e. proto ) property to be the constructor function's external, accessible, prototype object (every function object automatically has a prototype property). No clue what the hell this means Makes this variable point to newly created object Executes the constructor function(this is the function that new is called on), using the newly created object whenever this is mentioned. This is why it first creates the object, binds it, and now the constructor this calls refer to the new objects Returns the newly created object, unless the function returns a non-null object reference. function Hero ( heroName , realName ) { this . realName = realName ; this . heroName = heroName ; } const superman = Hero ( \"Superman\" , \"Clark Kent\" ); console . log ( superman ); If we run this code not in strict mode, then it will consider this as global. Otherwise it will consider this as undefined. This is a good thing because it prevents us from creating global variables This works const superman = new Hero ( \"Superman\" , \"Clark Kent\" ); console . log ( superman ); When a function is used as a constructor (with the new keyword), its this is bound to the new object being constructed. When we call new, a new object is created and set as the function's this argument. The object is then implicitly returned from the function, unless we explicitly return an object. The only scenario where the return statement doesn\u2019t overwrite the constructor call is if the return statement tries to return anything that is not an object. In this case, the object will contain the original values.","title":"new operator and Constructors"},{"location":"CSC309/midterm_preparation/#classes","text":"Instead of making 'instances' or copies of classes, JS works ona delegation framework. If a property cannot be found in an object, JS looks for that property in a delegate object . Delegate objects can be chained(think of this the same way as the inheritance chain.) Prototypes are objects that are used by other objects to add delegate properties They are not superclasses- no instances are created. An object will just have a reference to its prototype (i.e no instances are created, you just point to an existing prototype) Multple objects can have the same prototype object reference (so if you modify a prototype, that will change delegate properties for ALL of the objects which have that prototype.) An object can have multiple prototypes If you want to access an object property/methos, JS first looks at the object, if it can't find it in the object, looks at the prototype of the object, if can't find it in the prototype of the objec,t looks in the prototype of the prototype of the object, all the way till it gets to the Object Prototype.","title":"Classes"},{"location":"CSC343/","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [ dir - name ] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. Project layout mkdocs . yml # The configuration file . docs / index . md # The documentation homepage . ... # Other markdown pages , images and other files .","title":"Welcome to MkDocs"},{"location":"CSC343/#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"CSC343/#commands","text":"mkdocs new [ dir - name ] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Commands"},{"location":"CSC343/#project-layout","text":"mkdocs . yml # The configuration file . docs / index . md # The documentation homepage . ... # Other markdown pages , images and other files .","title":"Project layout"},{"location":"CSC343/ddl/","text":"Data Definition Language(DDL) Types Each column must have a type. List of possible types: Char(n): fixed-length string of n characters, padded with blanks if necessary Varchar(n): variable-length string of up to n characters Text: variable-length, unlimited . PSQL and other implementations support it, but it's not in SQL standard. Int: just integer Float: Real number(+/-, decimal places, etc) e.g: 1.49, 37.96e2 Boolean e.g: TRUE, FALSE Time-related: Date : just the date, no time in hrs, minuts, e.g: \u20182011-09-22\u2019 Time : just the time in hrs, minutes, etc, no Date, e.g: '15:00:02.5' TimeStamp : you know both the time + the date, e.g: 'Jan-12-2011 10:25' User-defined types Can define your own types, where you can set constraints : create domain Grade as int default null check ( value >= 0 and value <= 100 ); create domain Campus as varchar ( 4 ) default 'StG' check ( value in ( 'StG' , 'UTM' , 'UTSC' )); domain is a data type with optional constraints constraints are checked every time new value is added. Constraints Primary key, foreign key, checks, unique, they're all constraints. Can give them a name(except for primary key) by adding constraint << name >> before check ( << condition >> ) constraint gradeInRange check ( value >= 0 ); constraint validCourseReference foreign key ( cNum , dept ) references Course ; Check Constraints A check constraint is the most generic constraint type. It allows you to specify that the value in a certain column must satisfy a Boolean (truth-value) expression. A check constraint is satisfied if the check expression evaluates to true or the null value. Since most expressions will evaluate to the null value if any operand is null, they will not prevent null values in the constrained columns Check constraint can check across the column, OR across the entire row( in PSQL ). It can also check across the entire table( not in PSQL ). # this one gives the check a name CREATE TABLE products ( product_no integer , name text , price numeric CONSTRAINT positive_price CHECK ( price > 0 ) ); # this one does a general check on the row . CREATE TABLE products ( product_no integer , name text , price numeric CHECK ( price > 0 ), discounted_price numeric CHECK ( discounted_price > 0 ), CHECK ( price > discounted_price ) ); Not null Constraints A not-null constraint simply specifies that a column must not assume the null value. A syntax example: # must always be written as column constraint CREATE TABLE products ( product_no integer NOT NULL , name text NULL , price numeric NOT NULL CHECK ( price > 0 ) ); ### Unique * same format as primary key declaration * set of attributes form a key ( they are unique ) * 1 value + can be null ( or all of them ). two null values are never considered equal in this comparison ( you can think of NULL as unknown ). That means even in the presence of a unique constraint it is possible to store duplicate rows that contain a null value in at least one of the constrained columns . * Can be written as a column constraint or as a tqable constraint . * ` UNIQUE NOT NULL ` has same meaning as ` Primary Key ` except you can have as manu ` unique not null ` as you want but you can only have 1 ` Primary Key ` ``` SQL CREATE TABLE products ( product_no integer UNIQUE , name text , price numeric ); # this specifies that the COMBINATION of prodcut_no and name MUST BE UNIQUE CREATE TABLE products ( product_no integer , name text , price numeric , UNIQUE ( product_no , name ) ); Primary Key Set of attributes forms a key( unique ) link Values are never null ( each one of the attributes is NOT NULL ) Very useful for optimizations Option 1 is if you only have 1 primary key create table Blah ( age1 integer primary key ; age2 integer ; age3 integer ); Option 2 is if you want 1+ primary keys : add pk at the end of table definition(still inside): create table Blah ( age1 integer ; age2 integer ; age3 integer ; primary key ( age1 , age2 ); ) Foreign Key foreign key ( SID ) references Student Every value of sID in this table must occur in Student table Must be declared either primary key or unique in Student table Has same syntax as unique and Primary Key create table People ( SIN integer primary key , name text , OHIP text unique ); create table Volunteers ( email text primary key , OHIPnum text references People ( OHIP )); age int check ( age > 0 ); Assertions Assertions can express ross-table constraints: create assertion ( name ) check ( predicate ); Expensive because have to be checked on every database updated Assertions are not supported by PostreSQL(or most other DBMS's) Triggers Triggers are compromise between checks AND Assertions They are powerful You control the cost by deciding when they are applied. Process Specify type of database even you want to respond to: (after delete on Courses, before update of grade on Took, etc) Specify the response: (insert into Winners values (sID)) as a function. Creating the function : create function RecordWinner () returns trigger as $$ begin if new . grade >= 85 then insert into Winners values ( new . sid ); end if ; return new ; end $$ language plpgsql The trigger : create trigger TookUpdate before insert on Took # specify the event for each row execute procedure RecordWinner (); # specify what function you want to u Reaction Policies Assume table R refers to table S You can define \"fixes\" propagate backwards from S to R. We define them in R because that's the table that will be affected Cannot define \"fixes\" that propagate forward from R to S. Events You can react to: on delete(when row deleted in S creates dangling reference) on update(when an update in S creates dangling reference(i.e maybe one of values of p.k is changed)) or both: on delete restrict on update cascade reactions restrict : don't allow the deletion/update in S. Therefore, if I delete a row from S which has a reference in R, DBMS won't let me.W cascade : make the same deletion/update in the referring tuple. if I delete row from S, also delete all rows from R which reference it. set null : set corresponding value (not entire tuple!!) in referring tuple to null. Semantics of Deletion Deletion proceeds in 2 stages: Marik all tuples for which the WHERE condition is satisfied Go back and delete the markwed tuples. Updating Schema itself Alter: alter a domain or table alter table Course add column numSections integer ; alter table Course drop column breadth ; Drop: remove a domain, table, or whole schema drop table course ; delete from course removes all referring rows.","title":"Data Definition Language(DDL)"},{"location":"CSC343/ddl/#data-definition-languageddl","text":"","title":"Data Definition Language(DDL)"},{"location":"CSC343/ddl/#types","text":"Each column must have a type. List of possible types: Char(n): fixed-length string of n characters, padded with blanks if necessary Varchar(n): variable-length string of up to n characters Text: variable-length, unlimited . PSQL and other implementations support it, but it's not in SQL standard. Int: just integer Float: Real number(+/-, decimal places, etc) e.g: 1.49, 37.96e2 Boolean e.g: TRUE, FALSE Time-related: Date : just the date, no time in hrs, minuts, e.g: \u20182011-09-22\u2019 Time : just the time in hrs, minutes, etc, no Date, e.g: '15:00:02.5' TimeStamp : you know both the time + the date, e.g: 'Jan-12-2011 10:25'","title":"Types"},{"location":"CSC343/ddl/#user-defined-types","text":"Can define your own types, where you can set constraints : create domain Grade as int default null check ( value >= 0 and value <= 100 ); create domain Campus as varchar ( 4 ) default 'StG' check ( value in ( 'StG' , 'UTM' , 'UTSC' )); domain is a data type with optional constraints constraints are checked every time new value is added.","title":"User-defined types"},{"location":"CSC343/ddl/#constraints","text":"Primary key, foreign key, checks, unique, they're all constraints. Can give them a name(except for primary key) by adding constraint << name >> before check ( << condition >> ) constraint gradeInRange check ( value >= 0 ); constraint validCourseReference foreign key ( cNum , dept ) references Course ;","title":"Constraints"},{"location":"CSC343/ddl/#check-constraints","text":"A check constraint is the most generic constraint type. It allows you to specify that the value in a certain column must satisfy a Boolean (truth-value) expression. A check constraint is satisfied if the check expression evaluates to true or the null value. Since most expressions will evaluate to the null value if any operand is null, they will not prevent null values in the constrained columns Check constraint can check across the column, OR across the entire row( in PSQL ). It can also check across the entire table( not in PSQL ). # this one gives the check a name CREATE TABLE products ( product_no integer , name text , price numeric CONSTRAINT positive_price CHECK ( price > 0 ) ); # this one does a general check on the row . CREATE TABLE products ( product_no integer , name text , price numeric CHECK ( price > 0 ), discounted_price numeric CHECK ( discounted_price > 0 ), CHECK ( price > discounted_price ) );","title":"Check Constraints"},{"location":"CSC343/ddl/#not-null-constraints","text":"A not-null constraint simply specifies that a column must not assume the null value. A syntax example: # must always be written as column constraint CREATE TABLE products ( product_no integer NOT NULL , name text NULL , price numeric NOT NULL CHECK ( price > 0 ) ); ### Unique * same format as primary key declaration * set of attributes form a key ( they are unique ) * 1 value + can be null ( or all of them ). two null values are never considered equal in this comparison ( you can think of NULL as unknown ). That means even in the presence of a unique constraint it is possible to store duplicate rows that contain a null value in at least one of the constrained columns . * Can be written as a column constraint or as a tqable constraint . * ` UNIQUE NOT NULL ` has same meaning as ` Primary Key ` except you can have as manu ` unique not null ` as you want but you can only have 1 ` Primary Key ` ``` SQL CREATE TABLE products ( product_no integer UNIQUE , name text , price numeric ); # this specifies that the COMBINATION of prodcut_no and name MUST BE UNIQUE CREATE TABLE products ( product_no integer , name text , price numeric , UNIQUE ( product_no , name ) );","title":"Not null Constraints"},{"location":"CSC343/ddl/#primary-key","text":"Set of attributes forms a key( unique ) link Values are never null ( each one of the attributes is NOT NULL ) Very useful for optimizations Option 1 is if you only have 1 primary key create table Blah ( age1 integer primary key ; age2 integer ; age3 integer ); Option 2 is if you want 1+ primary keys : add pk at the end of table definition(still inside): create table Blah ( age1 integer ; age2 integer ; age3 integer ; primary key ( age1 , age2 ); )","title":"Primary Key"},{"location":"CSC343/ddl/#foreign-key","text":"foreign key ( SID ) references Student Every value of sID in this table must occur in Student table Must be declared either primary key or unique in Student table Has same syntax as unique and Primary Key create table People ( SIN integer primary key , name text , OHIP text unique ); create table Volunteers ( email text primary key , OHIPnum text references People ( OHIP )); age int check ( age > 0 );","title":"Foreign Key"},{"location":"CSC343/ddl/#assertions","text":"Assertions can express ross-table constraints: create assertion ( name ) check ( predicate ); Expensive because have to be checked on every database updated Assertions are not supported by PostreSQL(or most other DBMS's)","title":"Assertions"},{"location":"CSC343/ddl/#triggers","text":"Triggers are compromise between checks AND Assertions They are powerful You control the cost by deciding when they are applied.","title":"Triggers"},{"location":"CSC343/ddl/#process","text":"Specify type of database even you want to respond to: (after delete on Courses, before update of grade on Took, etc) Specify the response: (insert into Winners values (sID)) as a function. Creating the function : create function RecordWinner () returns trigger as $$ begin if new . grade >= 85 then insert into Winners values ( new . sid ); end if ; return new ; end $$ language plpgsql The trigger : create trigger TookUpdate before insert on Took # specify the event for each row execute procedure RecordWinner (); # specify what function you want to u","title":"Process"},{"location":"CSC343/ddl/#reaction-policies","text":"Assume table R refers to table S You can define \"fixes\" propagate backwards from S to R. We define them in R because that's the table that will be affected Cannot define \"fixes\" that propagate forward from R to S.","title":"Reaction Policies"},{"location":"CSC343/ddl/#events","text":"You can react to: on delete(when row deleted in S creates dangling reference) on update(when an update in S creates dangling reference(i.e maybe one of values of p.k is changed)) or both: on delete restrict on update cascade","title":"Events"},{"location":"CSC343/ddl/#reactions","text":"restrict : don't allow the deletion/update in S. Therefore, if I delete a row from S which has a reference in R, DBMS won't let me.W cascade : make the same deletion/update in the referring tuple. if I delete row from S, also delete all rows from R which reference it. set null : set corresponding value (not entire tuple!!) in referring tuple to null.","title":"reactions"},{"location":"CSC343/ddl/#semantics-of-deletion","text":"Deletion proceeds in 2 stages: Marik all tuples for which the WHERE condition is satisfied Go back and delete the markwed tuples.","title":"Semantics of Deletion"},{"location":"CSC343/ddl/#updating-schema-itself","text":"Alter: alter a domain or table alter table Course add column numSections integer ; alter table Course drop column breadth ; Drop: remove a domain, table, or whole schema drop table course ; delete from course removes all referring rows.","title":"Updating Schema itself"},{"location":"CSC343/relational_algebra/","text":"Relational Algebra Definitions Relation : table in SQL Schema : structure of a relation(what columns does it have, what type are they, are there any constraints on its columns). e.g of schema: Teams (name, homefield, coach) Instance : particular data in a relation. Instances frequently change, schemas always never. Tuple : 1 row inside the relation. A row can have this format: {Nick, 21, UofT, CS}, where the attributes( see below ) are {surname, age, university, degree}. Attribute : column in SQL. Attribute of a relation. Every Every tuple must have a value for that in RA(relational algebra). This is not necessarily true for SQL. Database schema : a set of relation schemas Database instance : a set of relation instances All Relations are sets . A relation is a set** of tuples, which means: There can be no duplicate tuples Since it's a set, the order of the tuples doesn't matter . SQL is different since there, relations are bags (they allow duplicates. this will come later.) Constraining the data Superkeys Superkey is a set of attributes(1+) that uniquely identify a tuple in a relation/table key is a minimal superkey. Foreign keys An attribute is a foreign key because it refers to an attribute that is a key in another table . If a key in another table has multiple attributes, then foreign key must also have attributes(since it must contain all attributes of the primary key). R_1[X] \\subseteq R_2[Y] R_1[X] \\subseteq R_2[Y] , e.g: Roles[mID] \\subseteq Movies[mID] Roles[mID] \\subseteq Movies[mID] X and Y are a list of attributes, of same arity Y must be a key in R_2 R_2 : notice that it is a key, not the superkey(we want the minimal set of attributes that uniquely identify a tuple) Note: R_1[X] \\subseteq R_2[Y] R_1[X] \\subseteq R_2[Y] is a foreign key ifff Y is a key for relation R_2 R_2 . Otherwise, it's a normal referential integrity constraint, or inclusion dependency. e.g Artists[mID] \\subseteq Roles[mID] Artists[mID] \\subseteq Roles[mID] If here mID in Roles is not a key, then we can have multiple mID's in Roles in which case this is not a Foreign key constraint. R \\subseteq S R \\subseteq S is equivalent to $ R - S = \\emptyset$ , which essentially means that there is nothing in R that does not exist in S since (R - S only keeps the things that exist in R that do not exist in S). Relational Algebra Basics Assume following schema for our examples: Exercise Schema Movies ( mID , title, director, year, length) Artists ( aID , aName, nationality) Roles ( mID, aID, character ) underlined means that it's the key(not the superkey! technically all of the attributes in a row create a superkey here Foreign key constraints : Roles[mID] \\subseteq Movies[mID] Roles[mID] \\subseteq Movies[mID] Roles[aID] \\subseteq Artists[aID] Roles[aID] \\subseteq Artists[aID] Select operator \\sigma_c(R) \\sigma_c(R) : choose tuples R is a table c is a boolean expression: alive = true \\sigma \\sigma means Select and is used to select all tuples from relation R which satisfy boolean expression c . Result is a relation with same schema as operand, with all attributes from R, but only with tuples which satisfy condition Project operator \\pi_L(R) \\pi_L(R) : choose columns R is a table L is the subset of attributes of R that you want to see(i.e which columns of your relation do you want to see. ) Result is a relation , with all tuples from R , BUT only the attributes in L . Cartesian Product R_1 \\times R_2 R_1 \\times R_2 R1 and R2 are both relations Result is a relation , with every single combination of a tuple from R1 concatenated to a tuple from R2 How many tuples are there in R1 \\times R2 R1 \\times R2 ? That's $\\text{number of rows in R1 } \\times \\text{ number of tuples/rows in R2} Note: If an attribute occurs in both relations, it is prefixed by the relation name: e.g: Movies.mid, Roles.mid Cartesian product can be inconvenient. This is because it will generate a lot of rows that do not make sense. We want only the rows where some attributes from relation A match with some attributes from relation B . We call this operation: Natural Join Natural Join R \\bowtie S R \\bowtie S Result is defined by: taking the Cartesian product selecting to ensure equality on attributes that exist in both relations . projecting to remove duplicate attributes Artists \\bowtie Roles Artists \\bowtie Roles only keeps the tuples/rows where the aID is the same in both Roles and Artists(see the schema above). That means each row will represent information about an artist and a role he played, essentially showing all artists along with the roles that they played Properties Commutative: R \\bowtie S = S \\bowtie R R \\bowtie S = S \\bowtie R Associative: R \\bowtie (S \\bowtie T) = (R \\bowtie S) \\bowtie T R \\bowtie (S \\bowtie T) = (R \\bowtie S) \\bowtie T , which means that brackets are essentially irrelevant, can just do R \\bowtie S \\bowtie T R \\bowtie S \\bowtie T Special cases If no attributes in common: resulting relation is cartesian product of the 2 relations . If one attribute in common: the 2nd column is ommitted from the result(either one of them could be omitted). Different attribute in common: we need to rename the attribute first to have the same name, and then we're back to case 2. No tuples match: if no tuples match, the resulting relation is empty Problems with Natural Join It can over-match if it chooses to join on some attributes that we don't want(let's say it also joins on A.cake = B.cake, when we actually don't want that), so we lose some control over it. It can under-match if we want to join over some attributes that do not have to carry the same name. In that case we first have to rename the attribute, which can be a PITA. The solutions to these problems is a Theta Join Theta Join R \\bowtie_{condition} S R \\bowtie_{condition} S This is syntactic sugar for the following sequence: Perform Cartesian product(you join every row from R to every row from S creating R x S tuples). Select \\sigma \\sigma the rows which satisfy your condition, and in your condition you specify which attributes pairs you want to match. Assignment operator R := Expression R := Expression Alternate notation is R(A_1, A_2,...,A_n):= Expression R(A_1, A_2,...,A_n):= Expression , where you would rename attributes of Expression to A_1,...,A_n A_1,...,A_n and give the new relation the name R. Note : all of the tuples stay the same, just the attributes change + the relation changes. R must be a temporary variable, you will use it for a future query, it serves no permanent purpose. e.g: CSCOffering := \\sigma_{dept = 'csc'}Offering CSCOffering := \\sigma_{dept = 'csc'}Offering TookCSC(sid,grade) := \\pi_{sid, \\; grade} (CSCOffering \\bowtie Took) TookCSC(sid,grade) := \\pi_{sid, \\; grade} (CSCOffering \\bowtie Took) PassedCSC(sid) := \\pi_{sid} (\\sigma_{grade > 50}(TookCSC)) PassedCSC(sid) := \\pi_{sid} (\\sigma_{grade > 50}(TookCSC)) Rename Operator \\rho_{R_1}(R_2) \\rho_{R_1}(R_2) Alternate notation is \\rho_{R_1(A_1,...,A_n)} (R_2) \\rho_{R_1(A_1,...,A_n)} (R_2) : lets you rename all the attributes + the relation We use \\rho \\rho when we want to rename within an expression, and R := Expression R := Expression when we want to create a multi-step query. Set Operations Relations are sets, therefore we can use set operations on them: union, interesection, and difference. ONLY IF operands are relations over same attributes(in number of them, name and order) Summary of Operators Advanced Relational Algebra MAX (min is analogous): Find all tuples that are not max . (using select and projects) Subtract from all to find the maxes (using set operations) k or more : Make all combos of k different tuples that satisfy the condition exactly k \"k or more\" - \"(k+1) or more\" every : create all combinations that should have occurred. Find combinations that did not occur (by subtracting those that did occur from all possible) all - (failures) = every","title":"Relational Algebra"},{"location":"CSC343/relational_algebra/#relational-algebra","text":"","title":"Relational Algebra"},{"location":"CSC343/relational_algebra/#definitions","text":"Relation : table in SQL Schema : structure of a relation(what columns does it have, what type are they, are there any constraints on its columns). e.g of schema: Teams (name, homefield, coach) Instance : particular data in a relation. Instances frequently change, schemas always never. Tuple : 1 row inside the relation. A row can have this format: {Nick, 21, UofT, CS}, where the attributes( see below ) are {surname, age, university, degree}. Attribute : column in SQL. Attribute of a relation. Every Every tuple must have a value for that in RA(relational algebra). This is not necessarily true for SQL. Database schema : a set of relation schemas Database instance : a set of relation instances All Relations are sets . A relation is a set** of tuples, which means: There can be no duplicate tuples Since it's a set, the order of the tuples doesn't matter . SQL is different since there, relations are bags (they allow duplicates. this will come later.)","title":"Definitions"},{"location":"CSC343/relational_algebra/#constraining-the-data","text":"Superkeys Superkey is a set of attributes(1+) that uniquely identify a tuple in a relation/table key is a minimal superkey. Foreign keys An attribute is a foreign key because it refers to an attribute that is a key in another table . If a key in another table has multiple attributes, then foreign key must also have attributes(since it must contain all attributes of the primary key). R_1[X] \\subseteq R_2[Y] R_1[X] \\subseteq R_2[Y] , e.g: Roles[mID] \\subseteq Movies[mID] Roles[mID] \\subseteq Movies[mID] X and Y are a list of attributes, of same arity Y must be a key in R_2 R_2 : notice that it is a key, not the superkey(we want the minimal set of attributes that uniquely identify a tuple) Note: R_1[X] \\subseteq R_2[Y] R_1[X] \\subseteq R_2[Y] is a foreign key ifff Y is a key for relation R_2 R_2 . Otherwise, it's a normal referential integrity constraint, or inclusion dependency. e.g Artists[mID] \\subseteq Roles[mID] Artists[mID] \\subseteq Roles[mID] If here mID in Roles is not a key, then we can have multiple mID's in Roles in which case this is not a Foreign key constraint. R \\subseteq S R \\subseteq S is equivalent to $ R - S = \\emptyset$ , which essentially means that there is nothing in R that does not exist in S since (R - S only keeps the things that exist in R that do not exist in S).","title":"Constraining the data"},{"location":"CSC343/relational_algebra/#relational-algebra-basics","text":"Assume following schema for our examples: Exercise Schema Movies ( mID , title, director, year, length) Artists ( aID , aName, nationality) Roles ( mID, aID, character ) underlined means that it's the key(not the superkey! technically all of the attributes in a row create a superkey here Foreign key constraints : Roles[mID] \\subseteq Movies[mID] Roles[mID] \\subseteq Movies[mID] Roles[aID] \\subseteq Artists[aID] Roles[aID] \\subseteq Artists[aID]","title":"Relational Algebra Basics"},{"location":"CSC343/relational_algebra/#select-operator-sigma_crsigma_cr-choose-tuples","text":"R is a table c is a boolean expression: alive = true \\sigma \\sigma means Select and is used to select all tuples from relation R which satisfy boolean expression c . Result is a relation with same schema as operand, with all attributes from R, but only with tuples which satisfy condition","title":"Select operator \\sigma_c(R)\\sigma_c(R): choose tuples"},{"location":"CSC343/relational_algebra/#project-operator-pi_lrpi_lr-choose-columns","text":"R is a table L is the subset of attributes of R that you want to see(i.e which columns of your relation do you want to see. ) Result is a relation , with all tuples from R , BUT only the attributes in L .","title":"Project operator \\pi_L(R)\\pi_L(R): choose columns"},{"location":"CSC343/relational_algebra/#cartesian-product-r_1-times-r_2r_1-times-r_2","text":"R1 and R2 are both relations Result is a relation , with every single combination of a tuple from R1 concatenated to a tuple from R2 How many tuples are there in R1 \\times R2 R1 \\times R2 ? That's $\\text{number of rows in R1 } \\times \\text{ number of tuples/rows in R2} Note: If an attribute occurs in both relations, it is prefixed by the relation name: e.g: Movies.mid, Roles.mid Cartesian product can be inconvenient. This is because it will generate a lot of rows that do not make sense. We want only the rows where some attributes from relation A match with some attributes from relation B . We call this operation: Natural Join","title":"Cartesian Product R_1 \\times R_2R_1 \\times R_2"},{"location":"CSC343/relational_algebra/#natural-join-r-bowtie-sr-bowtie-s","text":"Result is defined by: taking the Cartesian product selecting to ensure equality on attributes that exist in both relations . projecting to remove duplicate attributes Artists \\bowtie Roles Artists \\bowtie Roles only keeps the tuples/rows where the aID is the same in both Roles and Artists(see the schema above). That means each row will represent information about an artist and a role he played, essentially showing all artists along with the roles that they played","title":"Natural Join R \\bowtie SR \\bowtie S"},{"location":"CSC343/relational_algebra/#properties","text":"Commutative: R \\bowtie S = S \\bowtie R R \\bowtie S = S \\bowtie R Associative: R \\bowtie (S \\bowtie T) = (R \\bowtie S) \\bowtie T R \\bowtie (S \\bowtie T) = (R \\bowtie S) \\bowtie T , which means that brackets are essentially irrelevant, can just do R \\bowtie S \\bowtie T R \\bowtie S \\bowtie T","title":"Properties"},{"location":"CSC343/relational_algebra/#special-cases","text":"If no attributes in common: resulting relation is cartesian product of the 2 relations . If one attribute in common: the 2nd column is ommitted from the result(either one of them could be omitted). Different attribute in common: we need to rename the attribute first to have the same name, and then we're back to case 2. No tuples match: if no tuples match, the resulting relation is empty","title":"Special cases"},{"location":"CSC343/relational_algebra/#problems-with-natural-join","text":"It can over-match if it chooses to join on some attributes that we don't want(let's say it also joins on A.cake = B.cake, when we actually don't want that), so we lose some control over it. It can under-match if we want to join over some attributes that do not have to carry the same name. In that case we first have to rename the attribute, which can be a PITA. The solutions to these problems is a Theta Join","title":"Problems with Natural Join"},{"location":"CSC343/relational_algebra/#theta-join-r-bowtie_condition-sr-bowtie_condition-s","text":"This is syntactic sugar for the following sequence: Perform Cartesian product(you join every row from R to every row from S creating R x S tuples). Select \\sigma \\sigma the rows which satisfy your condition, and in your condition you specify which attributes pairs you want to match.","title":"Theta Join R \\bowtie_{condition} SR \\bowtie_{condition} S"},{"location":"CSC343/relational_algebra/#assignment-operator-r-expressionr-expression","text":"Alternate notation is R(A_1, A_2,...,A_n):= Expression R(A_1, A_2,...,A_n):= Expression , where you would rename attributes of Expression to A_1,...,A_n A_1,...,A_n and give the new relation the name R. Note : all of the tuples stay the same, just the attributes change + the relation changes. R must be a temporary variable, you will use it for a future query, it serves no permanent purpose. e.g: CSCOffering := \\sigma_{dept = 'csc'}Offering CSCOffering := \\sigma_{dept = 'csc'}Offering TookCSC(sid,grade) := \\pi_{sid, \\; grade} (CSCOffering \\bowtie Took) TookCSC(sid,grade) := \\pi_{sid, \\; grade} (CSCOffering \\bowtie Took) PassedCSC(sid) := \\pi_{sid} (\\sigma_{grade > 50}(TookCSC)) PassedCSC(sid) := \\pi_{sid} (\\sigma_{grade > 50}(TookCSC))","title":"Assignment operator R := ExpressionR := Expression"},{"location":"CSC343/relational_algebra/#rename-operator-rho_r_1r_2rho_r_1r_2","text":"Alternate notation is \\rho_{R_1(A_1,...,A_n)} (R_2) \\rho_{R_1(A_1,...,A_n)} (R_2) : lets you rename all the attributes + the relation We use \\rho \\rho when we want to rename within an expression, and R := Expression R := Expression when we want to create a multi-step query.","title":"Rename Operator \\rho_{R_1}(R_2)\\rho_{R_1}(R_2)"},{"location":"CSC343/relational_algebra/#set-operations","text":"Relations are sets, therefore we can use set operations on them: union, interesection, and difference. ONLY IF operands are relations over same attributes(in number of them, name and order)","title":"Set Operations"},{"location":"CSC343/relational_algebra/#summary-of-operators","text":"","title":"Summary of Operators"},{"location":"CSC343/relational_algebra/#advanced-relational-algebra","text":"MAX (min is analogous): Find all tuples that are not max . (using select and projects) Subtract from all to find the maxes (using set operations) k or more : Make all combos of k different tuples that satisfy the condition exactly k \"k or more\" - \"(k+1) or more\" every : create all combinations that should have occurred. Find combinations that did not occur (by subtracting those that did occur from all possible) all - (failures) = every","title":"Advanced Relational Algebra"},{"location":"CSC343/schema/","text":"Schemas Think of a Schema the same as a database. With Schemas, you can create different namespaces. , useful to avoid name clashes. Think of it as a big pot, which contains everythihng inside of it(tables, types, etc). The Search Path See the search path: SHOW search_path Set the search path: SET search_path TO University , public ; (set multiple paths in the search path) default search path is $ user , public Schema $ user is not created, but if you create it, it's already in the search path Schema public is created for you, and if you don't specify an alternate schema, everything is created in there by default. Working with a Schema Creating a schema Create your own schema: CREATE SCHEMA University . To refer to things inside of the schema: CREATE TABLE University . Student (...); SELECT * FROM University . Student ; Note : If you refer to a name withouts pecifying what schema it is within: any new names you define will go to default schema (public). If you create table frindle, goes to (public.frindle) Removing a Schema remove a schema: DROP SCHEMA University cascade IF EXISTS cascade means everything inside is droped(recursively) IF EXISTS is there to avoid getting error message Usage Pattern Can put the following at the top of every DDL file(Data Definition Language, language used to describe database schemas, saved in a plain text format) DROP SCHEMA IF EXISTS University CASCADE ; CREATE SCHEMA University ; SET SEARCH_PATH TO University ; Here's a good workflow: Create DDL file with the schema(Drop previous schema, create new schema, initialize all of your tables). Create a file(SQL dump) which inserts content in the database, and import them. Run queries directly in shell or by importing queries written in files.","title":"Schemas"},{"location":"CSC343/schema/#schemas","text":"Think of a Schema the same as a database. With Schemas, you can create different namespaces. , useful to avoid name clashes. Think of it as a big pot, which contains everythihng inside of it(tables, types, etc).","title":"Schemas"},{"location":"CSC343/schema/#the-search-path","text":"See the search path: SHOW search_path Set the search path: SET search_path TO University , public ; (set multiple paths in the search path) default search path is $ user , public Schema $ user is not created, but if you create it, it's already in the search path Schema public is created for you, and if you don't specify an alternate schema, everything is created in there by default.","title":"The Search Path"},{"location":"CSC343/schema/#working-with-a-schema","text":"","title":"Working with a Schema"},{"location":"CSC343/schema/#creating-a-schema","text":"Create your own schema: CREATE SCHEMA University . To refer to things inside of the schema: CREATE TABLE University . Student (...); SELECT * FROM University . Student ; Note : If you refer to a name withouts pecifying what schema it is within: any new names you define will go to default schema (public). If you create table frindle, goes to (public.frindle)","title":"Creating a schema"},{"location":"CSC343/schema/#removing-a-schema","text":"remove a schema: DROP SCHEMA University cascade IF EXISTS cascade means everything inside is droped(recursively) IF EXISTS is there to avoid getting error message","title":"Removing a Schema"},{"location":"CSC343/schema/#usage-pattern","text":"Can put the following at the top of every DDL file(Data Definition Language, language used to describe database schemas, saved in a plain text format) DROP SCHEMA IF EXISTS University CASCADE ; CREATE SCHEMA University ; SET SEARCH_PATH TO University ; Here's a good workflow: Create DDL file with the schema(Drop previous schema, create new schema, initialize all of your tables). Create a file(SQL dump) which inserts content in the database, and import them. Run queries directly in shell or by importing queries written in files.","title":"Usage Pattern"},{"location":"CSC343/sql_dml_1/","text":"Data Manipulation Language(DML) DDL: used for defining schemas DML: used for writing queries and modifying databases Order of Execution FROM clause & Joins determine initial table. WHERE filters rows individually according to data FROM 1 row satisfying a condition. GROUP BY combines rows after WHERE into groups Having filters the groups. Goes through the Groups and just like where filters rows, it filters groups according to each group satisfying a condition. ORDER BY arranges remaining rows/groups TOP only chooses N amount of rows. SELECT selects only the right columns. Basic queries Renaming tables: employee e renames table employee to e for duration of query --table e renames table to e. SELECT e . name , d . name FROM employee e , department d WHERE d . name = \u2018 marketing \u2019 AND e . name = \u2018 Horton \u2019 ; Renaming attributes: Use: attribute AS new_name select name AS title , dept FROM course ; Order relations: add as final clause ORDER BY ( attribute_list ) [ DESC / ASC ] Ordering can include expressions : ORDER BY sales + rentals Ordering is last thing done before SELECT, so all attributes are still available. SELECT with expressions: SELECT sid , grade + 10 AS adjusted FROM Took ; SELECT dept || cnum FROM course ; --Notice how every value in breadthRequirement column will be 'satisfies' SELECT dept , 'satisfies' AS breadthRequirement FROM Course WHERE breadth ; Comparing string to a pattern: Patterns are: %(means any string, of 0+ length), _(any single character ) Comparisons are done with: attribute LIKE '%pattern_' and attribute NOT LIKE '%pattern_' SELECT * FROM COURSE WHERE name LIKE '%Comp%' ; Aggregation and Grouping These include: SUM, AVG, COUNT, MIN, MAX, which can be applied to a column in a SELECT clause. When they are applied, they will only create 1 ROW, since by default they will take the aggregate function across the entire table. If we have a SELECT-FROM-WHERE with GROUP BY, tuples are grouped according to values of those attributes AND any aggregation gives us a single value per group SELECT : Each element of SELECT must be either an aggregate function(SUM, MAX, MIN, COUN), or an attribute on the GROUP BY list. HAVING : similar to select, HAVING can refer to attributes ONLY IF they're aggregate functions OR attributes of GROUP BY list. Union, Intersection and Difference ( subquery ) UNION / INTERSECT / EXCEPT / UNION ALL ( subquery ) --brackets are mandatory ( SELECT sid FROM Took WHERE grade > 95 ) UNION ( SELECT sid FROM Took WHERE grade < 50 ) Union ALL does not eliminate duplicates, but Union does. EXCEPT returns the distinct rows that do not appear in a second result set. ** Controlling Duplicate Elimination We remove duplicate rows with SELECT DISTINCT We force to keep duplicates by doing UNION ALL Views A view is a relation(table) defined in terms of stored table( base tables ) + other views. You can access a view like a base table. There are 2 types of views: Virtual : no tuples are stored, view is just a query constructed dynamically when needed(from base tables + other views) Materialized : constructed and stored. Problem is: Expensive to maintain! , because you need to modify memory every time. Views are used to: Break down a large query Provide another way of looking at the same data View for students who earned an 80 or higher in a CSC course. CREATE VIEW topresults AS -- this is the main line. The rest is a normal query. SELECT firstname , surname , cnum FROM Student , Took , Offering WHERE Student . sid = Took . sid AND Took . oid = Offering . oid AND grade >= 80 AND dept = 'CSC' ; We will only use virtual views. psql only started supporting materialized views recently.","title":"Data Manipulation Language(DML)"},{"location":"CSC343/sql_dml_1/#data-manipulation-languagedml","text":"DDL: used for defining schemas DML: used for writing queries and modifying databases","title":"Data Manipulation Language(DML)"},{"location":"CSC343/sql_dml_1/#order-of-execution","text":"FROM clause & Joins determine initial table. WHERE filters rows individually according to data FROM 1 row satisfying a condition. GROUP BY combines rows after WHERE into groups Having filters the groups. Goes through the Groups and just like where filters rows, it filters groups according to each group satisfying a condition. ORDER BY arranges remaining rows/groups TOP only chooses N amount of rows. SELECT selects only the right columns.","title":"Order of Execution"},{"location":"CSC343/sql_dml_1/#basic-queries","text":"Renaming tables: employee e renames table employee to e for duration of query --table e renames table to e. SELECT e . name , d . name FROM employee e , department d WHERE d . name = \u2018 marketing \u2019 AND e . name = \u2018 Horton \u2019 ; Renaming attributes: Use: attribute AS new_name select name AS title , dept FROM course ; Order relations: add as final clause ORDER BY ( attribute_list ) [ DESC / ASC ] Ordering can include expressions : ORDER BY sales + rentals Ordering is last thing done before SELECT, so all attributes are still available. SELECT with expressions: SELECT sid , grade + 10 AS adjusted FROM Took ; SELECT dept || cnum FROM course ; --Notice how every value in breadthRequirement column will be 'satisfies' SELECT dept , 'satisfies' AS breadthRequirement FROM Course WHERE breadth ; Comparing string to a pattern: Patterns are: %(means any string, of 0+ length), _(any single character ) Comparisons are done with: attribute LIKE '%pattern_' and attribute NOT LIKE '%pattern_' SELECT * FROM COURSE WHERE name LIKE '%Comp%' ;","title":"Basic queries"},{"location":"CSC343/sql_dml_1/#aggregation-and-grouping","text":"These include: SUM, AVG, COUNT, MIN, MAX, which can be applied to a column in a SELECT clause. When they are applied, they will only create 1 ROW, since by default they will take the aggregate function across the entire table. If we have a SELECT-FROM-WHERE with GROUP BY, tuples are grouped according to values of those attributes AND any aggregation gives us a single value per group SELECT : Each element of SELECT must be either an aggregate function(SUM, MAX, MIN, COUN), or an attribute on the GROUP BY list. HAVING : similar to select, HAVING can refer to attributes ONLY IF they're aggregate functions OR attributes of GROUP BY list.","title":"Aggregation and Grouping"},{"location":"CSC343/sql_dml_1/#union-intersection-and-difference","text":"( subquery ) UNION / INTERSECT / EXCEPT / UNION ALL ( subquery ) --brackets are mandatory ( SELECT sid FROM Took WHERE grade > 95 ) UNION ( SELECT sid FROM Took WHERE grade < 50 ) Union ALL does not eliminate duplicates, but Union does. EXCEPT returns the distinct rows that do not appear in a second result set. **","title":"Union, Intersection and Difference"},{"location":"CSC343/sql_dml_1/#controlling-duplicate-elimination","text":"We remove duplicate rows with SELECT DISTINCT We force to keep duplicates by doing UNION ALL","title":"Controlling Duplicate Elimination"},{"location":"CSC343/sql_dml_1/#views","text":"A view is a relation(table) defined in terms of stored table( base tables ) + other views. You can access a view like a base table. There are 2 types of views: Virtual : no tuples are stored, view is just a query constructed dynamically when needed(from base tables + other views) Materialized : constructed and stored. Problem is: Expensive to maintain! , because you need to modify memory every time. Views are used to: Break down a large query Provide another way of looking at the same data View for students who earned an 80 or higher in a CSC course. CREATE VIEW topresults AS -- this is the main line. The rest is a normal query. SELECT firstname , surname , cnum FROM Student , Took , Offering WHERE Student . sid = Took . sid AND Took . oid = Offering . oid AND grade >= 80 AND dept = 'CSC' ; We will only use virtual views. psql only started supporting materialized views recently.","title":"Views"},{"location":"CSC343/sql_dml_2/","text":"Outer Joins Traditional Joins FROM R , S FROM R cross join S FROM R natural join S FROM R join S on Condition Dangling tuples : With joins that require some attributes to match, tuples lacking a match are left out of the results. Outer join preserves dangling tuple by padding them with NULL in the other relation. Inner join(normal join) doesn't pad with NULL Outer joins A { LEFT | RIGHT | FULL } JOIN B ON C --Theta Outer Joins A NATURAL { LEFT | RIGHT | FULL } JOIN B --Natural Outer Joins Left/Right Join preserves dangling tuples on LHS/RHS, pads with nulls on opposite side. Full Join preserves dangling tuples on BOTH sides. Null Values Checking for null values : IS NULL and IS NOT NULL In SQL we have 3 truth-values: True, False, Unknown. Think of True = 1, False = 0, Unknown = 0.5 Boolean operators : AND is min, OR is max, NOT is (1-x) Null value Usage WHERE (and therefore NATURAL JOINS ) ignore Null values, so if you have any rows with Null's, you ignore them. Aggregation ignores NULL. Null never contributes to a sum, average or count, UNLESS every value is Null. In that case, count is 0. SELECT consideres 2 null values equal. So if you do select distinct on {[a,null], [a,null]} you just get 1 null Set operations consider 2 null values equal","title":"Outer Joins"},{"location":"CSC343/sql_dml_2/#outer-joins","text":"Traditional Joins FROM R , S FROM R cross join S FROM R natural join S FROM R join S on Condition Dangling tuples : With joins that require some attributes to match, tuples lacking a match are left out of the results. Outer join preserves dangling tuple by padding them with NULL in the other relation. Inner join(normal join) doesn't pad with NULL Outer joins A { LEFT | RIGHT | FULL } JOIN B ON C --Theta Outer Joins A NATURAL { LEFT | RIGHT | FULL } JOIN B --Natural Outer Joins Left/Right Join preserves dangling tuples on LHS/RHS, pads with nulls on opposite side. Full Join preserves dangling tuples on BOTH sides.","title":"Outer Joins"},{"location":"CSC343/sql_dml_2/#null-values","text":"Checking for null values : IS NULL and IS NOT NULL In SQL we have 3 truth-values: True, False, Unknown. Think of True = 1, False = 0, Unknown = 0.5 Boolean operators : AND is min, OR is max, NOT is (1-x)","title":"Null Values"},{"location":"CSC343/sql_dml_2/#null-value-usage","text":"WHERE (and therefore NATURAL JOINS ) ignore Null values, so if you have any rows with Null's, you ignore them. Aggregation ignores NULL. Null never contributes to a sum, average or count, UNLESS every value is Null. In that case, count is 0. SELECT consideres 2 null values equal. So if you do select distinct on {[a,null], [a,null]} you just get 1 null Set operations consider 2 null values equal","title":"Null value Usage"},{"location":"CSC343/subqueries/","text":"Subqueries We can use a (Subquery): In the FROM clause in the WHERE , provided it returns 1 result Subquery must be named, so we can refer to it from outer query. FROM : SELECT sid , dept || cnum as course , grade FROM ( SELECT * FROM Offering WHERE instructor = \u2018 Horton \u2019 ) Hoffering WHERE Took . oid = Hoffering . oid ; WHERE : only if subquery guaranteed to produce exactly one value. SELECT sid , surname FROM Student WHERE cgpa > ( SELECT cgpa FROM Student WHERE sid = 99999 ); Subquery is run first , and if it returns more than 1 value, SQL returns an error. If subquery reutrns null, then WHERE ignores it, beacuse a >, <, =, <> null is ignored. Any, All, IN,EXISTS When a subquery can return multiple values, we can use a quantifier --Comparisons x comparison ANY / SOME ( subquery ) -- comparison holds FOR AT LEAST ONE tuple in subquery result --Belonging to results x comparison ALL ( subquery ) -- TRUE iff comparison holds FOR EVERY tuple x IN ( subquery ) --TRUE iff x is in set of rows. --Existing EXISTS ( subquery ) --TRUE iff subquery has at least one tuple NOT EXISTS ( subquery ) --TRUE iff subquery doesn't exist Scope Queries are evaluated from inside out If a name refers to more than one thing, use the most closely nested one If subquery refers only to names defined inside of it, it can be evaluated once and then used repeatedly inthe query. Otherwise it's evaluated once for each tuple in the outer query.","title":"Subqueries"},{"location":"CSC343/subqueries/#subqueries","text":"We can use a (Subquery): In the FROM clause in the WHERE , provided it returns 1 result Subquery must be named, so we can refer to it from outer query. FROM : SELECT sid , dept || cnum as course , grade FROM ( SELECT * FROM Offering WHERE instructor = \u2018 Horton \u2019 ) Hoffering WHERE Took . oid = Hoffering . oid ; WHERE : only if subquery guaranteed to produce exactly one value. SELECT sid , surname FROM Student WHERE cgpa > ( SELECT cgpa FROM Student WHERE sid = 99999 ); Subquery is run first , and if it returns more than 1 value, SQL returns an error. If subquery reutrns null, then WHERE ignores it, beacuse a >, <, =, <> null is ignored.","title":"Subqueries"},{"location":"CSC343/subqueries/#any-all-inexists","text":"When a subquery can return multiple values, we can use a quantifier --Comparisons x comparison ANY / SOME ( subquery ) -- comparison holds FOR AT LEAST ONE tuple in subquery result --Belonging to results x comparison ALL ( subquery ) -- TRUE iff comparison holds FOR EVERY tuple x IN ( subquery ) --TRUE iff x is in set of rows. --Existing EXISTS ( subquery ) --TRUE iff subquery has at least one tuple NOT EXISTS ( subquery ) --TRUE iff subquery doesn't exist","title":"Any, All, IN,EXISTS"},{"location":"CSC343/subqueries/#scope","text":"Queries are evaluated from inside out If a name refers to more than one thing, use the most closely nested one If subquery refers only to names defined inside of it, it can be evaluated once and then used repeatedly inthe query. Otherwise it's evaluated once for each tuple in the outer query.","title":"Scope"},{"location":"CSC369/","text":"","title":"Index"},{"location":"CSC369/l10_synchronization/","text":"Synchronization By design, threads/processes can't anticipate when they are forced to yield the CPU through a context switch. Therefore, we need a way to make sure that threads share memory in a safe manner. We do that with synchronization. Types of synchronization Enforce single use of a shared resource, i.e only 1 thread can access a resource at the same time. This is called the critical section problem . By ensuring only 1 thread can access the resource, that means any future thread will only access it once it is updated, so there is no case where 2 threads are modifying data at the same time. This guarantees correctness. Control order of thread execution. Critical Section(CS) requirements Only 1 thread can access a shared resource at the same time . CS has shared variables which need to be synchronized to maintain consistency of data varaibles. Mutual exclusion If one thread is in the CS, no other thread is. Progress If no thread is executing in the critical section and other threads are waiting outside CS, only threads trying to get into CS section can influence the choice of which thread enters next , and choice cannot be postponed indefinitely . Essentially a process not requesting Critical section should not block other processes from entering the critical section. No starvation (bounded waiting) Once a thread T makes a request to access CS, There is a bound(a limit) on number of times that other threads are allowed to enter CS before thread T is granted access, i.e eventually a thread which wants to access CS must be allowed to access it. First Synchronization attempt: void my_work ( id_t id ){ /* XXXXXXX entry section XXXXXXX */ // repeat indefinitely until it's your turn, // i.e turn becomes your id*/ while ( turn != id ); /* XXXXXXX Critical section XXXXXXX */ // now we're in critical section, only the thread with the right ID(and ids are unique) can access it printf ( \"now you're in critical section\" ); /* XXXXXXX Exiting critical section XXXXXXX */ turn = 1 - id ; //change the id // ... } The above satisfies mutual exclusion : only 1 thread can access CS Above does not satisfy progress : if turn = 0, T1 may not enter even though it has gotten there before T0(or even if T0 is in another section), therefore it's not influencing the choice of which thread enters next, as something else has. If we don't have progress, then we have starvation Second Synchronization attempt Threads can yield execution at ANY TIME after they finish current instruction. A thread cannot switch half-way through executing an instruction. Here, one of them executes condition from while loop, and then GIVES UP CONTROL, at which point when control comes back to it, it's too late to lock the CS. Therefore in this case it does not satisfy mutual exclusion , since multiple threads can be in CS at the same time Synchronization: Peterson's Algorithm //NOTE: loser and flags are both global variables, so both threads have access to them and can modify the global version(and the changes propagate) int loser ; int flags [ 2 ]; /* Show \"interest\" in CS, are both initially 0, aka false*/ void my_work ( id_t id ) { // id will be 0 or 1 depending on which id it is //... flag [ id ] = true ; // entry section // by setting loser to itself, thread is being polite and allows other threads to enter. Assume this thread is the last one to arrive, so it sets loser to itself and the other thread can now move into critical section. loser = id ; // Entrance is granted for T0 if T1 does not want to enter(flag[1-id] is False) OR if T1 gave priority to T0 by setting loser = 1. while ( loser == id && flag [ 1 - id ]); /* Critical section */ printf ( \"in critical section now\" ); /*Exit section */ flag [ id ] = false ; } } Assume 1 thread arrives but not the other. In that case flag for other will be set to False so this thread can go ahead(therefore progress is satisfied-only the threads waiting for CS can get in). If multiple threads want to access something at the same time Final value of turn/loser determines which of the 2 processes is allowed to enter its critical section first , and because turn doesn't change it guarantees mutual exclusion where other thread cannot enter, UNTIL it sets its flag to false. Alg. can be extended to N threads Synchronization: Lamport's Bakery algorithm Upon entering each customer/thread gets a # The thread with lowest number is served next There's no guarantee that 2 threads don't get the same number. In the case of a tie, thread with lowest id is served first. Thread ids are unique and totally ordered. Synchronization Hardware vs Software Peterson's and Lamport's bakery algorithm show that synchronization can be implemented in software . However, hardware instructions make it easier and more efficient to build up higher-level abstractions for synchronization. Disabling interrupts void lock (){ disable_interrupts () } void unlock (){ enable_interrupts () } This is one solution on hardware level to create locks to enable synchronization and ensure mutual exclusion . From Operating Systems : Perhaps the most obvious way of achieving mutual exclusion is to allow a process to disable interrupts before it enters its critical section and then enable interrupts after it leaves its critical section. By disabling interrupts the CPU will be unable to switch processes. This guarantees that the process can use the shared variable without another process accessing it. But, disabling interrupts, is a major undertaking. Disadvantages : The computer will not be able to service interrupts for, maybe, a long time, depending on what a process is doing in a critical section. The process may forget to neable interrupts, which will effectively crash the computer. On multiprocessor systems other processors can still access it, this only stops context switches between threads not between processes. High Level Synchronization types Locks : good for protecting access to critical sections Condition variables (Condition can be any boolean expression): They wait for a condition to become true Semaphores : Basic, easy to understand Good for some race conditions where you can set the order in which threads will execute. race condition : condition where multiple threads access Critical Section and both try to update a shared veriable. Note that reading is not considered updating since it doesn't change the value. Not always the right abstraction Monitors: high-level, ideally have language support( Java)","title":"Synchronization"},{"location":"CSC369/l10_synchronization/#synchronization","text":"By design, threads/processes can't anticipate when they are forced to yield the CPU through a context switch. Therefore, we need a way to make sure that threads share memory in a safe manner. We do that with synchronization.","title":"Synchronization"},{"location":"CSC369/l10_synchronization/#types-of-synchronization","text":"Enforce single use of a shared resource, i.e only 1 thread can access a resource at the same time. This is called the critical section problem . By ensuring only 1 thread can access the resource, that means any future thread will only access it once it is updated, so there is no case where 2 threads are modifying data at the same time. This guarantees correctness. Control order of thread execution.","title":"Types of synchronization"},{"location":"CSC369/l10_synchronization/#critical-sectioncs-requirements","text":"Only 1 thread can access a shared resource at the same time . CS has shared variables which need to be synchronized to maintain consistency of data varaibles. Mutual exclusion If one thread is in the CS, no other thread is. Progress If no thread is executing in the critical section and other threads are waiting outside CS, only threads trying to get into CS section can influence the choice of which thread enters next , and choice cannot be postponed indefinitely . Essentially a process not requesting Critical section should not block other processes from entering the critical section. No starvation (bounded waiting) Once a thread T makes a request to access CS, There is a bound(a limit) on number of times that other threads are allowed to enter CS before thread T is granted access, i.e eventually a thread which wants to access CS must be allowed to access it.","title":"Critical Section(CS) requirements"},{"location":"CSC369/l10_synchronization/#first-synchronization-attempt","text":"void my_work ( id_t id ){ /* XXXXXXX entry section XXXXXXX */ // repeat indefinitely until it's your turn, // i.e turn becomes your id*/ while ( turn != id ); /* XXXXXXX Critical section XXXXXXX */ // now we're in critical section, only the thread with the right ID(and ids are unique) can access it printf ( \"now you're in critical section\" ); /* XXXXXXX Exiting critical section XXXXXXX */ turn = 1 - id ; //change the id // ... } The above satisfies mutual exclusion : only 1 thread can access CS Above does not satisfy progress : if turn = 0, T1 may not enter even though it has gotten there before T0(or even if T0 is in another section), therefore it's not influencing the choice of which thread enters next, as something else has. If we don't have progress, then we have starvation","title":"First Synchronization attempt:"},{"location":"CSC369/l10_synchronization/#second-synchronization-attempt","text":"Threads can yield execution at ANY TIME after they finish current instruction. A thread cannot switch half-way through executing an instruction. Here, one of them executes condition from while loop, and then GIVES UP CONTROL, at which point when control comes back to it, it's too late to lock the CS. Therefore in this case it does not satisfy mutual exclusion , since multiple threads can be in CS at the same time","title":"Second Synchronization attempt"},{"location":"CSC369/l10_synchronization/#synchronization-petersons-algorithm","text":"//NOTE: loser and flags are both global variables, so both threads have access to them and can modify the global version(and the changes propagate) int loser ; int flags [ 2 ]; /* Show \"interest\" in CS, are both initially 0, aka false*/ void my_work ( id_t id ) { // id will be 0 or 1 depending on which id it is //... flag [ id ] = true ; // entry section // by setting loser to itself, thread is being polite and allows other threads to enter. Assume this thread is the last one to arrive, so it sets loser to itself and the other thread can now move into critical section. loser = id ; // Entrance is granted for T0 if T1 does not want to enter(flag[1-id] is False) OR if T1 gave priority to T0 by setting loser = 1. while ( loser == id && flag [ 1 - id ]); /* Critical section */ printf ( \"in critical section now\" ); /*Exit section */ flag [ id ] = false ; } } Assume 1 thread arrives but not the other. In that case flag for other will be set to False so this thread can go ahead(therefore progress is satisfied-only the threads waiting for CS can get in). If multiple threads want to access something at the same time Final value of turn/loser determines which of the 2 processes is allowed to enter its critical section first , and because turn doesn't change it guarantees mutual exclusion where other thread cannot enter, UNTIL it sets its flag to false. Alg. can be extended to N threads","title":"Synchronization: Peterson's Algorithm"},{"location":"CSC369/l10_synchronization/#synchronization-lamports-bakery-algorithm","text":"Upon entering each customer/thread gets a # The thread with lowest number is served next There's no guarantee that 2 threads don't get the same number. In the case of a tie, thread with lowest id is served first. Thread ids are unique and totally ordered.","title":"Synchronization: Lamport's Bakery algorithm"},{"location":"CSC369/l10_synchronization/#synchronization-hardware-vs-software","text":"Peterson's and Lamport's bakery algorithm show that synchronization can be implemented in software . However, hardware instructions make it easier and more efficient to build up higher-level abstractions for synchronization.","title":"Synchronization Hardware vs Software"},{"location":"CSC369/l10_synchronization/#disabling-interrupts","text":"void lock (){ disable_interrupts () } void unlock (){ enable_interrupts () } This is one solution on hardware level to create locks to enable synchronization and ensure mutual exclusion . From Operating Systems : Perhaps the most obvious way of achieving mutual exclusion is to allow a process to disable interrupts before it enters its critical section and then enable interrupts after it leaves its critical section. By disabling interrupts the CPU will be unable to switch processes. This guarantees that the process can use the shared variable without another process accessing it. But, disabling interrupts, is a major undertaking. Disadvantages : The computer will not be able to service interrupts for, maybe, a long time, depending on what a process is doing in a critical section. The process may forget to neable interrupts, which will effectively crash the computer. On multiprocessor systems other processors can still access it, this only stops context switches between threads not between processes.","title":"Disabling interrupts"},{"location":"CSC369/l10_synchronization/#high-level-synchronization-types","text":"Locks : good for protecting access to critical sections Condition variables (Condition can be any boolean expression): They wait for a condition to become true Semaphores : Basic, easy to understand Good for some race conditions where you can set the order in which threads will execute. race condition : condition where multiple threads access Critical Section and both try to update a shared veriable. Note that reading is not considered updating since it doesn't change the value. Not always the right abstraction Monitors: high-level, ideally have language support( Java)","title":"High Level Synchronization types"},{"location":"CSC369/l11_locks/","text":"Locks // Thread creation and destruction // creates a thread int pthread_create ( pthread_t * thread , const pthread_attr_t * attr , void * ( * start_routine ) ( void * ), void * arg ); // example pthread_t t1 ; err = pthread_create ( & t1 , NULL , thread1 , ( void * ) 0 ); // block until child thread finishes int pthread_join ( pthread_t thread , void ** retval ); // example pthread_join ( t1 , NULL ); //pthread exits pthread_exit () // Locks with threads pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER ; pthread_mutex_lock ( & mutex ); count ++ ; printf ( \"%d, %d \\n \" , gettid () % 10 , count ); pthread_mutex_unlock ( & mutex ); Atomic instructions(test and set) boolean TAS ( boolean * lock ){ if ( * lock == False ){ // if no lock, return that there's no lock and lock it. Essentially if there's no lock, we can pass inside the critical section and TAS also locks it. * lock = True ; return False } else { return True ; } } Lock is always true on exit from test-and-set. either it was already True(locked) and nothing changed, or it was False(available), and now the caller holds it. Return value is True if it was locked already, or False if it was previously available Lock implementations Spin Lock boolean lock ; void acquire ( boolean * lock ){ while ( test_and_set ( lock )); // as long as its true, it means it's already locked by somebody else so keep executing while loop. Once it turns to False, it means that it became available, and TAS already locked it for this caller. so this thread now holds it and you can return. } void release ( boolean * lock ){ * lock = false ; // to release simply set to false } Previous example is a spin lock : it uses busy waiting - thread continually executes while loop is in acquire, which consumes CPU cycles. Spin locks have 3 problems: Busy waiting \\rightarrow \\rightarrow consumes CPU cycles Starvation is possible : When a thread leaves its CS, the next one to enter depends completely on scheduling. It depends entirely on which thread the OS chooses to execute next. Therefore, whilst extremely unlikely(very very low chance) it is possible that the OS always chooses some other thread to execute before this one, so this waiting thread could be denied entry indefinitely Deadlock is possible through priority inversion . Sleep Lock wait queues in Linux Instead of spinning, put thread to sleep (into \"blocked state\"), while waiting to acquire lock Requires a queue of waiting threads, from which the OS will choose next thread to wake up. Advantage is that starvation is not possible because the queue can function in a FIFO fashion, such that given all things equal, a thread that asks for a lock first will acquire it first if other threads also want it. wait_event ( queue , condition ); wake_up ( wait_queue_head_t * queue ); Lock example #include <stdio.h> #include <unistd.h> #include <pthread.h> #include <semaphore.h> #include <stdlib.h> #include <sys/types.h> // initialize the lock pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER ; int count = 0 ; // We give threads specific functions to execute. This is the function we want threads // to perform. Thread finishes when it calls pthread_exit(3), if it returns from start routine, // or if it is cancelled (pthread_cancel). // Before returning, a successful call to pthread_create() stores the ID of the new thread in // the buffer pointed to by thread; this identifier is used to refer to the // thread in subsequent call to other pthreads functions. void * thread1 ( void * threadid ){ printf ( \"Start thread %ld \\n \" , gettid ()); int i ; for ( i = 0 ; i < 100000 ; i ++ ){ pthread_mutex_lock ( & mutex ); count ++ ; printf ( \"%d, %d \\n \" , gettid () % 10 , count ); pthread_mutex_unlock ( & mutex ); // simulate doing more work. allows another thread to grab control and print usleep ( 2 ); } printf ( \"End thread %d \\n \" , gettid () % 10 ); pthread_exit ( NULL ); } int main ( int argc , char * argv []){ pthread_t t1 , t2 ; int err ; // create a new thread, and indicate what function it should run. Once you create it, // control might shift directly to the thread, or could still belong to the processor err = pthread_create ( & t1 , NULL , thread1 , ( void * ) 0 ); if ( err ){ printf ( \"Error: pthread_create failed %d. \\n \" , 0 ); exit ( 1 ); } err = pthread_create ( & t2 , NULL , thread1 , ( void * ) 0 ); if ( err ){ printf ( \"Error: pthread_create failed %d. \\n \" , 1 ); exit ( 1 ); } pthread_join ( t1 , NULL ); pthread_join ( t2 , NULL ); printf ( \"Controller \\n \" ); // exiting thread pthread_exit ( NULL ); } example of the output :","title":"Locks"},{"location":"CSC369/l11_locks/#locks","text":"// Thread creation and destruction // creates a thread int pthread_create ( pthread_t * thread , const pthread_attr_t * attr , void * ( * start_routine ) ( void * ), void * arg ); // example pthread_t t1 ; err = pthread_create ( & t1 , NULL , thread1 , ( void * ) 0 ); // block until child thread finishes int pthread_join ( pthread_t thread , void ** retval ); // example pthread_join ( t1 , NULL ); //pthread exits pthread_exit () // Locks with threads pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER ; pthread_mutex_lock ( & mutex ); count ++ ; printf ( \"%d, %d \\n \" , gettid () % 10 , count ); pthread_mutex_unlock ( & mutex );","title":"Locks"},{"location":"CSC369/l11_locks/#atomic-instructionstest-and-set","text":"boolean TAS ( boolean * lock ){ if ( * lock == False ){ // if no lock, return that there's no lock and lock it. Essentially if there's no lock, we can pass inside the critical section and TAS also locks it. * lock = True ; return False } else { return True ; } } Lock is always true on exit from test-and-set. either it was already True(locked) and nothing changed, or it was False(available), and now the caller holds it. Return value is True if it was locked already, or False if it was previously available","title":"Atomic instructions(test and set)"},{"location":"CSC369/l11_locks/#lock-implementations","text":"","title":"Lock implementations"},{"location":"CSC369/l11_locks/#spin-lock","text":"boolean lock ; void acquire ( boolean * lock ){ while ( test_and_set ( lock )); // as long as its true, it means it's already locked by somebody else so keep executing while loop. Once it turns to False, it means that it became available, and TAS already locked it for this caller. so this thread now holds it and you can return. } void release ( boolean * lock ){ * lock = false ; // to release simply set to false } Previous example is a spin lock : it uses busy waiting - thread continually executes while loop is in acquire, which consumes CPU cycles. Spin locks have 3 problems: Busy waiting \\rightarrow \\rightarrow consumes CPU cycles Starvation is possible : When a thread leaves its CS, the next one to enter depends completely on scheduling. It depends entirely on which thread the OS chooses to execute next. Therefore, whilst extremely unlikely(very very low chance) it is possible that the OS always chooses some other thread to execute before this one, so this waiting thread could be denied entry indefinitely Deadlock is possible through priority inversion .","title":"Spin Lock"},{"location":"CSC369/l11_locks/#sleep-lock","text":"wait queues in Linux Instead of spinning, put thread to sleep (into \"blocked state\"), while waiting to acquire lock Requires a queue of waiting threads, from which the OS will choose next thread to wake up. Advantage is that starvation is not possible because the queue can function in a FIFO fashion, such that given all things equal, a thread that asks for a lock first will acquire it first if other threads also want it. wait_event ( queue , condition ); wake_up ( wait_queue_head_t * queue );","title":"Sleep Lock"},{"location":"CSC369/l11_locks/#lock-example","text":"#include <stdio.h> #include <unistd.h> #include <pthread.h> #include <semaphore.h> #include <stdlib.h> #include <sys/types.h> // initialize the lock pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER ; int count = 0 ; // We give threads specific functions to execute. This is the function we want threads // to perform. Thread finishes when it calls pthread_exit(3), if it returns from start routine, // or if it is cancelled (pthread_cancel). // Before returning, a successful call to pthread_create() stores the ID of the new thread in // the buffer pointed to by thread; this identifier is used to refer to the // thread in subsequent call to other pthreads functions. void * thread1 ( void * threadid ){ printf ( \"Start thread %ld \\n \" , gettid ()); int i ; for ( i = 0 ; i < 100000 ; i ++ ){ pthread_mutex_lock ( & mutex ); count ++ ; printf ( \"%d, %d \\n \" , gettid () % 10 , count ); pthread_mutex_unlock ( & mutex ); // simulate doing more work. allows another thread to grab control and print usleep ( 2 ); } printf ( \"End thread %d \\n \" , gettid () % 10 ); pthread_exit ( NULL ); } int main ( int argc , char * argv []){ pthread_t t1 , t2 ; int err ; // create a new thread, and indicate what function it should run. Once you create it, // control might shift directly to the thread, or could still belong to the processor err = pthread_create ( & t1 , NULL , thread1 , ( void * ) 0 ); if ( err ){ printf ( \"Error: pthread_create failed %d. \\n \" , 0 ); exit ( 1 ); } err = pthread_create ( & t2 , NULL , thread1 , ( void * ) 0 ); if ( err ){ printf ( \"Error: pthread_create failed %d. \\n \" , 1 ); exit ( 1 ); } pthread_join ( t1 , NULL ); pthread_join ( t2 , NULL ); printf ( \"Controller \\n \" ); // exiting thread pthread_exit ( NULL ); } example of the output :","title":"Lock example"},{"location":"CSC369/l12_conditional_variables/","text":"Conditional Variables Internal data is just a queue of waiting threads Uses following atomic operations Atomic Operation info : An operation during which a processor can simultaneously read a location and write it in the same bus operation. This prevents any other processor or I/O device from writing or reading memory until the operation is complete. This is why, when a thread performs an atomic operation, the other threads see it as happening instantaneously, and will never interrupt. Atomic operations is that they are relatively quick compared to locks, and do not suffer from deadlock, and convoying. cv_wait ( struct cv * cv , struct lock * lock ) : Releases the lock, Waits(by sleeping) Re-aquires lock before return cv_signal ( struct cv * cv , struct lock * lock ) : Wake one enqueued thread OS picks one lucky thread to wake up cv_broadcast ( struct cv * cv , struct lock * lock ) : Wake all enqueued threads, but only one of them re-acquires(since it previously acquired the lock and then released it to wait on a condition) the mutex(the lock). Always check condition inside while loop before calling cv_wait The other woken-up threads are no longer blocked on pthread_cond_wait . They're no longer in the CV queue , because their condition has been satisfied. . So now they're in the section of the cv_wait function where it tries to acquire the lock again, so it waits until the lock becomes available. The problem is that when they acquire the mutex, the condition might no longer be true, in which case they shouldn't actually hold the lock. This is why cv_wait is wrapped inside of a while loop(see code below). Because thread acquires lock, then executes while loop condition again, sees condition is not true and does cv_wait again, at which point it releases the lock .If condition is true however, then lock moves on to the critical section. This is why we need a while loop instead of an if loop, because we need to check if condition is still true once we wake up from cv_wait . If no one is waiting, signal or broadcast has no effect Conditional variables are always used together with locks . Conditional Variables are used to make locks more selective, and only acquire on a specific condition. The lock protects the shared data that is modified You can't directly modify the lock condition. You can only modify it with signaling or broadcasting, therefore in your while loop check against another variable to see if the condition is true or not. You can update that variable inside of CS, as is the case in the example below . lock_acquire ( lock ); while ( condition not true ){ // this will release the lock for others until condition becomes true, at which point it reaquires the lock and starts executing critical section cv_wait ( cond , lock ); } // ... critical section ... printf ( \"critical section\" ); // ..end section cv_signal ( cond ); // or cv_broadcast(cond) lock_release ( lock ); Real example #include <stdio.h> #include <stdlib.h> #include <pthread.h> #include <semaphore.h> // we only need 1 lock pthread_mutex_t region_mutex = PTHREAD_MUTEX_INITIALIZER ; pthread_cond_t space_available = PTHREAD_COND_INITIALIZER ; pthread_cond_t has_some_data = PTHREAD_COND_INITIALIZER ; #define MAX 25 int buffer [ MAX ]; int nextfill = 0 ; int nextuse = 0 ; int size = 0 ; int loops = 0 ; void add_buffer ( int value ) { buffer [ nextfill ] = value ; nextfill = ( nextfill + 1 ) % MAX ; size ++ ; } int use_buffer () { int tmp = buffer [ nextuse ]; nextuse = ( nextuse + 1 ) % MAX ; size -- ; return tmp ; } void * producer ( void * arg ) { int i , id = * ( int * )( arg ); for ( i = 0 ; i < loops ; i ++ ) { pthread_mutex_lock ( & region_mutex ); // WARNING: always need to do a while instead of an If for conditional variables, because we need to check if they still satisfy the condition while ( size == MAX ) { // it will release the lock and wait until space_available becomes true(1). at that point // it reaquires the lock pthread_cond_wait ( & space_available , & region_mutex ); } printf ( \"Producer[%d] producing: %d \\n \" , id , i ); add_buffer ( i ); pthread_cond_signal ( & has_some_data ); pthread_mutex_unlock ( & region_mutex ); } return NULL ; } void * consumer ( void * arg ) { int i , id = * ( int * ) arg ; for ( i = 0 ; i < loops ; i ++ ) { pthread_mutex_lock ( & region_mutex ); while ( size == 0 ) { pthread_cond_wait ( & has_some_data , & region_mutex ); } int tmp = use_buffer (); printf ( \" \\t Consumer[%d] consumed: %d \\n \" , id , tmp ); pthread_cond_signal ( & space_available ); pthread_mutex_unlock ( & region_mutex ); } return NULL ; } #define PRODUCERS 1 #define CONSUMERS 1 int main ( int argc , char * argv []) { int i , pid [ PRODUCERS ], cid [ CONSUMERS ]; if ( argc != 2 ) { fprintf ( stderr , \"usage: %s <value> \\n \" , argv [ 0 ]); exit ( 1 ); } loops = atoi ( argv [ 1 ]); // array of threads both for consumers and for producers pthread_t P [ PRODUCERS ], C [ CONSUMERS ]; for ( i = 0 ; i < PRODUCERS ; i ++ ) { pid [ i ] = i ; // create PRODUCERS amount of threads, // which will execute function producer pthread_create ( & P [ i ], NULL , producer , & pid [ i ]); } for ( i = 0 ; i < CONSUMERS ; i ++ ) { cid [ i ] = i ; // produce pthread_create ( & C [ i ], NULL , consumer , & cid [ i ]); } // now make main thread wait for all producer threads for ( i = 0 ; i < PRODUCERS ; i ++ ) { pthread_join ( P [ i ], NULL ); } // make main thread wait for all consumer threads for ( i = 0 ; i < CONSUMERS ; i ++ ) { pthread_join ( C [ i ], NULL ); } return 0 ; } Classical Problems in Multithreading Producer/Consumer Problem See locks chapter Reader/Writer Problem Notice that read is outside of the CS because we want to have multiple readers able to read at the same time In the writer section, threads block until readcount becomes 0. Essentially they wait until all threads are finished reading. Summary of Locks + Conditional Variable Locks provide mutual exclusion for critical sections CV block a thread that has to wait for something to happen first","title":"Conditional Variables"},{"location":"CSC369/l12_conditional_variables/#conditional-variables","text":"Internal data is just a queue of waiting threads Uses following atomic operations Atomic Operation info : An operation during which a processor can simultaneously read a location and write it in the same bus operation. This prevents any other processor or I/O device from writing or reading memory until the operation is complete. This is why, when a thread performs an atomic operation, the other threads see it as happening instantaneously, and will never interrupt. Atomic operations is that they are relatively quick compared to locks, and do not suffer from deadlock, and convoying. cv_wait ( struct cv * cv , struct lock * lock ) : Releases the lock, Waits(by sleeping) Re-aquires lock before return cv_signal ( struct cv * cv , struct lock * lock ) : Wake one enqueued thread OS picks one lucky thread to wake up cv_broadcast ( struct cv * cv , struct lock * lock ) : Wake all enqueued threads, but only one of them re-acquires(since it previously acquired the lock and then released it to wait on a condition) the mutex(the lock). Always check condition inside while loop before calling cv_wait The other woken-up threads are no longer blocked on pthread_cond_wait . They're no longer in the CV queue , because their condition has been satisfied. . So now they're in the section of the cv_wait function where it tries to acquire the lock again, so it waits until the lock becomes available. The problem is that when they acquire the mutex, the condition might no longer be true, in which case they shouldn't actually hold the lock. This is why cv_wait is wrapped inside of a while loop(see code below). Because thread acquires lock, then executes while loop condition again, sees condition is not true and does cv_wait again, at which point it releases the lock .If condition is true however, then lock moves on to the critical section. This is why we need a while loop instead of an if loop, because we need to check if condition is still true once we wake up from cv_wait . If no one is waiting, signal or broadcast has no effect Conditional variables are always used together with locks . Conditional Variables are used to make locks more selective, and only acquire on a specific condition. The lock protects the shared data that is modified You can't directly modify the lock condition. You can only modify it with signaling or broadcasting, therefore in your while loop check against another variable to see if the condition is true or not. You can update that variable inside of CS, as is the case in the example below . lock_acquire ( lock ); while ( condition not true ){ // this will release the lock for others until condition becomes true, at which point it reaquires the lock and starts executing critical section cv_wait ( cond , lock ); } // ... critical section ... printf ( \"critical section\" ); // ..end section cv_signal ( cond ); // or cv_broadcast(cond) lock_release ( lock );","title":"Conditional Variables"},{"location":"CSC369/l12_conditional_variables/#real-example","text":"#include <stdio.h> #include <stdlib.h> #include <pthread.h> #include <semaphore.h> // we only need 1 lock pthread_mutex_t region_mutex = PTHREAD_MUTEX_INITIALIZER ; pthread_cond_t space_available = PTHREAD_COND_INITIALIZER ; pthread_cond_t has_some_data = PTHREAD_COND_INITIALIZER ; #define MAX 25 int buffer [ MAX ]; int nextfill = 0 ; int nextuse = 0 ; int size = 0 ; int loops = 0 ; void add_buffer ( int value ) { buffer [ nextfill ] = value ; nextfill = ( nextfill + 1 ) % MAX ; size ++ ; } int use_buffer () { int tmp = buffer [ nextuse ]; nextuse = ( nextuse + 1 ) % MAX ; size -- ; return tmp ; } void * producer ( void * arg ) { int i , id = * ( int * )( arg ); for ( i = 0 ; i < loops ; i ++ ) { pthread_mutex_lock ( & region_mutex ); // WARNING: always need to do a while instead of an If for conditional variables, because we need to check if they still satisfy the condition while ( size == MAX ) { // it will release the lock and wait until space_available becomes true(1). at that point // it reaquires the lock pthread_cond_wait ( & space_available , & region_mutex ); } printf ( \"Producer[%d] producing: %d \\n \" , id , i ); add_buffer ( i ); pthread_cond_signal ( & has_some_data ); pthread_mutex_unlock ( & region_mutex ); } return NULL ; } void * consumer ( void * arg ) { int i , id = * ( int * ) arg ; for ( i = 0 ; i < loops ; i ++ ) { pthread_mutex_lock ( & region_mutex ); while ( size == 0 ) { pthread_cond_wait ( & has_some_data , & region_mutex ); } int tmp = use_buffer (); printf ( \" \\t Consumer[%d] consumed: %d \\n \" , id , tmp ); pthread_cond_signal ( & space_available ); pthread_mutex_unlock ( & region_mutex ); } return NULL ; } #define PRODUCERS 1 #define CONSUMERS 1 int main ( int argc , char * argv []) { int i , pid [ PRODUCERS ], cid [ CONSUMERS ]; if ( argc != 2 ) { fprintf ( stderr , \"usage: %s <value> \\n \" , argv [ 0 ]); exit ( 1 ); } loops = atoi ( argv [ 1 ]); // array of threads both for consumers and for producers pthread_t P [ PRODUCERS ], C [ CONSUMERS ]; for ( i = 0 ; i < PRODUCERS ; i ++ ) { pid [ i ] = i ; // create PRODUCERS amount of threads, // which will execute function producer pthread_create ( & P [ i ], NULL , producer , & pid [ i ]); } for ( i = 0 ; i < CONSUMERS ; i ++ ) { cid [ i ] = i ; // produce pthread_create ( & C [ i ], NULL , consumer , & cid [ i ]); } // now make main thread wait for all producer threads for ( i = 0 ; i < PRODUCERS ; i ++ ) { pthread_join ( P [ i ], NULL ); } // make main thread wait for all consumer threads for ( i = 0 ; i < CONSUMERS ; i ++ ) { pthread_join ( C [ i ], NULL ); } return 0 ; }","title":"Real example"},{"location":"CSC369/l12_conditional_variables/#classical-problems-in-multithreading","text":"","title":"Classical Problems in Multithreading"},{"location":"CSC369/l12_conditional_variables/#producerconsumer-problem","text":"See locks chapter","title":"Producer/Consumer Problem"},{"location":"CSC369/l12_conditional_variables/#readerwriter-problem","text":"Notice that read is outside of the CS because we want to have multiple readers able to read at the same time In the writer section, threads block until readcount becomes 0. Essentially they wait until all threads are finished reading.","title":"Reader/Writer Problem"},{"location":"CSC369/l12_conditional_variables/#summary-of-locks-conditional-variable","text":"Locks provide mutual exclusion for critical sections CV block a thread that has to wait for something to happen first","title":"Summary of Locks + Conditional Variable"},{"location":"CSC369/l13_semaphores/","text":"Semaphores Abstract data types that provide synchronization. Semaphore is an alternative to locks. A semaphore is an integer counting variable that has 2 atomic operations: wait and signal Semaphores include: Integer counter variable(semaphore value), that can only be accessed through 2 atomic operations . Semaphore value represents number of threads that can pass through wait before it blocks Atomic operation wait (also called P or decrement). Blocks while semaphore counter <= 0 and then decremenets counter Atomic operation signal (also called V or increment) Increment the counter , unblock a waiting thread if there are any. Definitions of atomic operations these are definitions not implementations wait ( sem ){ while ( sem <= 0 ); // keeps executing as long as sem <= 0. sem -- // sem here is 0+, and its decremented. } signal ( sem ){ sem ++ ; } Types of semaphores Binary(Mutex) Semaphore is the most common: count = 0 / 1 Allow only 1 thread into CS Mutual exclusion to critical section Counting semaphore( max n threads allowed in CS, where count = n ) Great for a resource which allows certain kinds of unsynchronized concurrent access (e.g reading) Atomicity of wait() and signal() wait () and signal () are atomic, meaning that they execute in one go, i.e they will not be interrupted whilst executed. To implement them, can use: lower-level primitives uniprocessor : disable interrupts or use hardware instructions multiprocessor : use hardware instructions Example typedef struct account { double balance ; semaphore S ; } account_t ; Withdraw ( account_t * acct , amt ){ double bal ; wait ( acct -> S ); bal = acct -> balance ; bal = bal - amt ; acct -> balance = bal ; signal ( acct -> S ); return bal ; } Note: note that we're returning bal instead of acct->balance. This is because we should never touch shared variables outside of a critical section, even for reading, because they might have already been changed . Instead return the local variable bal, which you know gives accurate result. Semaphors Advantages and disadvantages Advantage : A semaphor's value can be modified by any thread. In comparison, a lock has an \"owner\" and can be released only by its owner. Advantage : Semaphor can impose an order of behaviour between threads. That's not possible with locks. If you want to impose order of a first then b, make code wait before b on a semaphore that increases ONLY AFTER a is passed. Disadvantage : Has a conditional variable which is very basic( if count == 0 -> sleep ). We may want a more complex wait condition. Producers/Consumers with Semaphors //globals // mutex for writing/reading from bugger mutex = 1 // semaphor for how many pieces you can read reads_allowed = 0 // semaphor for how many pieces can be written at the same time writes_allowed = N Producer { // allow to write only if there is space(i.e if writes_allowed > 0) sem_wait ( writes_allowed ) // lock buffer sem_wait ( mutex ) add_to_buffer () sem_signal ( mutex ) // send to Consumer message that it's ready to consume +1 piece sem_signal ( reads_allowed ) } Consumer { // only allow reads if they are possible(there are // pieces ready to be consumed) sem_wait ( reads_allowed ) // lock the buffer sem_wait ( mutex ) read_from_buffer () sem_wait ( mutex ) // allow +1 write sem_signal ( writes_allowed ) } Reader/Writer with Semaphors from Wikipedia : Suppose we have a shared memory area (critical section). It is possible to protect the shared data behind a mutual exclusion mutex , in which case no two threads can access the data at the same time, specifically we don't want a writer and reader accessing it at the same time, or 2 writers, but we're ok with 2 readers accessing it. Reader R2 should be allowed to read the resource alongside R1 because reads don't modify data, so concurrent reads are safe . This is the motivation for the first readers-writers problem , in which the constraint is added that no reader shall be kept waiting if the share is currently opened for reading. This is also called readers-preference , with its solution: // Globals int readcount = 0 // number of readers semaphore resource = 1 ; semaphore mutex = 1 ; Writer { // can't read and write to data at the same time sem_wait ( resource ); write (); sem_signal ( resource ); } Reader { // remember that readcount is a shared variable, therefore multiple variables may be able to modify it at the same time sem_wait ( mutex ) reacount += 1 ; if ( readcount == 1 ){ //only need to lock it once, and lock it the first time a reader accesses it sem_wait ( resource ); } sem_signal ( mutex ) read ; sem_wait ( mutex ) readcount -= 1 ; if ( readcount == 0 ){ // once the last reader inside has finished reading, then you can release the lock and a write or another read can grab it. sem_signal ( read_or_write ) } sem_signal ( mutex ) } TODO : Read Complete Reader/Writer","title":"Semaphores"},{"location":"CSC369/l13_semaphores/#semaphores","text":"Abstract data types that provide synchronization. Semaphore is an alternative to locks. A semaphore is an integer counting variable that has 2 atomic operations: wait and signal Semaphores include: Integer counter variable(semaphore value), that can only be accessed through 2 atomic operations . Semaphore value represents number of threads that can pass through wait before it blocks Atomic operation wait (also called P or decrement). Blocks while semaphore counter <= 0 and then decremenets counter Atomic operation signal (also called V or increment) Increment the counter , unblock a waiting thread if there are any.","title":"Semaphores"},{"location":"CSC369/l13_semaphores/#definitions-of-atomic-operations","text":"these are definitions not implementations wait ( sem ){ while ( sem <= 0 ); // keeps executing as long as sem <= 0. sem -- // sem here is 0+, and its decremented. } signal ( sem ){ sem ++ ; }","title":"Definitions of atomic operations"},{"location":"CSC369/l13_semaphores/#types-of-semaphores","text":"Binary(Mutex) Semaphore is the most common: count = 0 / 1 Allow only 1 thread into CS Mutual exclusion to critical section Counting semaphore( max n threads allowed in CS, where count = n ) Great for a resource which allows certain kinds of unsynchronized concurrent access (e.g reading)","title":"Types of semaphores"},{"location":"CSC369/l13_semaphores/#atomicity-of-wait-and-signal","text":"wait () and signal () are atomic, meaning that they execute in one go, i.e they will not be interrupted whilst executed. To implement them, can use: lower-level primitives uniprocessor : disable interrupts or use hardware instructions multiprocessor : use hardware instructions","title":"Atomicity of wait() and signal()"},{"location":"CSC369/l13_semaphores/#example","text":"typedef struct account { double balance ; semaphore S ; } account_t ; Withdraw ( account_t * acct , amt ){ double bal ; wait ( acct -> S ); bal = acct -> balance ; bal = bal - amt ; acct -> balance = bal ; signal ( acct -> S ); return bal ; } Note: note that we're returning bal instead of acct->balance. This is because we should never touch shared variables outside of a critical section, even for reading, because they might have already been changed . Instead return the local variable bal, which you know gives accurate result.","title":"Example"},{"location":"CSC369/l13_semaphores/#semaphors-advantages-and-disadvantages","text":"Advantage : A semaphor's value can be modified by any thread. In comparison, a lock has an \"owner\" and can be released only by its owner. Advantage : Semaphor can impose an order of behaviour between threads. That's not possible with locks. If you want to impose order of a first then b, make code wait before b on a semaphore that increases ONLY AFTER a is passed. Disadvantage : Has a conditional variable which is very basic( if count == 0 -> sleep ). We may want a more complex wait condition.","title":"Semaphors Advantages and disadvantages"},{"location":"CSC369/l13_semaphores/#producersconsumers-with-semaphors","text":"//globals // mutex for writing/reading from bugger mutex = 1 // semaphor for how many pieces you can read reads_allowed = 0 // semaphor for how many pieces can be written at the same time writes_allowed = N Producer { // allow to write only if there is space(i.e if writes_allowed > 0) sem_wait ( writes_allowed ) // lock buffer sem_wait ( mutex ) add_to_buffer () sem_signal ( mutex ) // send to Consumer message that it's ready to consume +1 piece sem_signal ( reads_allowed ) } Consumer { // only allow reads if they are possible(there are // pieces ready to be consumed) sem_wait ( reads_allowed ) // lock the buffer sem_wait ( mutex ) read_from_buffer () sem_wait ( mutex ) // allow +1 write sem_signal ( writes_allowed ) }","title":"Producers/Consumers with Semaphors"},{"location":"CSC369/l13_semaphores/#readerwriter-with-semaphors","text":"from Wikipedia : Suppose we have a shared memory area (critical section). It is possible to protect the shared data behind a mutual exclusion mutex , in which case no two threads can access the data at the same time, specifically we don't want a writer and reader accessing it at the same time, or 2 writers, but we're ok with 2 readers accessing it. Reader R2 should be allowed to read the resource alongside R1 because reads don't modify data, so concurrent reads are safe . This is the motivation for the first readers-writers problem , in which the constraint is added that no reader shall be kept waiting if the share is currently opened for reading. This is also called readers-preference , with its solution: // Globals int readcount = 0 // number of readers semaphore resource = 1 ; semaphore mutex = 1 ; Writer { // can't read and write to data at the same time sem_wait ( resource ); write (); sem_signal ( resource ); } Reader { // remember that readcount is a shared variable, therefore multiple variables may be able to modify it at the same time sem_wait ( mutex ) reacount += 1 ; if ( readcount == 1 ){ //only need to lock it once, and lock it the first time a reader accesses it sem_wait ( resource ); } sem_signal ( mutex ) read ; sem_wait ( mutex ) readcount -= 1 ; if ( readcount == 0 ){ // once the last reader inside has finished reading, then you can release the lock and a write or another read can grab it. sem_signal ( read_or_write ) } sem_signal ( mutex ) } TODO : Read Complete Reader/Writer","title":"Reader/Writer with Semaphors"},{"location":"CSC369/l14_deadlocks/","text":"Deadlock Resources Resources : A resource is an object that a process requires hardware: printers, memory, processors, etc data: shared variables, files, etc. synchronization objects (to access critical regions): locks, semaphores, monitors Root causes of a resource deadlock Note: think of it like a traffic jam Resources are finite Processes will wait if a resource they need is unavailable Resources may be held by other waiting processes Necessary conditions for a deadlock Mutual exclusion : only one process may use resource at a time. This condition is satisfied in any synchronization environment . It's one of the 3 necessary conditions for synchronization(see Progress section): Mutual exclusion, Progress, bounded waiting(no starvation). Hold and wait : process may hold resources while waiting for other resources to become available. Name is hold and wait because you hold your current resources and waiting for more This condition is satisfied in any synchronization environment . No preemption : no resource can be forcibly removed from a process holding it. This condition is also satisfied in any synchronization environment . For example we cannot forcibly take a lock from a thread give it to another. Circular wait : a closed chain of processes exists, such that each process holds at least one resource needed by the next process in the chain. Bug This is the main reason why a deadlock occurs. e.g: A->B->C->A Together these conditions are necessary and sufficient for a deadlock Deadlock prevention To prevent a deadlock, we need to break one of the 4 conditions. Break mutual exclusion Method : use architectural support(hardware) to create lock-free data structures using non-blocking atomic operation . Problem : fundamental part of synchronization requirements. Very difficult to convert complex operations to a lock-free version, Break hold and wait Problems : Process may wait for a long time for all resources to become available at the same time. Process will try to acquire all locks at the start, instead of an on-going basis, which severly limits concurrency, since now a lot of critical sections are locked off. As a result of previous problem, some processes may hold for some locks for a really long time before they actually use it. Process may not know all resources it needs in advance. Break no pre-emption Problems : typically it's a terrible idea to take resources away from another thread. A thread cannot know where another thread currently is, and if you take the lock away whilst it is modifying data, you can corrupt everything. In conclusion, it's a bad idea to try and break any of the first 3 conditions of a deadlock, since they are also pillars of synchronization which make syncrhonization easier to achieve and less buggy. Therefore only way left is to prevent circular wait. Preventing circular wait Method : assign a linear ordering to resources and require that a process holding a resource can only request resources that that follow its resource R in the ordering. Example process A has lock # 2, and it can only request locks with a higher number. you have function request_friend ( a , b ) , where it locks 1st arg and then 2nd arg. If you call request_friend(a,b) and request_friend(b,a), then you will get a deadlock, as Thread 1 will lock a and then wait fo b. and Thread 2 will lock b and then wait for a Note other strategies for dealing with Deadlocks are: deadlock avoidance (use knowledge about resources that each process might request, deadlock detection , and deadlock recovery Ostrich algorithm Most OS nowadays employ \"ostrich algorithm\": ignore problem, hope it doesn't happen often. Deadlock vs Livelock from wikipedia a livelock is similar to a deadlock, except that the state of the processes involved in livelock constantly change with regard to one another, so no-one progresses. It's a special case of resource starvation. Example of livelock is 2 people meeting in a narrow corridor, where each one tries to be polite by moving aside to let the other pass, but they end up swaying from side to side without making any progress because they always move the same way at the same time Communication deadlocks problem : Deadlocks that happen when A sends request to B, and waits for reply, B waits for the message, and the message gets lost , then both are waiting. solution : use timeouts, use protocol to detect that message is lost and resend it.","title":"Deadlock"},{"location":"CSC369/l14_deadlocks/#deadlock","text":"","title":"Deadlock"},{"location":"CSC369/l14_deadlocks/#resources","text":"Resources : A resource is an object that a process requires hardware: printers, memory, processors, etc data: shared variables, files, etc. synchronization objects (to access critical regions): locks, semaphores, monitors","title":"Resources"},{"location":"CSC369/l14_deadlocks/#root-causes-of-a-resource-deadlock","text":"Note: think of it like a traffic jam Resources are finite Processes will wait if a resource they need is unavailable Resources may be held by other waiting processes","title":"Root causes of a resource deadlock"},{"location":"CSC369/l14_deadlocks/#necessary-conditions-for-a-deadlock","text":"Mutual exclusion : only one process may use resource at a time. This condition is satisfied in any synchronization environment . It's one of the 3 necessary conditions for synchronization(see Progress section): Mutual exclusion, Progress, bounded waiting(no starvation). Hold and wait : process may hold resources while waiting for other resources to become available. Name is hold and wait because you hold your current resources and waiting for more This condition is satisfied in any synchronization environment . No preemption : no resource can be forcibly removed from a process holding it. This condition is also satisfied in any synchronization environment . For example we cannot forcibly take a lock from a thread give it to another. Circular wait : a closed chain of processes exists, such that each process holds at least one resource needed by the next process in the chain. Bug This is the main reason why a deadlock occurs. e.g: A->B->C->A Together these conditions are necessary and sufficient for a deadlock","title":"Necessary conditions for a deadlock"},{"location":"CSC369/l14_deadlocks/#deadlock-prevention","text":"To prevent a deadlock, we need to break one of the 4 conditions.","title":"Deadlock prevention"},{"location":"CSC369/l14_deadlocks/#break-mutual-exclusion","text":"Method : use architectural support(hardware) to create lock-free data structures using non-blocking atomic operation . Problem : fundamental part of synchronization requirements. Very difficult to convert complex operations to a lock-free version,","title":"Break mutual exclusion"},{"location":"CSC369/l14_deadlocks/#break-hold-and-wait","text":"Problems : Process may wait for a long time for all resources to become available at the same time. Process will try to acquire all locks at the start, instead of an on-going basis, which severly limits concurrency, since now a lot of critical sections are locked off. As a result of previous problem, some processes may hold for some locks for a really long time before they actually use it. Process may not know all resources it needs in advance.","title":"Break hold and wait"},{"location":"CSC369/l14_deadlocks/#break-no-pre-emption","text":"Problems : typically it's a terrible idea to take resources away from another thread. A thread cannot know where another thread currently is, and if you take the lock away whilst it is modifying data, you can corrupt everything. In conclusion, it's a bad idea to try and break any of the first 3 conditions of a deadlock, since they are also pillars of synchronization which make syncrhonization easier to achieve and less buggy. Therefore only way left is to prevent circular wait.","title":"Break no pre-emption"},{"location":"CSC369/l14_deadlocks/#preventing-circular-wait","text":"Method : assign a linear ordering to resources and require that a process holding a resource can only request resources that that follow its resource R in the ordering. Example process A has lock # 2, and it can only request locks with a higher number. you have function request_friend ( a , b ) , where it locks 1st arg and then 2nd arg. If you call request_friend(a,b) and request_friend(b,a), then you will get a deadlock, as Thread 1 will lock a and then wait fo b. and Thread 2 will lock b and then wait for a Note other strategies for dealing with Deadlocks are: deadlock avoidance (use knowledge about resources that each process might request, deadlock detection , and deadlock recovery","title":"Preventing circular wait"},{"location":"CSC369/l14_deadlocks/#ostrich-algorithm","text":"Most OS nowadays employ \"ostrich algorithm\": ignore problem, hope it doesn't happen often.","title":"Ostrich algorithm"},{"location":"CSC369/l14_deadlocks/#deadlock-vs-livelock","text":"from wikipedia a livelock is similar to a deadlock, except that the state of the processes involved in livelock constantly change with regard to one another, so no-one progresses. It's a special case of resource starvation. Example of livelock is 2 people meeting in a narrow corridor, where each one tries to be polite by moving aside to let the other pass, but they end up swaying from side to side without making any progress because they always move the same way at the same time","title":"Deadlock vs Livelock"},{"location":"CSC369/l14_deadlocks/#communication-deadlocks","text":"problem : Deadlocks that happen when A sends request to B, and waits for reply, B waits for the message, and the message gets lost , then both are waiting. solution : use timeouts, use protocol to detect that message is lost and resend it.","title":"Communication deadlocks"},{"location":"CSC369/l2_l3_l4_files/","text":"Files and File Systems Top requirements for an OS Virtualization : present physical resources as a more general, easy-to-use form of itself present illusion of multiple resources where only a couple exist. For example, you can have only 1 core, but you can create 'as many processes as you want' to run them at the same time. Files and directories abstract away the hard drive Concurrency Coordinate multiple parallel activities to ensure corectness Persistence Need to persist data. Data needs to survive crash. File systems control how and when data is transferred to persistent storage . File Systems Requirements: Store large amounts of information Information must survive crashes and termination of processes Multiple processes must be able to access information concurrently File Operations Creating a file Deleting a file Writing to file Reading to file Moving a file Truncation and appending Directories For user : convenient way to organize files For OS : convenient naming interface Directory Structure A directory isa list of entries . Associated data can be(size, protection, user access, location, etc) Unordered list of entries Directories are implemented as a file , which means you need to manage only one kind of secondary storage Directory Implementation Acyclic-graph directories: imeplmenetned in Unix: same file or directory can be in 2 different directories. DIfferent from tree-structured which may not have cycles. Implementation: List : requires linear search to find entries, easy to implement but slow to execute Hash table : take space, faster. File Links Hard links: directory entry refers to \"true path\" to the file Each file has a count of how many references it has. if you delete the entry, you check if the hard links is equal to 1(i.e this directory is only one pointing to it), and if yes, you actually delete the file at that path. Otherwise you just delete the current reference to it from your directory but leave the file intact since there are other references to it. In normal cases, like editing a file, you're editing the file at the true path so all references to it will point to the updated file Soft links with a soft link, you refer to a file which holds the true path of the linked file. The advantage of this is that you can work across file systems. Disadvantage is that if you delete the file, link remains in place. Another disadvantage is that you don't actually delete the file, you delete the soft link to it. File System Implementation File systems use blocks(4Kb) to store data . If our disk is 64 kb, we have 16 blocks. Superblock/master block determines location of root directory superblock always at well-known disk location(might be in dirst block) sometimes replicated for reliability Includes other important information about file system(how many inodes, data blocks there are, where bitmaps and inode begin) typedef struct a1fs_superblock { // basic file system info: type of file system, size of file system, number of inodes /** Must match A1FS_MAGIC. */ uint64_t magic ; uint64_t size ; unsigned short s_inode_size ; // number of inodes, blocks + free inodes and free blocks unsigned int s_inodes_count ; unsigned int s_blocks_count ; unsigned int s_free_blocks_count ; unsigned int s_free_inodes_count ; // Location of bitmaps and tables a1fs_extent data_blocks_extent ; a1fs_extent block_bitmap_extent ; a1fs_extent inode_bitmap_extent ; a1fs_extent inode_table_extent ; } a1fs_superblock ; We have bitmaps which determine which blocks are free, one bit per block on disk. They can be cached in memory for performance In ext2, we have a bitmap for inodes, and a bitmap for data blocks Inode table stored in 1+ blocks. Inode table Remaining blocks used to store files and directories Disk layout strategies Files often span multiple blocks, since they are greater than 4Kb(or whatever size of the block is). Here's how to find all blocks of a file: Contiguous allocation: Advantages : fast, simplifies directory access. Disadvantages : inflexible, causes external fragmentation Links Advantages : each block points to the next, directory points to the firss. Good for sequentia/continuousl access Disadvantages : terrible for random access Indexed structure/inode : index block contains pointers to many other blocks. Advantages : handles random access well, b/c has pointers to all blocks. Pretty good for sequential Inode structure: Unix Inodes All file metadata is stored inside an inode Unix directories map file names to inode: Each inode contains 15 block pointer: 12 are direct block pointers(disk addresses of first 12 data block pointers) 13th is single indirect block pointer: points to block containing direct block pointers 14th is a double indirect block pointer: points to block contiaining addresses of single indirect blocks 15th is a triple indirect block pointer. Total size will be: 4Kb*(12+ 1024+1024^2 + 1024^3) \\approx 4Tb 4Kb*(12+ 1024+1024^2 + 1024^3) \\approx 4Tb Advantages of imbalanced tree like this are: most files are small( \\approx 2Kb \\approx 2Kb ) Files are usually accessed sequentially DIrectories are typically small(20-) Therefore, most of them will fit inside of the direct blocks, which results in a very fast sequential + random access. Once file becomes larger, than need to use indirect blocks. Extent-based approach /** Extent - a contiguous range of blocks. */ typedef struct extent { /** Starting block of the extent. */ int start ; /** Number of blocks in the extent. */ int count ; } Advantages : uses smaller amoutn of metadata per file, file allocation is more compact Disadvantages : less flexible than pointer-based approach, but still a lot more flexible compared to contiguous allocation. This sort of does contiguous allocation but on a much smaller scale, where it's blocks of contiguously allocated files. Used by : ext4, HFS+, NTFS, XFS Link-based approach FAT file system ,sued by WIndoes before NTFS Instead of pointer to all blocks you have a table where the inode just has one pointer to first data block o the file, then first block points to second block etc Disadvantages : very bad random access, or accessing last blocks of file since you need to move through all data blocks first. NTFS Each volume(partition) is a linear sequence of blocks. Master File Table : Each volume has a Master File Table**(MFT) MFT is full of 1 kb Records (MFR). Records (they're similar to inodes but more flexible): 1 or more records per file/directory . MFT records are variable length Long attributes can be stored externally, and a pointer kept in MFT record. Otherwise MFT record prefers to keep data inside of it(so it will store dentries inside of an MFT record as well as the actual data inside a small file). If data won't fit inside an MFT record, NTFS will to allocate files in extents/runs of consecutive blocks and give pointers towards them.. Records contain a lot of metadata(key value pairs), which allow for implementation of extra features: compresion, different file types. Fast File system meant for hard disk-based environments Cylinder Groups Disk partitioned into groups of cylinders(bitmap + inodes + data blocks all in the same group) Data blocks in same file allocated in same cylinder group which decreases seeking when reading a file Files in same directory allocated in same cylinder group which decreases seeking when finding a file in a path, because folders are also considered files so we want to stay within the same cylinder group preferably. Inodes for files allocated in same cylinder group as file data blocks which decreases seeking More FFS improvements Use larger blocks(4K) with fragments(1K pieces) instead of small blocks(1K) Small block size leads to a small max file size + low bandwidth utilization. Mounting a file system OS reads the superblock OS identifies type of FS + other parameters OS attaches the volume to the file system tree Reading a file Find the inode number from the dentry(directory entry) Find the inode inside of the inode table. e.g: if inode is inode #32 then find it at: 4kb(blocksize) \\times 3 + 128b (size\\; of\\; inode) * 32 4kb(blocksize) \\times 3 + 128b (size\\; of\\; inode) * 32 Once you have the inode, inode has pointer to all of its data blocks, so do the same strategy to get to the data blocks and then read them. Say you want to open file / one / two / three : Master block for the location of inode for \u201c/\u201d Directory block for \u201c/\u201d - search for \u201cone\u201d Inode block containing inode for \u201cone\u201d Directory block for \u201cone\u201d - search for \u201ctwo\u201d Inode block containing inode for \u201ctwo\u201d Directory block for \u201ctwo\u201d - search for \u201cthree\u201d Inode block for \u201cthree\", open() VFS(Virtual File System) Works as an Abstraction file system interface . User-level programmer interacts with file systems through general system calls, without worrying about which system call it is. Helps OS support file system and programmers not code towards a specific file system","title":"Files and File Systems"},{"location":"CSC369/l2_l3_l4_files/#files-and-file-systems","text":"","title":"Files and File Systems"},{"location":"CSC369/l2_l3_l4_files/#top-requirements-for-an-os","text":"Virtualization : present physical resources as a more general, easy-to-use form of itself present illusion of multiple resources where only a couple exist. For example, you can have only 1 core, but you can create 'as many processes as you want' to run them at the same time. Files and directories abstract away the hard drive Concurrency Coordinate multiple parallel activities to ensure corectness Persistence Need to persist data. Data needs to survive crash. File systems control how and when data is transferred to persistent storage .","title":"Top requirements for an OS"},{"location":"CSC369/l2_l3_l4_files/#file-systems","text":"Requirements: Store large amounts of information Information must survive crashes and termination of processes Multiple processes must be able to access information concurrently","title":"File Systems"},{"location":"CSC369/l2_l3_l4_files/#file-operations","text":"Creating a file Deleting a file Writing to file Reading to file Moving a file Truncation and appending","title":"File Operations"},{"location":"CSC369/l2_l3_l4_files/#directories","text":"For user : convenient way to organize files For OS : convenient naming interface","title":"Directories"},{"location":"CSC369/l2_l3_l4_files/#directory-structure","text":"A directory isa list of entries . Associated data can be(size, protection, user access, location, etc) Unordered list of entries Directories are implemented as a file , which means you need to manage only one kind of secondary storage","title":"Directory Structure"},{"location":"CSC369/l2_l3_l4_files/#directory-implementation","text":"Acyclic-graph directories: imeplmenetned in Unix: same file or directory can be in 2 different directories. DIfferent from tree-structured which may not have cycles. Implementation: List : requires linear search to find entries, easy to implement but slow to execute Hash table : take space, faster.","title":"Directory Implementation"},{"location":"CSC369/l2_l3_l4_files/#file-links","text":"Hard links: directory entry refers to \"true path\" to the file Each file has a count of how many references it has. if you delete the entry, you check if the hard links is equal to 1(i.e this directory is only one pointing to it), and if yes, you actually delete the file at that path. Otherwise you just delete the current reference to it from your directory but leave the file intact since there are other references to it. In normal cases, like editing a file, you're editing the file at the true path so all references to it will point to the updated file Soft links with a soft link, you refer to a file which holds the true path of the linked file. The advantage of this is that you can work across file systems. Disadvantage is that if you delete the file, link remains in place. Another disadvantage is that you don't actually delete the file, you delete the soft link to it.","title":"File Links"},{"location":"CSC369/l2_l3_l4_files/#file-system-implementation","text":"File systems use blocks(4Kb) to store data . If our disk is 64 kb, we have 16 blocks. Superblock/master block determines location of root directory superblock always at well-known disk location(might be in dirst block) sometimes replicated for reliability Includes other important information about file system(how many inodes, data blocks there are, where bitmaps and inode begin) typedef struct a1fs_superblock { // basic file system info: type of file system, size of file system, number of inodes /** Must match A1FS_MAGIC. */ uint64_t magic ; uint64_t size ; unsigned short s_inode_size ; // number of inodes, blocks + free inodes and free blocks unsigned int s_inodes_count ; unsigned int s_blocks_count ; unsigned int s_free_blocks_count ; unsigned int s_free_inodes_count ; // Location of bitmaps and tables a1fs_extent data_blocks_extent ; a1fs_extent block_bitmap_extent ; a1fs_extent inode_bitmap_extent ; a1fs_extent inode_table_extent ; } a1fs_superblock ; We have bitmaps which determine which blocks are free, one bit per block on disk. They can be cached in memory for performance In ext2, we have a bitmap for inodes, and a bitmap for data blocks Inode table stored in 1+ blocks. Inode table Remaining blocks used to store files and directories","title":"File System Implementation"},{"location":"CSC369/l2_l3_l4_files/#disk-layout-strategies","text":"Files often span multiple blocks, since they are greater than 4Kb(or whatever size of the block is). Here's how to find all blocks of a file: Contiguous allocation: Advantages : fast, simplifies directory access. Disadvantages : inflexible, causes external fragmentation Links Advantages : each block points to the next, directory points to the firss. Good for sequentia/continuousl access Disadvantages : terrible for random access Indexed structure/inode : index block contains pointers to many other blocks. Advantages : handles random access well, b/c has pointers to all blocks. Pretty good for sequential","title":"Disk layout strategies"},{"location":"CSC369/l2_l3_l4_files/#inode-structure-unix-inodes","text":"All file metadata is stored inside an inode Unix directories map file names to inode: Each inode contains 15 block pointer: 12 are direct block pointers(disk addresses of first 12 data block pointers) 13th is single indirect block pointer: points to block containing direct block pointers 14th is a double indirect block pointer: points to block contiaining addresses of single indirect blocks 15th is a triple indirect block pointer. Total size will be: 4Kb*(12+ 1024+1024^2 + 1024^3) \\approx 4Tb 4Kb*(12+ 1024+1024^2 + 1024^3) \\approx 4Tb Advantages of imbalanced tree like this are: most files are small( \\approx 2Kb \\approx 2Kb ) Files are usually accessed sequentially DIrectories are typically small(20-) Therefore, most of them will fit inside of the direct blocks, which results in a very fast sequential + random access. Once file becomes larger, than need to use indirect blocks.","title":"Inode structure: Unix Inodes"},{"location":"CSC369/l2_l3_l4_files/#extent-based-approach","text":"/** Extent - a contiguous range of blocks. */ typedef struct extent { /** Starting block of the extent. */ int start ; /** Number of blocks in the extent. */ int count ; } Advantages : uses smaller amoutn of metadata per file, file allocation is more compact Disadvantages : less flexible than pointer-based approach, but still a lot more flexible compared to contiguous allocation. This sort of does contiguous allocation but on a much smaller scale, where it's blocks of contiguously allocated files. Used by : ext4, HFS+, NTFS, XFS","title":"Extent-based approach"},{"location":"CSC369/l2_l3_l4_files/#link-based-approach","text":"FAT file system ,sued by WIndoes before NTFS Instead of pointer to all blocks you have a table where the inode just has one pointer to first data block o the file, then first block points to second block etc Disadvantages : very bad random access, or accessing last blocks of file since you need to move through all data blocks first.","title":"Link-based approach"},{"location":"CSC369/l2_l3_l4_files/#ntfs","text":"Each volume(partition) is a linear sequence of blocks. Master File Table : Each volume has a Master File Table**(MFT) MFT is full of 1 kb Records (MFR). Records (they're similar to inodes but more flexible): 1 or more records per file/directory . MFT records are variable length Long attributes can be stored externally, and a pointer kept in MFT record. Otherwise MFT record prefers to keep data inside of it(so it will store dentries inside of an MFT record as well as the actual data inside a small file). If data won't fit inside an MFT record, NTFS will to allocate files in extents/runs of consecutive blocks and give pointers towards them.. Records contain a lot of metadata(key value pairs), which allow for implementation of extra features: compresion, different file types.","title":"NTFS"},{"location":"CSC369/l2_l3_l4_files/#fast-file-system","text":"meant for hard disk-based environments","title":"Fast File system"},{"location":"CSC369/l2_l3_l4_files/#cylinder-groups","text":"Disk partitioned into groups of cylinders(bitmap + inodes + data blocks all in the same group) Data blocks in same file allocated in same cylinder group which decreases seeking when reading a file Files in same directory allocated in same cylinder group which decreases seeking when finding a file in a path, because folders are also considered files so we want to stay within the same cylinder group preferably. Inodes for files allocated in same cylinder group as file data blocks which decreases seeking","title":"Cylinder Groups"},{"location":"CSC369/l2_l3_l4_files/#more-ffs-improvements","text":"Use larger blocks(4K) with fragments(1K pieces) instead of small blocks(1K) Small block size leads to a small max file size + low bandwidth utilization.","title":"More FFS improvements"},{"location":"CSC369/l2_l3_l4_files/#mounting-a-file-system","text":"OS reads the superblock OS identifies type of FS + other parameters OS attaches the volume to the file system tree","title":"Mounting a file system"},{"location":"CSC369/l2_l3_l4_files/#reading-a-file","text":"Find the inode number from the dentry(directory entry) Find the inode inside of the inode table. e.g: if inode is inode #32 then find it at: 4kb(blocksize) \\times 3 + 128b (size\\; of\\; inode) * 32 4kb(blocksize) \\times 3 + 128b (size\\; of\\; inode) * 32 Once you have the inode, inode has pointer to all of its data blocks, so do the same strategy to get to the data blocks and then read them. Say you want to open file / one / two / three : Master block for the location of inode for \u201c/\u201d Directory block for \u201c/\u201d - search for \u201cone\u201d Inode block containing inode for \u201cone\u201d Directory block for \u201cone\u201d - search for \u201ctwo\u201d Inode block containing inode for \u201ctwo\u201d Directory block for \u201ctwo\u201d - search for \u201cthree\u201d Inode block for \u201cthree\", open()","title":"Reading a file"},{"location":"CSC369/l2_l3_l4_files/#vfsvirtual-file-system","text":"Works as an Abstraction file system interface . User-level programmer interacts with file systems through general system calls, without worrying about which system call it is. Helps OS support file system and programmers not code towards a specific file system","title":"VFS(Virtual File System)"},{"location":"CSC369/l5_disks/","text":"Disks I/O Secondary Storage Devices Drums: ancient Magnetic Disks: fixed, removable Optical disks: write-once, read-many for CD-R and DVD-R or write-many, read-many for CD-RW Flash memory: solid state , non-volatile memory Disk Performance Seek - moving disk arm to correct cylinder, and correct track Depends on how fast the arm can move(improving slowly 7-10%) Rotation - waiting for sector to rotate under the head, on the same track Depends on rotation rate(hasn't changed recently), Average latency of 1/2 rotation Transfer - transferring data from surface into disk controller electronics depends on density(improving quickly 40% per year), 100Mb/s Optimizations Track skew : skew the track locations so that we have enough time to position Cache : a small memory chip, part of the hard drive(8-16 MB). it's different from OS cache. It is aware of disk geometry , and when reading a sector may cache the whole track to speed up future reads on the same track Zone : each sector is 512 bytes. <font color=\"\"Outer tracks are larger by geometry, so they should hold more sectors. Disk Scheduling Because seeks are so expensive(milliseconds), the OS tries to schedule disk requests to queue them in the most optimal way Modern disks do disk scheduling themselves, because they know their layout better than OS so can optimize better, therefore they undo any scheduling done by OS. Methods FCFS( do nothing) Reasonable when load is low Long waiting times for long queues SSTF(shortest seek time first(shortest movement to the right track)) Minimize arm movement, maximize request rate Favors middle blocks SCAN(elevator): service requests in one direction until done, then reverse C-SCAN: like SCAN but only go in one direction. Look/C-look: like C-Scan but only go as far as last request in each direction File systems need to be aware of disk characteristics for performance Allocation strategies to enhance performance. Best ones is allocating related data close together. This is a \" closeness \" property of disks: reduce seek times by putting related things close to one another. . Can improve performance X2 times. Another one is * Amortization : amortize each positioning delay by grabbing lots of useful data. -essentially caching the whole track. Can improve X10 Request scheduling to reduce seek time. Use something like Look or C-Look. Note: Fragmentation on aging file system causes more seeking. Fragmentation refers to condition where files are divided in pieces scattered around the disk . Therefore defragmentation software is meant to move files into blocks next to each other.","title":"Disks I/O"},{"location":"CSC369/l5_disks/#disks-io","text":"","title":"Disks I/O"},{"location":"CSC369/l5_disks/#secondary-storage-devices","text":"Drums: ancient Magnetic Disks: fixed, removable Optical disks: write-once, read-many for CD-R and DVD-R or write-many, read-many for CD-RW Flash memory: solid state , non-volatile memory","title":"Secondary Storage Devices"},{"location":"CSC369/l5_disks/#disk-performance","text":"Seek - moving disk arm to correct cylinder, and correct track Depends on how fast the arm can move(improving slowly 7-10%) Rotation - waiting for sector to rotate under the head, on the same track Depends on rotation rate(hasn't changed recently), Average latency of 1/2 rotation Transfer - transferring data from surface into disk controller electronics depends on density(improving quickly 40% per year), 100Mb/s","title":"Disk Performance"},{"location":"CSC369/l5_disks/#optimizations","text":"Track skew : skew the track locations so that we have enough time to position Cache : a small memory chip, part of the hard drive(8-16 MB). it's different from OS cache. It is aware of disk geometry , and when reading a sector may cache the whole track to speed up future reads on the same track Zone : each sector is 512 bytes. <font color=\"\"Outer tracks are larger by geometry, so they should hold more sectors.","title":"Optimizations"},{"location":"CSC369/l5_disks/#disk-scheduling","text":"Because seeks are so expensive(milliseconds), the OS tries to schedule disk requests to queue them in the most optimal way Modern disks do disk scheduling themselves, because they know their layout better than OS so can optimize better, therefore they undo any scheduling done by OS.","title":"Disk Scheduling"},{"location":"CSC369/l5_disks/#methods","text":"FCFS( do nothing) Reasonable when load is low Long waiting times for long queues SSTF(shortest seek time first(shortest movement to the right track)) Minimize arm movement, maximize request rate Favors middle blocks SCAN(elevator): service requests in one direction until done, then reverse C-SCAN: like SCAN but only go in one direction. Look/C-look: like C-Scan but only go as far as last request in each direction File systems need to be aware of disk characteristics for performance Allocation strategies to enhance performance. Best ones is allocating related data close together. This is a \" closeness \" property of disks: reduce seek times by putting related things close to one another. . Can improve performance X2 times. Another one is * Amortization : amortize each positioning delay by grabbing lots of useful data. -essentially caching the whole track. Can improve X10 Request scheduling to reduce seek time. Use something like Look or C-Look. Note: Fragmentation on aging file system causes more seeking. Fragmentation refers to condition where files are divided in pieces scattered around the disk . Therefore defragmentation software is meant to move files into blocks next to each other.","title":"Methods"},{"location":"CSC369/l6_reliability/","text":"Reliability and Write Optimizations Answers: how do we optimize writes? How do we handle OS crashes and disk errors? How do we guarantee consistency of on-disk storage?","title":"Reliability and Write Optimizations"},{"location":"CSC369/l6_reliability/#reliability-and-write-optimizations","text":"Answers: how do we optimize writes? How do we handle OS crashes and disk errors? How do we guarantee consistency of on-disk storage?","title":"Reliability and Write Optimizations"},{"location":"CSC369/l7_journaling/","text":"File System Reliability Goal: ensure FS is in consistent state in event of OS failure. Consistent state : looks like operation either never occured, or like it completed. Approaches Do nothing, and choose good order for operations to minimize data loss. Most old file systems took this approach(ext2, ffs) Treat each FS operation as transaction. Roll-back if transaction didn't complete. Crash recovery When FS comes back up, run program to scan FS and restore consistency. fsck Checks : All referenceddata blocks(by inodes) must be allocated in data bitmap (i.e all used data blocks are allocated in bitmap) All allocated inodes must be in some directory entry (i.e all inodes are being used) Inode link count must match directory entries. Disadvantages : Only checks FS integrity, can't restore any lost data Too slow : scanning could take hours, because disks are very large. Disadvantage : it can't detect if data block didn't get written. Journaling A.k.a write-ahead-logging Ext3 extends ext2 with journaling capabilities. Journal can be implemented as a regular(albeit large) file on FS, making it backward and forward compatible with ext2 Widely adopted in most modern file systems(ext3, ext4, XFS, NTFS, etc). Write a log on disk of the operation you're about to do, before making any changes If a crash happens before journal write finishes , doesn't matter since actual write hasn't happened yet, so FS remains consistent If a crash happens during actual write \\rightarrow \\rightarrow go back to journal and retry actual writes. Log Log consists of transactions. Each transaction starts with (TxBegin), follow with logging of exact physical content, and end with (TxEnd) Sequence of operations: Journal Write step : Write all operations except TxEnd. If crash happens here, just skip. no inconsistency. Journal Commit step : Write TxEnd(once 1.completes, then you have a guarantee that the write of operations was completed safely without any errors). Checkpoint step (writing data to FS): Write the data and metadata to FS. If crash happens during checkpoint step, after reboot, scan the journal, look for committed transactions, replay them , and after replay FS is guaranteed to be consistent. Free step : Mark the transaction as free in the journal./ i.e delete it. Metadata Journaling Major problem :( See diagram above ) we write data after checkpoiniting metadata, so if crash occurs before all data is written, inodes will point to garbage data Solution :: write data BEFORE writing metadata to journal Write data, wait until it completes Metadata journal write Metadata journal commit Checkpoint metadata(will only deal with inode ids, block locations, doesn't actually write any data, since all data was already written). free RAID","title":"File System Reliability"},{"location":"CSC369/l7_journaling/#file-system-reliability","text":"Goal: ensure FS is in consistent state in event of OS failure. Consistent state : looks like operation either never occured, or like it completed.","title":"File System Reliability"},{"location":"CSC369/l7_journaling/#approaches","text":"Do nothing, and choose good order for operations to minimize data loss. Most old file systems took this approach(ext2, ffs) Treat each FS operation as transaction. Roll-back if transaction didn't complete.","title":"Approaches"},{"location":"CSC369/l7_journaling/#crash-recovery","text":"When FS comes back up, run program to scan FS and restore consistency.","title":"Crash recovery"},{"location":"CSC369/l7_journaling/#fsck","text":"Checks : All referenceddata blocks(by inodes) must be allocated in data bitmap (i.e all used data blocks are allocated in bitmap) All allocated inodes must be in some directory entry (i.e all inodes are being used) Inode link count must match directory entries. Disadvantages : Only checks FS integrity, can't restore any lost data Too slow : scanning could take hours, because disks are very large. Disadvantage : it can't detect if data block didn't get written.","title":"fsck"},{"location":"CSC369/l7_journaling/#journaling","text":"A.k.a write-ahead-logging Ext3 extends ext2 with journaling capabilities. Journal can be implemented as a regular(albeit large) file on FS, making it backward and forward compatible with ext2 Widely adopted in most modern file systems(ext3, ext4, XFS, NTFS, etc). Write a log on disk of the operation you're about to do, before making any changes If a crash happens before journal write finishes , doesn't matter since actual write hasn't happened yet, so FS remains consistent If a crash happens during actual write \\rightarrow \\rightarrow go back to journal and retry actual writes.","title":"Journaling"},{"location":"CSC369/l7_journaling/#log","text":"Log consists of transactions. Each transaction starts with (TxBegin), follow with logging of exact physical content, and end with (TxEnd)","title":"Log"},{"location":"CSC369/l7_journaling/#sequence-of-operations","text":"Journal Write step : Write all operations except TxEnd. If crash happens here, just skip. no inconsistency. Journal Commit step : Write TxEnd(once 1.completes, then you have a guarantee that the write of operations was completed safely without any errors). Checkpoint step (writing data to FS): Write the data and metadata to FS. If crash happens during checkpoint step, after reboot, scan the journal, look for committed transactions, replay them , and after replay FS is guaranteed to be consistent. Free step : Mark the transaction as free in the journal./ i.e delete it.","title":"Sequence of operations:"},{"location":"CSC369/l7_journaling/#metadata-journaling","text":"Major problem :( See diagram above ) we write data after checkpoiniting metadata, so if crash occurs before all data is written, inodes will point to garbage data Solution :: write data BEFORE writing metadata to journal Write data, wait until it completes Metadata journal write Metadata journal commit Checkpoint metadata(will only deal with inode ids, block locations, doesn't actually write any data, since all data was already written). free","title":"Metadata Journaling"},{"location":"CSC369/l7_journaling/#raid","text":"","title":"RAID"},{"location":"CSC369/l8_system_call/","text":"System Call System call is a function that invokes the OS . App wants to use a resource that OS manages, so asks for permission, and if it has the permission, OS does some work for it. Interrupts(exceptions/traps) OS is an event-driven program. It responds to interrupts, most of which(maybe all, not sure) are defined by interrupts. Interrupts indicate that something needs attention of OS . They can: Signal a system call, ( software interrupt ): a request for OS to 'take the wheel and do something for an App' Signal an error ( software interrupt ): that occured Timer interrupts, where OS switches to another process ( hardware interrupt ) Interrupts are predefined, so whenever one happens, CPU jumps to a routine for that specific interrupt. Boundary Crossings From user mode to system mode(User to Kernel) Hardware interrupt : ( timer interrupt where OS decides to switch process or error (seg fault, divide by 0 etc)) Software interrupt : system calls From system mode to user mode(Kernel to user) : Once OS finsihes its task, it goes back to applications(probably picks next process from ready queue. It sets up the next process(registers, mode for application, jumps to next application instruction) Privileged Instructions CPU Hardware can only run in user mode or system mode . Some instructions are privileged instructions , they can only run in system mode. CPU checks current protection level for each instruction. On a \"system call interrupt\", the mode bit is switched as you mode to system/kernel mode to allow for privileged instructions. Types of Privileged instructions: Access I/O device: poll for IO, perform DMA, catch hardware interrupt Manipulate memory management: set up page tables, load/flush the TLB and CPU caches Configure various \"mode bits\": interrupt priority level, software trap vectors, etc Call halt instruction: put cpu into low-power or idle state until next interrupt System Calls Interface User program calls C library function w. arguments. C library function passes arguments to OS. User process runs special instruction (x86 INT). This generates a system call software interrupt (there are different types of software interrupts, system call is one type). INT is an assembly language instruction for x86 processors that generates a software interrupt for a system call , with the interrupt number as an argument. [Stept 5 from image]Kernel looks up the software interrupt code in the interrupt descriptor table.It sees that it's interrupted for a system call. [Step 6 from image]Kernel looks in the system call table, and invokes the function implementing that call. System/Kernel verifies the arguments for routine. System executes rutine and then returns result in register EAX , runs iret(interrupt return) iret is an interrupt. It switches back to the user, and restores the user space. System Calls in Linux You can invoke any system call from userspace using syscall ( syscall_no , arg1 , arg2 ,...)","title":"System Call"},{"location":"CSC369/l8_system_call/#system-call","text":"System call is a function that invokes the OS . App wants to use a resource that OS manages, so asks for permission, and if it has the permission, OS does some work for it.","title":"System Call"},{"location":"CSC369/l8_system_call/#interruptsexceptionstraps","text":"OS is an event-driven program. It responds to interrupts, most of which(maybe all, not sure) are defined by interrupts. Interrupts indicate that something needs attention of OS . They can: Signal a system call, ( software interrupt ): a request for OS to 'take the wheel and do something for an App' Signal an error ( software interrupt ): that occured Timer interrupts, where OS switches to another process ( hardware interrupt ) Interrupts are predefined, so whenever one happens, CPU jumps to a routine for that specific interrupt.","title":"Interrupts(exceptions/traps)"},{"location":"CSC369/l8_system_call/#boundary-crossings","text":"From user mode to system mode(User to Kernel) Hardware interrupt : ( timer interrupt where OS decides to switch process or error (seg fault, divide by 0 etc)) Software interrupt : system calls From system mode to user mode(Kernel to user) : Once OS finsihes its task, it goes back to applications(probably picks next process from ready queue. It sets up the next process(registers, mode for application, jumps to next application instruction)","title":"Boundary Crossings"},{"location":"CSC369/l8_system_call/#privileged-instructions","text":"CPU Hardware can only run in user mode or system mode . Some instructions are privileged instructions , they can only run in system mode. CPU checks current protection level for each instruction. On a \"system call interrupt\", the mode bit is switched as you mode to system/kernel mode to allow for privileged instructions. Types of Privileged instructions: Access I/O device: poll for IO, perform DMA, catch hardware interrupt Manipulate memory management: set up page tables, load/flush the TLB and CPU caches Configure various \"mode bits\": interrupt priority level, software trap vectors, etc Call halt instruction: put cpu into low-power or idle state until next interrupt","title":"Privileged Instructions"},{"location":"CSC369/l8_system_call/#system-calls-interface","text":"User program calls C library function w. arguments. C library function passes arguments to OS. User process runs special instruction (x86 INT). This generates a system call software interrupt (there are different types of software interrupts, system call is one type). INT is an assembly language instruction for x86 processors that generates a software interrupt for a system call , with the interrupt number as an argument. [Stept 5 from image]Kernel looks up the software interrupt code in the interrupt descriptor table.It sees that it's interrupted for a system call. [Step 6 from image]Kernel looks in the system call table, and invokes the function implementing that call. System/Kernel verifies the arguments for routine. System executes rutine and then returns result in register EAX , runs iret(interrupt return) iret is an interrupt. It switches back to the user, and restores the user space.","title":"System Calls Interface"},{"location":"CSC369/l8_system_call/#system-calls-in-linux","text":"You can invoke any system call from userspace using syscall ( syscall_no , arg1 , arg2 ,...)","title":"System Calls in Linux"},{"location":"CSC369/l9_threads/","text":"Processes and Threads Interprocess Communication Processes can communicate with each other through: signals pipes sockets files Processes can share memory with each other: use shmget() shmget () : sys call tells OS to allocate shared memory region (sort of like malloc tells OS to allocate mem region in heap) shmat () : maps shared memory to some address. If you choose NULL, OS chooses address for you mmap () : another approach for creating shared memory region Disadvantages: Space : Need multiple PCB, page tables, etc Time : very time-consuming to fork and copy address space, create data structures, etc Inter-process communication: extra work is needed to share and communicate across isolated processes. Threads Definition : a thread is a single control flow through a program. A program w. multiple control flows is multithreaded. Recall that a process is: Address space: Code Heap Execution state program counter stack pointer OS resources open file table, etc. Main idea: Separate the address space from the execution state. Then multiple \"threads of execution\" can share the same address space(same space + access to the heap) but have their independent execution state(their own program coutner and ) Note: All the threads see the same data, otherwise they'd be considered different tasks; if some data can only be accessed by a particular thread, that's usually solely the purview of the programming language, not of the operating system. This is what threads turn into : Address space( shared )): Code(machine code of the program, which means all threads can call the same functions) Heap(can access the same data defined in the heap) Execution state ( independent )(each thread has their own) program counter(each thread can be at a different stage in the program) stack pointer(the stack is individual to the current function you're in) stack pointer: points to the top of the stack. this is where you push function arguments, as well as return statements and respectively pop them off. Each thread has their own OS resources( shared ) open file table, etc. Everything else threads share. But they have their own SP and PC Advantages Sharing : threads can solve a single problem concurrently and share code, heap, and global variables Lighter weight : they're faster to create and destroy + faster context switching times Performance gains : I/O(since one is blocked and the other one moves ahead) + overlapping computation User level and kernel-level threads Kernel-Level threads Details: OS schedules all threads in the system All thread operations are implemented in the kernel Kernel deals with context switching Advantages and Disadvantages: Multi-threading is much cheaper than processes , this is because you don't have to initialize a new address space, new PCB, new OS resources. too much overhead compared to user-threads . We still want system calls , but we want procedure calls procedure call is calling code from user space, sys call is asking OS to run in sys mode and do privileged function * Not enough fine-grained concurrency User-Level Threads Details: User-level threads are managed entirely by run-time system(user-level libraries) Creating a new thread, switching between threads, and synchronizing threads are done via procedure calls kernel has no idea or involvement in user-threads. it doesn't know they're happening . Comparatively, kernel-threads run through system calls which are much slower. Advantages and disadvantages: They are small and fast, up to 100x faster. User-level threads are invisibleto the OS so OS can make poor decisions. OS can shedule a process with idle threads Blocking process whose threads initiated an I/O, even though the process has other threads that can execute De-scheduling a process with a thread holding a lock(so no other thread from that process can access critical code region UNTIL OS gives control back to that specific thread POSIX Threads Standardizes C language threads known as pthreads . Specifies interface, not implementation! Implementation may be kernel-level, user-level, or hybrid.","title":"Processes and Threads"},{"location":"CSC369/l9_threads/#processes-and-threads","text":"","title":"Processes and Threads"},{"location":"CSC369/l9_threads/#interprocess-communication","text":"Processes can communicate with each other through: signals pipes sockets files Processes can share memory with each other: use shmget() shmget () : sys call tells OS to allocate shared memory region (sort of like malloc tells OS to allocate mem region in heap) shmat () : maps shared memory to some address. If you choose NULL, OS chooses address for you mmap () : another approach for creating shared memory region","title":"Interprocess Communication"},{"location":"CSC369/l9_threads/#disadvantages","text":"Space : Need multiple PCB, page tables, etc Time : very time-consuming to fork and copy address space, create data structures, etc Inter-process communication: extra work is needed to share and communicate across isolated processes.","title":"Disadvantages:"},{"location":"CSC369/l9_threads/#threads","text":"Definition : a thread is a single control flow through a program. A program w. multiple control flows is multithreaded. Recall that a process is: Address space: Code Heap Execution state program counter stack pointer OS resources open file table, etc. Main idea: Separate the address space from the execution state. Then multiple \"threads of execution\" can share the same address space(same space + access to the heap) but have their independent execution state(their own program coutner and ) Note: All the threads see the same data, otherwise they'd be considered different tasks; if some data can only be accessed by a particular thread, that's usually solely the purview of the programming language, not of the operating system. This is what threads turn into : Address space( shared )): Code(machine code of the program, which means all threads can call the same functions) Heap(can access the same data defined in the heap) Execution state ( independent )(each thread has their own) program counter(each thread can be at a different stage in the program) stack pointer(the stack is individual to the current function you're in) stack pointer: points to the top of the stack. this is where you push function arguments, as well as return statements and respectively pop them off. Each thread has their own OS resources( shared ) open file table, etc. Everything else threads share. But they have their own SP and PC","title":"Threads"},{"location":"CSC369/l9_threads/#advantages","text":"Sharing : threads can solve a single problem concurrently and share code, heap, and global variables Lighter weight : they're faster to create and destroy + faster context switching times Performance gains : I/O(since one is blocked and the other one moves ahead) + overlapping computation","title":"Advantages"},{"location":"CSC369/l9_threads/#user-level-and-kernel-level-threads","text":"","title":"User level and kernel-level threads"},{"location":"CSC369/l9_threads/#kernel-level-threads","text":"Details: OS schedules all threads in the system All thread operations are implemented in the kernel Kernel deals with context switching Advantages and Disadvantages: Multi-threading is much cheaper than processes , this is because you don't have to initialize a new address space, new PCB, new OS resources. too much overhead compared to user-threads . We still want system calls , but we want procedure calls procedure call is calling code from user space, sys call is asking OS to run in sys mode and do privileged function * Not enough fine-grained concurrency","title":"Kernel-Level threads"},{"location":"CSC369/l9_threads/#user-level-threads","text":"Details: User-level threads are managed entirely by run-time system(user-level libraries) Creating a new thread, switching between threads, and synchronizing threads are done via procedure calls kernel has no idea or involvement in user-threads. it doesn't know they're happening . Comparatively, kernel-threads run through system calls which are much slower. Advantages and disadvantages: They are small and fast, up to 100x faster. User-level threads are invisibleto the OS so OS can make poor decisions. OS can shedule a process with idle threads Blocking process whose threads initiated an I/O, even though the process has other threads that can execute De-scheduling a process with a thread holding a lock(so no other thread from that process can access critical code region UNTIL OS gives control back to that specific thread","title":"User-Level Threads"},{"location":"CSC369/l9_threads/#posix-threads","text":"Standardizes C language threads known as pthreads . Specifies interface, not implementation! Implementation may be kernel-level, user-level, or hybrid.","title":"POSIX Threads"},{"location":"CSC369/processes/","text":"Processes Process Control Block(PCB) Contains information related to a process. The information must be saved and updated, as process moves from one state to another(new, read...etc) Process state : (new, ready, running, waiting, terminated) Program Counter : address of the next instruction to execute in the process Registers : the specific registers that are used + their values PID : ID of a particular process OS resources : List of open files, network connections, signals, etc Location of PCB : PCB is kept in memory area that is protected from normal user access. Some OS's place it at beginning of the kernel stack. Process Life Cycle Ready (its waiting for OS to pick it up and move it to running) When creating a process, before moving it to ready do the following: Create new Process: CB, user address space structure Allocate memory Load the program executable: initialize the start state for process (initialize all necessary variables, create necesssary network connections, db connections, open files, etc) Change state to ready Running (moves to Blocked if waits for some event(I/O, sleep, etc) or Ready if the OS interrupts it) Blocked (moves to ready when even occurs) Managing states OS maintains a queue for each state(ready, running, blocked). As a process changes its state, its PCB(a pointer to it) is unlinked from one queue and moved to another) OS uses a context switch : a switch the change CPU to another process by: Saving the state of the old process Load saved state for new process Context Switch When does it happen? Process calls yield () system call voluntarily (occurs rarely) Process is blocked when it makes a certain system call Timer interrupt handler decides to switch processes Notice in hardware it saves the user registers of process A to k-stack of A In OS mode: OS first saves the k-regs(think of k-regs as the current registers) to process struct A, and recovers k-regs from proc-struct(B). Question: this entire diagram Process Creation(In Unix) In some systems, children of process inherit permissions of parent process, and other resources After creating a child process (entire new PCB), parent may either wait for it to finish its task or continue in parallel. This depends on the OS and on your hardware. If only 1 CPU is available, OS can only run one of them at the same time. If more are available, OS can choose to run both of them at the same time. OS decides if parent or child goes first fork () : Creates and initializes new PCB Creates new address space Initializes address space with copy (note that its a copy, the child does not have a direct relation to the parent. ) of entire contents of address space of the parent , i.e it has access to a copy of same data that parent proces has access to Initialize kernel resources to point to same resources as used by parent(db connections, open files, etc) Places PCB on ready queue . Returns child PID to parent, returns 0 to the child(use return pid to differentiate if you're in the parent or the child.) Process Destruction exit () process voluntarily releases all resources exit () doesn't free all of the data. Must stop process to free everything(i.e needs to context switch to another process) A process is a zombie, until its parent collects information it, by calling wait() and catching the SIGCHILD signal. Once that happens wait() returns, process can read information of child and then zombie is completely removed from the memory. if a parent process isn\u2019t programmed properly and never calls wait(),its zombie children will stick around in memory until they\u2019re cleaned up.","title":"Processes"},{"location":"CSC369/processes/#processes","text":"","title":"Processes"},{"location":"CSC369/processes/#process-control-blockpcb","text":"Contains information related to a process. The information must be saved and updated, as process moves from one state to another(new, read...etc) Process state : (new, ready, running, waiting, terminated) Program Counter : address of the next instruction to execute in the process Registers : the specific registers that are used + their values PID : ID of a particular process OS resources : List of open files, network connections, signals, etc Location of PCB : PCB is kept in memory area that is protected from normal user access. Some OS's place it at beginning of the kernel stack.","title":"Process Control Block(PCB)"},{"location":"CSC369/processes/#process-life-cycle","text":"Ready (its waiting for OS to pick it up and move it to running) When creating a process, before moving it to ready do the following: Create new Process: CB, user address space structure Allocate memory Load the program executable: initialize the start state for process (initialize all necessary variables, create necesssary network connections, db connections, open files, etc) Change state to ready Running (moves to Blocked if waits for some event(I/O, sleep, etc) or Ready if the OS interrupts it) Blocked (moves to ready when even occurs)","title":"Process Life Cycle"},{"location":"CSC369/processes/#managing-states","text":"OS maintains a queue for each state(ready, running, blocked). As a process changes its state, its PCB(a pointer to it) is unlinked from one queue and moved to another) OS uses a context switch : a switch the change CPU to another process by: Saving the state of the old process Load saved state for new process","title":"Managing states"},{"location":"CSC369/processes/#context-switch","text":"","title":"Context Switch"},{"location":"CSC369/processes/#when-does-it-happen","text":"Process calls yield () system call voluntarily (occurs rarely) Process is blocked when it makes a certain system call Timer interrupt handler decides to switch processes Notice in hardware it saves the user registers of process A to k-stack of A In OS mode: OS first saves the k-regs(think of k-regs as the current registers) to process struct A, and recovers k-regs from proc-struct(B). Question: this entire diagram","title":"When does it happen?"},{"location":"CSC369/processes/#process-creationin-unix","text":"In some systems, children of process inherit permissions of parent process, and other resources After creating a child process (entire new PCB), parent may either wait for it to finish its task or continue in parallel. This depends on the OS and on your hardware. If only 1 CPU is available, OS can only run one of them at the same time. If more are available, OS can choose to run both of them at the same time. OS decides if parent or child goes first fork () : Creates and initializes new PCB Creates new address space Initializes address space with copy (note that its a copy, the child does not have a direct relation to the parent. ) of entire contents of address space of the parent , i.e it has access to a copy of same data that parent proces has access to Initialize kernel resources to point to same resources as used by parent(db connections, open files, etc) Places PCB on ready queue . Returns child PID to parent, returns 0 to the child(use return pid to differentiate if you're in the parent or the child.)","title":"Process Creation(In Unix)"},{"location":"CSC369/processes/#process-destruction","text":"exit () process voluntarily releases all resources exit () doesn't free all of the data. Must stop process to free everything(i.e needs to context switch to another process) A process is a zombie, until its parent collects information it, by calling wait() and catching the SIGCHILD signal. Once that happens wait() returns, process can read information of child and then zombie is completely removed from the memory. if a parent process isn\u2019t programmed properly and never calls wait(),its zombie children will stick around in memory until they\u2019re cleaned up.","title":"Process Destruction"},{"location":"CSC369/docs_nfs284/","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [ dir - name ] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. Project layout mkdocs . yml # The configuration file . docs / index . md # The documentation homepage . ... # Other markdown pages , images and other files .","title":"Welcome to MkDocs"},{"location":"CSC369/docs_nfs284/#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"CSC369/docs_nfs284/#commands","text":"mkdocs new [ dir - name ] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Commands"},{"location":"CSC369/docs_nfs284/#project-layout","text":"mkdocs . yml # The configuration file . docs / index . md # The documentation homepage . ... # Other markdown pages , images and other files .","title":"Project layout"},{"location":"CSC369/docs_nfs284/notes/","text":"File System Considerations Consider data structures to use to keep track of data and metadata. How to perform access methods: (open, read, write). Consider how to do operations efficiently(open,close,delete,etc.) Data Structures Blocks : Space on filesystem divided into blocks of data, typically 4KB. Data region : Region which holds the user data. Inodes : We need to keep track of metadata for each file(size of file, owner and access rights, access and modify times, which blocks contain the information). Inode table . We store the inodes in an inode table, which we store in blocks, also at the beginning of the file. We can store multiple inodes in the same block since an inode is pretty small(128-256 bytes), and considering each block typically takes 4Kb(4096 bytes), we can hold about 80 inodes. Data and inode bitmaps : We also need some data structures to keep track of which inodes or data blocks are free or allocated. Each bit indicates whether block/object is free(0) or in-use(1). Superblock : Contains information about the particular filesystem. When mounting a file system, OS will read the superblock first to initialize various parameters, and then attach a volume to the file-system tree. Things it tracks are: how many inodes and data blocks are in the file system, where the inode table begins, etc. The Inode Structure that holds metadata for a given file(length, permissions), AND the location of the blocks which hold the file. Given an i-number( each inode is implicitly referred to a number ), you should be able to calculate where on the disk the respective inode is. Here's how you address a sector of the inode block: blk = ( inumber * sizeof ( inode_t )) / blockSize ; sector = (( blk * blockSize ) + inodeStartAddr ) / sectorSize ; You have to divide by blocksize and sectorsize because the disks are not byte addressable, rather they consist of a large number of addressable sectors, usually 512 bytes, so you have to divide by the block. The inode itself contains virtually all information you need about the file: Type(regular type, directory, etc) Size Number of blocks allocated to it Protection information(who owns the file, who can read, write, execute.) Some time information One of the most important decisions is how inode referse to where data blocks are. One simple approach is to have 1 or more direct pointers( disk addresses ) inside the inode, each pointer refering to one disk block that belongs to a file. Multi-level inode Have both direct pointers and indirect pointers . Indirect pointers refer to blocks that contains more pointers, this massively increases the size your file can have. Consider that a block has 4Kb and a pointer is 4bytes, you can fit 1000 pointers inside one of those blocks. You keep using direct pointers until you run out of space. Once you are done with them, stat using indirect pointers and filling up those blocks. You can add double indirect pointers , which points to a block that contains indirect pointers , therefore that block can contain 1024 indirect pointers, and since each indirect pointer can contain 1024 direct pointers to blocks, that means you will have 1024 * 1024 = 1,000,000 blocks, i.e 1,000,000 * 4 bytes = 4,000,000 bytes = 4GB. If you add triple indirect pointers , you have a block of 1024 double indirect pointers, and since each double indirect pointer can have 1,000,000 blocks, that means your triple indirect pointer contains 1,000,000,000 blocks, i.e 1,000,000,000 * 4 bytes = 4,000,000,000 bytes = 4TB. Extent-based approach Use extents instead of pointers. An extent is a disk pointer + a length(in blocks), so instead of requiring a pointer for every block of a file, you use a pointer + a length to specify on-disk location of a file. Have multiple extents for the same file. Link-based approach Use a linked list .Instead of having multiple pointer, have just one, which points to the first block of the file. Then add another pointer at the end of the data block, and so on . Advantages : supports arbitrarily large files only limited by size of the FS. Problems : performs poorly for some workloads, for example if you need to read the last block of a file, or just doing random access. Some systems will have an in-memory table of link information, instead of storing the next pointers in the data blocks. . Table is indexed by address of data block D(so you're at data block D, and then you look inside the table, where the content is the pointer to the next data block.) Makes it easy to do random file access(simply scan through in-memory table to find desired block, and access it on disk directly.) This is the basis of FAT system(file allocation table) . Optimizations Findings from research Finding Explanation Most files are small 2Kb is most common size Average file size is growing Almost 200kb is now average Most bytes are stored in large files Few big files use most space File system contains tons of files 100K on average File systems are roughly half full 50% full on average Directories typically small Most < 20 entries Directory Organization Directory contains: <file_name, inode number> pairs You want to have the following structure inum reserved_inode_number reclen strlen name 5 2 12 2 . 2 2 12 3 .. 12 12 4 1 foo inum is the inode number(which you can access as shown previously) reserved_inode_number keeps track of the number of references to a file. When they become 0(through unlink()), the file is deleted. reclen(record length) the total bytes for the name + leftover space strlen is the actual length of the name name is the actual name of the file. Storing directories Storing as a regular file Stored as a special type of file, therefore also has an inode(somewhere in inode table), and the type field inside the inode is marked as \"directory\" instead of \"regular file\". This makes it simple to store directories. On-disk structure remains unchanged. Store directories in B-tree form(XFS[S+96]) Makes file creations faster(since you can check much faster if a file like that already exists) Free Space Management File system must track which inodes and data blocks are free and which aren't, so it can find space when a file or directory is created/modified . Bitmaps : If inode bitmap, One bit for every inode, and 1 if occupied, 0 if free. When we create a file, OS searches through bitmap for a free inode, allocates it to the file, then FS marks the inode as used(w. 1 in bitmap). Similarly for the creation of a data block. Optimization with Pre-allocation : ext2 and ext3 looks for sequence of blocks(for eg. 8) that are free, so when you create a file and it needs data blocks, give it a contiguous portion on the disk, which will improve performance. Free lists : single pointer in super block points to first free block on FS. That block then keeps next free pointer, which creates a list of free blocks on the system. Access Paths: Reading and Writing Assume file system is already mounted, and superblock is in memory(everything has been set up already). Open open ( \"/foo/bar\" , O_RDONLY ) FS first finds the inode for the file bar, to get basic info about the file(permission information, file size, etc). **THerefore, FS must find inode, given full pathname). FS must traverse the pathname and and locate the desired inode. I.e it starts at the root directory(\"/\") which it already loaded, and then it traverses to the file through all the directories on its path. Begin traversal at root directory, which FS already knows from the superblock . Additionally, most often root inode number is 2, so FS would begin by reading the block that contains inode number 2. Once FS has the directory inode, look through the data blocks, for an entry for the actual file or for the next directory in the path. Once you get it, you can also get its inode, at which point move to the next inode recursively. Final step is to read bar's inode into memory, where FS does permission check, allocates a file descriptor for this process in the per-process open-file table, and returns file descriptor to the user. Read When read () is called, first read(offset 0, unless lseek() is called), will read from first block of the file. read() will further update in-memory open table for file descriptor, updating file offset such that next read is read from 2nd file block, etc. Potentially update inode with new last-accessed time Close Deallocate the file descriptor. Write First user must call open () , as described before. Then user can call write () , and update file with new contents. When writing, each write must first decide which block to allocate to the file, and update structures on the disk accordingly(data bitmap and the inode). Close the file. Each write generates 5 I/Os: 1. Read data bitmap to find out which block to use to add info. 2. One to write the bitmap(reflext that a previously free block is now busy, OR free) 3. Read inode to get block location. 4. Write to inode to update new block location. 5. Write actual block. File Creation FS must allocate inode + allocate space within directory for new file. One read to inode bitmap(find free inode), one write to inode bitmap(initialize it), one write to directory data block (link high-level name of file to inode number), one read and write to directory node to update it. If directory needs to grow to accomodate new entry , will need additional I/Os. Notes for Project Can use Pre-allocation Use bitmaps Target system more towards smaller files(which are the most common ones.)","title":"File System Considerations"},{"location":"CSC369/docs_nfs284/notes/#file-system-considerations","text":"Consider data structures to use to keep track of data and metadata. How to perform access methods: (open, read, write). Consider how to do operations efficiently(open,close,delete,etc.)","title":"File System Considerations"},{"location":"CSC369/docs_nfs284/notes/#data-structures","text":"Blocks : Space on filesystem divided into blocks of data, typically 4KB. Data region : Region which holds the user data. Inodes : We need to keep track of metadata for each file(size of file, owner and access rights, access and modify times, which blocks contain the information). Inode table . We store the inodes in an inode table, which we store in blocks, also at the beginning of the file. We can store multiple inodes in the same block since an inode is pretty small(128-256 bytes), and considering each block typically takes 4Kb(4096 bytes), we can hold about 80 inodes. Data and inode bitmaps : We also need some data structures to keep track of which inodes or data blocks are free or allocated. Each bit indicates whether block/object is free(0) or in-use(1). Superblock : Contains information about the particular filesystem. When mounting a file system, OS will read the superblock first to initialize various parameters, and then attach a volume to the file-system tree. Things it tracks are: how many inodes and data blocks are in the file system, where the inode table begins, etc.","title":"Data Structures"},{"location":"CSC369/docs_nfs284/notes/#the-inode","text":"Structure that holds metadata for a given file(length, permissions), AND the location of the blocks which hold the file. Given an i-number( each inode is implicitly referred to a number ), you should be able to calculate where on the disk the respective inode is. Here's how you address a sector of the inode block: blk = ( inumber * sizeof ( inode_t )) / blockSize ; sector = (( blk * blockSize ) + inodeStartAddr ) / sectorSize ; You have to divide by blocksize and sectorsize because the disks are not byte addressable, rather they consist of a large number of addressable sectors, usually 512 bytes, so you have to divide by the block. The inode itself contains virtually all information you need about the file: Type(regular type, directory, etc) Size Number of blocks allocated to it Protection information(who owns the file, who can read, write, execute.) Some time information One of the most important decisions is how inode referse to where data blocks are. One simple approach is to have 1 or more direct pointers( disk addresses ) inside the inode, each pointer refering to one disk block that belongs to a file.","title":"The Inode"},{"location":"CSC369/docs_nfs284/notes/#multi-level-inode","text":"Have both direct pointers and indirect pointers . Indirect pointers refer to blocks that contains more pointers, this massively increases the size your file can have. Consider that a block has 4Kb and a pointer is 4bytes, you can fit 1000 pointers inside one of those blocks. You keep using direct pointers until you run out of space. Once you are done with them, stat using indirect pointers and filling up those blocks. You can add double indirect pointers , which points to a block that contains indirect pointers , therefore that block can contain 1024 indirect pointers, and since each indirect pointer can contain 1024 direct pointers to blocks, that means you will have 1024 * 1024 = 1,000,000 blocks, i.e 1,000,000 * 4 bytes = 4,000,000 bytes = 4GB. If you add triple indirect pointers , you have a block of 1024 double indirect pointers, and since each double indirect pointer can have 1,000,000 blocks, that means your triple indirect pointer contains 1,000,000,000 blocks, i.e 1,000,000,000 * 4 bytes = 4,000,000,000 bytes = 4TB.","title":"Multi-level inode"},{"location":"CSC369/docs_nfs284/notes/#extent-based-approach","text":"Use extents instead of pointers. An extent is a disk pointer + a length(in blocks), so instead of requiring a pointer for every block of a file, you use a pointer + a length to specify on-disk location of a file. Have multiple extents for the same file.","title":"Extent-based approach"},{"location":"CSC369/docs_nfs284/notes/#link-based-approach","text":"Use a linked list .Instead of having multiple pointer, have just one, which points to the first block of the file. Then add another pointer at the end of the data block, and so on . Advantages : supports arbitrarily large files only limited by size of the FS. Problems : performs poorly for some workloads, for example if you need to read the last block of a file, or just doing random access. Some systems will have an in-memory table of link information, instead of storing the next pointers in the data blocks. . Table is indexed by address of data block D(so you're at data block D, and then you look inside the table, where the content is the pointer to the next data block.) Makes it easy to do random file access(simply scan through in-memory table to find desired block, and access it on disk directly.) This is the basis of FAT system(file allocation table) .","title":"Link-based approach"},{"location":"CSC369/docs_nfs284/notes/#optimizations","text":"","title":"Optimizations"},{"location":"CSC369/docs_nfs284/notes/#findings-from-research","text":"Finding Explanation Most files are small 2Kb is most common size Average file size is growing Almost 200kb is now average Most bytes are stored in large files Few big files use most space File system contains tons of files 100K on average File systems are roughly half full 50% full on average Directories typically small Most < 20 entries","title":"Findings from research"},{"location":"CSC369/docs_nfs284/notes/#directory-organization","text":"Directory contains: <file_name, inode number> pairs You want to have the following structure inum reserved_inode_number reclen strlen name 5 2 12 2 . 2 2 12 3 .. 12 12 4 1 foo inum is the inode number(which you can access as shown previously) reserved_inode_number keeps track of the number of references to a file. When they become 0(through unlink()), the file is deleted. reclen(record length) the total bytes for the name + leftover space strlen is the actual length of the name name is the actual name of the file.","title":"Directory Organization"},{"location":"CSC369/docs_nfs284/notes/#storing-directories","text":"Storing as a regular file Stored as a special type of file, therefore also has an inode(somewhere in inode table), and the type field inside the inode is marked as \"directory\" instead of \"regular file\". This makes it simple to store directories. On-disk structure remains unchanged. Store directories in B-tree form(XFS[S+96]) Makes file creations faster(since you can check much faster if a file like that already exists)","title":"Storing directories"},{"location":"CSC369/docs_nfs284/notes/#free-space-management","text":"File system must track which inodes and data blocks are free and which aren't, so it can find space when a file or directory is created/modified . Bitmaps : If inode bitmap, One bit for every inode, and 1 if occupied, 0 if free. When we create a file, OS searches through bitmap for a free inode, allocates it to the file, then FS marks the inode as used(w. 1 in bitmap). Similarly for the creation of a data block. Optimization with Pre-allocation : ext2 and ext3 looks for sequence of blocks(for eg. 8) that are free, so when you create a file and it needs data blocks, give it a contiguous portion on the disk, which will improve performance. Free lists : single pointer in super block points to first free block on FS. That block then keeps next free pointer, which creates a list of free blocks on the system.","title":"Free Space Management"},{"location":"CSC369/docs_nfs284/notes/#access-paths-reading-and-writing","text":"Assume file system is already mounted, and superblock is in memory(everything has been set up already).","title":"Access Paths: Reading and Writing"},{"location":"CSC369/docs_nfs284/notes/#open","text":"open ( \"/foo/bar\" , O_RDONLY ) FS first finds the inode for the file bar, to get basic info about the file(permission information, file size, etc). **THerefore, FS must find inode, given full pathname). FS must traverse the pathname and and locate the desired inode. I.e it starts at the root directory(\"/\") which it already loaded, and then it traverses to the file through all the directories on its path. Begin traversal at root directory, which FS already knows from the superblock . Additionally, most often root inode number is 2, so FS would begin by reading the block that contains inode number 2. Once FS has the directory inode, look through the data blocks, for an entry for the actual file or for the next directory in the path. Once you get it, you can also get its inode, at which point move to the next inode recursively. Final step is to read bar's inode into memory, where FS does permission check, allocates a file descriptor for this process in the per-process open-file table, and returns file descriptor to the user.","title":"Open"},{"location":"CSC369/docs_nfs284/notes/#read","text":"When read () is called, first read(offset 0, unless lseek() is called), will read from first block of the file. read() will further update in-memory open table for file descriptor, updating file offset such that next read is read from 2nd file block, etc. Potentially update inode with new last-accessed time","title":"Read"},{"location":"CSC369/docs_nfs284/notes/#close","text":"Deallocate the file descriptor.","title":"Close"},{"location":"CSC369/docs_nfs284/notes/#write","text":"First user must call open () , as described before. Then user can call write () , and update file with new contents. When writing, each write must first decide which block to allocate to the file, and update structures on the disk accordingly(data bitmap and the inode). Close the file. Each write generates 5 I/Os: 1. Read data bitmap to find out which block to use to add info. 2. One to write the bitmap(reflext that a previously free block is now busy, OR free) 3. Read inode to get block location. 4. Write to inode to update new block location. 5. Write actual block.","title":"Write"},{"location":"CSC369/docs_nfs284/notes/#file-creation","text":"FS must allocate inode + allocate space within directory for new file. One read to inode bitmap(find free inode), one write to inode bitmap(initialize it), one write to directory data block (link high-level name of file to inode number), one read and write to directory node to update it. If directory needs to grow to accomodate new entry , will need additional I/Os.","title":"File Creation"},{"location":"CSC369/docs_nfs284/notes/#notes-for-project","text":"Can use Pre-allocation Use bitmaps Target system more towards smaller files(which are the most common ones.)","title":"Notes for Project"},{"location":"CSC369/docs_nfs284/processes/","text":"Processes Process : running program. A typical system might be running tens or hundreds of processes at the same time. Doing so makes the system easy to use, as you never need to be concerned whether the CPU is avilable, you simply run the program. How do you provide the illusion of many CPUs? There are typically only a few Physical CPUs available, how can the OS provide illusion of nearly-endless supply of said CPUs? It runs one process, stops it, runs another, and so forth. OS creates this illusion by virtualizing the CPU. It looks like there are many CPUs when in fact its only one, and were switching between them at very high speeds. Virtualization mechanisms : low-level protocols and methods that implement some functionality. e.g:context switch(a time sharing mechanism). policies : more high-level, reside on top of mechanisms. They're algorithms that are responsible for some decisions in the CPU(which program should next run the OS?). A scheduling policy in OS will make this decision using: historical information (which program has run more over last minute) workload knowledge (what types of programs are run) performance metrics (is system optimizing for interactive performance or thoroughput). Time sharing The main purpose of time sharing is to make it look like you have infinite concurrent processes you can use, and to let you create and run as many programs as you want at the same time. The disadvantage is the performance. Each will run more slowly if the CPU must be shared(this is because OS will have to switch more often). The resource(CPU, network link, etc (time sharing occurs for many different resources) ) can be used for some time by process A, then process B, and so on. Employed by all modern OS. Context sharing : gives the OS the ability to stop running one program and start running another on a given CPU. Space sharing A resource is divided in space among those who want to use it. Disk sharing is naturally a shared resource(once a block is assigned to a file, it's normally not assigned to another file until the user deletes the original file. Abstraction: The process A process is simply a running program. To understand what a process is, ask ourselves: at any given time, what parts of a machine are important to the execution of a program. Memory: Memory that the process can address( address space ) is part of the process. Instructions lie in memory. Data the program reads and writes sits in memory. Registers: instructions explicitly read or update registers, so they're important to execution. Program Counter : which instruction of program will execute next Stack Pointer : manages the stack for function parameters Frame Pointer : manages the stack for function parameters, local variables and return addresses. Process Creation Before running program, OS must load code and static data(initialized variables) into address space of the process. Programs reside on disk in some executable format . So OS reads the bytes from disk and places the into its address space. Modern OS's do it lazily(they load pieces of code or data only as they are requested/needed in program execution**(.","title":"Processes"},{"location":"CSC369/docs_nfs284/processes/#processes","text":"Process : running program. A typical system might be running tens or hundreds of processes at the same time. Doing so makes the system easy to use, as you never need to be concerned whether the CPU is avilable, you simply run the program.","title":"Processes"},{"location":"CSC369/docs_nfs284/processes/#how-do-you-provide-the-illusion-of-many-cpus","text":"There are typically only a few Physical CPUs available, how can the OS provide illusion of nearly-endless supply of said CPUs? It runs one process, stops it, runs another, and so forth. OS creates this illusion by virtualizing the CPU. It looks like there are many CPUs when in fact its only one, and were switching between them at very high speeds.","title":"How do you provide the illusion of many CPUs?"},{"location":"CSC369/docs_nfs284/processes/#virtualization","text":"mechanisms : low-level protocols and methods that implement some functionality. e.g:context switch(a time sharing mechanism). policies : more high-level, reside on top of mechanisms. They're algorithms that are responsible for some decisions in the CPU(which program should next run the OS?). A scheduling policy in OS will make this decision using: historical information (which program has run more over last minute) workload knowledge (what types of programs are run) performance metrics (is system optimizing for interactive performance or thoroughput).","title":"Virtualization"},{"location":"CSC369/docs_nfs284/processes/#time-sharing","text":"The main purpose of time sharing is to make it look like you have infinite concurrent processes you can use, and to let you create and run as many programs as you want at the same time. The disadvantage is the performance. Each will run more slowly if the CPU must be shared(this is because OS will have to switch more often). The resource(CPU, network link, etc (time sharing occurs for many different resources) ) can be used for some time by process A, then process B, and so on. Employed by all modern OS. Context sharing : gives the OS the ability to stop running one program and start running another on a given CPU.","title":"Time sharing"},{"location":"CSC369/docs_nfs284/processes/#space-sharing","text":"A resource is divided in space among those who want to use it. Disk sharing is naturally a shared resource(once a block is assigned to a file, it's normally not assigned to another file until the user deletes the original file.","title":"Space sharing"},{"location":"CSC369/docs_nfs284/processes/#abstraction-the-process","text":"A process is simply a running program. To understand what a process is, ask ourselves: at any given time, what parts of a machine are important to the execution of a program. Memory: Memory that the process can address( address space ) is part of the process. Instructions lie in memory. Data the program reads and writes sits in memory. Registers: instructions explicitly read or update registers, so they're important to execution. Program Counter : which instruction of program will execute next Stack Pointer : manages the stack for function parameters Frame Pointer : manages the stack for function parameters, local variables and return addresses.","title":"Abstraction: The process"},{"location":"CSC369/docs_nfs284/processes/#process-creation","text":"Before running program, OS must load code and static data(initialized variables) into address space of the process. Programs reside on disk in some executable format . So OS reads the bytes from disk and places the into its address space. Modern OS's do it lazily(they load pieces of code or data only as they are requested/needed in program execution**(.","title":"Process Creation"},{"location":"NFS284/","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [ dir - name ] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. Project layout mkdocs . yml # The configuration file . docs / index . md # The documentation homepage . ... # Other markdown pages , images and other files .","title":"Welcome to MkDocs"},{"location":"NFS284/#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"NFS284/#commands","text":"mkdocs new [ dir - name ] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Commands"},{"location":"NFS284/#project-layout","text":"mkdocs . yml # The configuration file . docs / index . md # The documentation homepage . ... # Other markdown pages , images and other files .","title":"Project layout"},{"location":"NFS284/doing_well/","text":"To read Lecture Content Supporting documents Required textbooks readings. NOT responsible for additional information in the textbook, that is not covered in these materials, i.e only chapters and readings they indicate. Use textbook as background reference to assist in comprehension of the material.","title":"To read"},{"location":"NFS284/doing_well/#to-read","text":"Lecture Content Supporting documents Required textbooks readings. NOT responsible for additional information in the textbook, that is not covered in these materials, i.e only chapters and readings they indicate. Use textbook as background reference to assist in comprehension of the material.","title":"To read"},{"location":"NFS284/food_safety/","text":"Week 4: Food Safety Prebiotics and Probiotics Probiotics live bacterial culture that may be beneficial to your health Present in or added to foods Have to be consumed on a continuous basis because they are very quickly eliminated. Notes on regulations : Canadian regulations require specific name of probiotic listed as ingredient Pemitted claims: nutrient-function claim about role of probiotics in health Content claim about calcium & vitamin D. Roles of probiotics: Improve immune function. Prevent diarrhea. Modify colon cancer risk Affect body weight. Prebiotics Indigestible carbohydrates (not alive) in fruits and vegetables. Added to foods in purified form Help support growth of beneficial microflora(i.e priobiotics eat prebiotics.) Intestinal microflora(microbiome) in the Large Intestine: Slow movement of components favors growth of bacteria Bacteria can break down indigestible food components such as dietary fibre. Lead to fermentation, intestinal gas Breastfeeding and Infant Gastrointestinal System Colostrum: Breast milk produced during f irst week after delivery , with a different composition from mature breast milk. Contains immune factors to help protect the infant from infection, particularly in GI tract. Contains antibodies which pass from mother's bloodstream into the milk. General Breast Milk Note: enzymes break down food proteases break down proteins lipases break down fats amylases break down starch and sugar. Breastfeeding Infants have a suckling reflex for first 4-6 months . That's why they're unable to consume solid food at the beginning. Note: until 6 months of age, Health Canada recommends infants are exclusively breastfed. Breastfeeding is more common among: Mothers with partners Non-smoking mothers Women who give birth at home Non-working mothers Carbohydrates Great PREbiotics (promoting growth of Lactobacillus bifidus) reduce risk of gastrointestinal infections in infant's gut. No starch in milk \\Rightarrow \\Rightarrow low amylase in infant gut amylase: enzyme which breaks down starches and sugars, and because there's no starch in milk, you don't need amylase. lactase (breaks down lactose) present in large amoutns in brush border of instestinge Fat VERY HIGH in fat (52%) Supports rapid growth rate of newborns. Gastric lipase : plays important role in fat digestion in infants. Lipase: digests, transports and processes dietary lipids(triglycerides, fats, oils) Few pancreatic digestive enzymes in infants compared to adults. Protein Proteins are absorbed broken down (into amino acids) from adults. Antibodies in breast milk are absorbed intact and enhance the infant's immune system. Infants produce enzyme rennin to digest other proteins. Gastric Bypass Surgery Recommended to people with High Body Mass index, at risk for chronic disease(type 2 diabestes and cardiovascular disease), have been overweight for a long time. Advantages Reduces size of stomach Shortens length of intestines, so less food is absorbed by the body(therefore less converted to fat) Therefore Very effective for weight loss Disadvantages Because instestine is shortened, the areas where vitamins and minerals are usually abosrbed are now bypassed, so you need vitamins injections to prevent defficiencies. Gastric dumping syndrome : food flow: stomach \\rightarrow \\rightarrow small inestine (sphincter is bypassed). If too much food enters the small intestine quickly, water moves through osmosis from body into the lumen of the gut , because the food is a high solute concentration(and in osmosis solvent molecules(water) move from low solute concentration to high solute concentration) Symptoms include: dizziness, nausea, diarrhea Foor-Borne Illness Food infection Ingestion of living microbes(bacteria, viruses, parasites) . Salmonella : microbe in check and eggs. Destroyed by cooking thoroughly Listeria : microbe in luncheon meats(because eaten without cooking). Microwaving of raw chicken products not recommended, because heating is uneven Food intoxication Ingestion of toxins secreted by microbes . Can occur if all microbes are killed by heat treatment, if the toxin is heat-resistant. E.coli : in been and vegetables grown next to beef. Destroyed by cooking at high temperatures. Staphylococcus aureus : heat-resistant . Spread from humans via coughing and sneezing. Present in meat, potato & macaroni salads. Refrigeration limits bacteria growth . General Advice Temperatures Avoid unsave temperatures 15-52 C: rapid bacterial growth and bacterial toxins. Food should be at this temperature for minimal amounts of time. 4-15 C and 52-60 C: Some growth may occur. Many Bacteria survive. Cook food at high temperatures(kills most of the bacteria). 75C is minimum temperature for reheating foods. Warming temperatures control growth but allow survival of some bacteria Keep food in cold temperatures. 4C- Stops the growth of most bacteria. Food Etiquette Don't cross-contaminate(raw meats with one knife, fish and shellfish with another knife, unwashed fruits and veggies with another) Wash hands and surfaces often","title":"Week 4: Food Safety"},{"location":"NFS284/food_safety/#week-4-food-safety","text":"","title":"Week 4: Food Safety"},{"location":"NFS284/food_safety/#prebiotics-and-probiotics","text":"","title":"Prebiotics and Probiotics"},{"location":"NFS284/food_safety/#probiotics","text":"live bacterial culture that may be beneficial to your health Present in or added to foods Have to be consumed on a continuous basis because they are very quickly eliminated. Notes on regulations : Canadian regulations require specific name of probiotic listed as ingredient Pemitted claims: nutrient-function claim about role of probiotics in health Content claim about calcium & vitamin D.","title":"Probiotics"},{"location":"NFS284/food_safety/#roles-of-probiotics","text":"Improve immune function. Prevent diarrhea. Modify colon cancer risk Affect body weight.","title":"Roles of probiotics:"},{"location":"NFS284/food_safety/#prebiotics","text":"Indigestible carbohydrates (not alive) in fruits and vegetables. Added to foods in purified form Help support growth of beneficial microflora(i.e priobiotics eat prebiotics.)","title":"Prebiotics"},{"location":"NFS284/food_safety/#intestinal-microfloramicrobiome-in-the-large-intestine","text":"Slow movement of components favors growth of bacteria Bacteria can break down indigestible food components such as dietary fibre. Lead to fermentation, intestinal gas","title":"Intestinal microflora(microbiome) in the Large Intestine:"},{"location":"NFS284/food_safety/#breastfeeding-and-infant-gastrointestinal-system","text":"","title":"Breastfeeding and Infant Gastrointestinal System"},{"location":"NFS284/food_safety/#colostrum","text":"Breast milk produced during f irst week after delivery , with a different composition from mature breast milk. Contains immune factors to help protect the infant from infection, particularly in GI tract. Contains antibodies which pass from mother's bloodstream into the milk.","title":"Colostrum:"},{"location":"NFS284/food_safety/#general-breast-milk","text":"Note: enzymes break down food proteases break down proteins lipases break down fats amylases break down starch and sugar.","title":"General Breast Milk"},{"location":"NFS284/food_safety/#breastfeeding","text":"Infants have a suckling reflex for first 4-6 months . That's why they're unable to consume solid food at the beginning. Note: until 6 months of age, Health Canada recommends infants are exclusively breastfed. Breastfeeding is more common among: Mothers with partners Non-smoking mothers Women who give birth at home Non-working mothers","title":"Breastfeeding"},{"location":"NFS284/food_safety/#carbohydrates","text":"Great PREbiotics (promoting growth of Lactobacillus bifidus) reduce risk of gastrointestinal infections in infant's gut. No starch in milk \\Rightarrow \\Rightarrow low amylase in infant gut amylase: enzyme which breaks down starches and sugars, and because there's no starch in milk, you don't need amylase. lactase (breaks down lactose) present in large amoutns in brush border of instestinge","title":"Carbohydrates"},{"location":"NFS284/food_safety/#fat","text":"VERY HIGH in fat (52%) Supports rapid growth rate of newborns. Gastric lipase : plays important role in fat digestion in infants. Lipase: digests, transports and processes dietary lipids(triglycerides, fats, oils) Few pancreatic digestive enzymes in infants compared to adults.","title":"Fat"},{"location":"NFS284/food_safety/#protein","text":"Proteins are absorbed broken down (into amino acids) from adults. Antibodies in breast milk are absorbed intact and enhance the infant's immune system. Infants produce enzyme rennin to digest other proteins.","title":"Protein"},{"location":"NFS284/food_safety/#gastric-bypass-surgery","text":"Recommended to people with High Body Mass index, at risk for chronic disease(type 2 diabestes and cardiovascular disease), have been overweight for a long time.","title":"Gastric Bypass Surgery"},{"location":"NFS284/food_safety/#advantages","text":"Reduces size of stomach Shortens length of intestines, so less food is absorbed by the body(therefore less converted to fat) Therefore Very effective for weight loss","title":"Advantages"},{"location":"NFS284/food_safety/#disadvantages","text":"Because instestine is shortened, the areas where vitamins and minerals are usually abosrbed are now bypassed, so you need vitamins injections to prevent defficiencies. Gastric dumping syndrome : food flow: stomach \\rightarrow \\rightarrow small inestine (sphincter is bypassed). If too much food enters the small intestine quickly, water moves through osmosis from body into the lumen of the gut , because the food is a high solute concentration(and in osmosis solvent molecules(water) move from low solute concentration to high solute concentration) Symptoms include: dizziness, nausea, diarrhea","title":"Disadvantages"},{"location":"NFS284/food_safety/#foor-borne-illness","text":"","title":"Foor-Borne Illness"},{"location":"NFS284/food_safety/#food-infection","text":"Ingestion of living microbes(bacteria, viruses, parasites) . Salmonella : microbe in check and eggs. Destroyed by cooking thoroughly Listeria : microbe in luncheon meats(because eaten without cooking). Microwaving of raw chicken products not recommended, because heating is uneven","title":"Food infection"},{"location":"NFS284/food_safety/#food-intoxication","text":"Ingestion of toxins secreted by microbes . Can occur if all microbes are killed by heat treatment, if the toxin is heat-resistant. E.coli : in been and vegetables grown next to beef. Destroyed by cooking at high temperatures. Staphylococcus aureus : heat-resistant . Spread from humans via coughing and sneezing. Present in meat, potato & macaroni salads. Refrigeration limits bacteria growth .","title":"Food intoxication"},{"location":"NFS284/food_safety/#general-advice","text":"","title":"General Advice"},{"location":"NFS284/food_safety/#temperatures","text":"Avoid unsave temperatures 15-52 C: rapid bacterial growth and bacterial toxins. Food should be at this temperature for minimal amounts of time. 4-15 C and 52-60 C: Some growth may occur. Many Bacteria survive. Cook food at high temperatures(kills most of the bacteria). 75C is minimum temperature for reheating foods. Warming temperatures control growth but allow survival of some bacteria Keep food in cold temperatures. 4C- Stops the growth of most bacteria.","title":"Temperatures"},{"location":"NFS284/food_safety/#food-etiquette","text":"Don't cross-contaminate(raw meats with one knife, fish and shellfish with another knife, unwashed fruits and veggies with another) Wash hands and surfaces often","title":"Food Etiquette"},{"location":"NFS284/general_lessons/","text":"General Lessons Food Safety Food infection Ingestion of living microbes(bacteria, viruses, parasites) . Salmonella : microbe in check and eggs. Destroyed by cooking thoroughly Listeria : microbe in luncheon meats(because eaten without cooking). Microwaving of raw chicken products not recommended, because heating is uneven Food intoxication Ingestion of toxins secreted by microbes . Can occur if all microbes are killed by heat treatment, if the toxin is heat-resistant. E.coli : in been and vegetables grown next to beef. Destroyed by cooking at high temperatures. Staphylococcus aureus : heat-resistant. Spread from humans via coughing and sneezing. Present in meat, potato & macaroni salads. Refrigeration limits bacteria growth. General Advice Temperatures Avoid unsave temperatures 15-52 C: rapid bacterial growth and bacterial toxins. Food should be at this temperature for minimal amounts of time. 4-15 C and 52-60 C: Some growth may occur. Many Bacteria survive. Cook food at high temperatures(kills most of the bacteria). 75C is minimum temperature for reheating foods. Warming temperatures control growth but allow survival of some bacteria Keep food in cold temperatures. 4C- Stops the growth of most bacteria. Food Etiquette Don't cross-contaminate(raw meats with one knife, fish and shellfish with another knife, unwashed fruits and veggies with another) Wash hands and surfaces often","title":"General Lessons"},{"location":"NFS284/general_lessons/#general-lessons","text":"","title":"General Lessons"},{"location":"NFS284/general_lessons/#food-safety","text":"","title":"Food Safety"},{"location":"NFS284/general_lessons/#food-infection","text":"Ingestion of living microbes(bacteria, viruses, parasites) . Salmonella : microbe in check and eggs. Destroyed by cooking thoroughly Listeria : microbe in luncheon meats(because eaten without cooking). Microwaving of raw chicken products not recommended, because heating is uneven","title":"Food infection"},{"location":"NFS284/general_lessons/#food-intoxication","text":"Ingestion of toxins secreted by microbes . Can occur if all microbes are killed by heat treatment, if the toxin is heat-resistant. E.coli : in been and vegetables grown next to beef. Destroyed by cooking at high temperatures. Staphylococcus aureus : heat-resistant. Spread from humans via coughing and sneezing. Present in meat, potato & macaroni salads. Refrigeration limits bacteria growth.","title":"Food intoxication"},{"location":"NFS284/general_lessons/#general-advice","text":"","title":"General Advice"},{"location":"NFS284/general_lessons/#temperatures","text":"Avoid unsave temperatures 15-52 C: rapid bacterial growth and bacterial toxins. Food should be at this temperature for minimal amounts of time. 4-15 C and 52-60 C: Some growth may occur. Many Bacteria survive. Cook food at high temperatures(kills most of the bacteria). 75C is minimum temperature for reheating foods. Warming temperatures control growth but allow survival of some bacteria Keep food in cold temperatures. 4C- Stops the growth of most bacteria.","title":"Temperatures"},{"location":"NFS284/general_lessons/#food-etiquette","text":"Don't cross-contaminate(raw meats with one knife, fish and shellfish with another knife, unwashed fruits and veggies with another) Wash hands and surfaces often","title":"Food Etiquette"},{"location":"NFS284/midterm_prep/","text":"Midterm preparation Lecture Material Intro to nutrition Dietary Referance Intakes Canada's food guide Food labelling Nutrition Research Digestive System Food Safety Food intake assessment natural health products carbohydrates Supporting documents Physiology Fundamentals Natural Health Products Lipids: Chemistry & Digestion(lipids lectures are not included in the test, but supporting document listed here is) Textbook readings Reading 1 Reading 2 Reading 3 Reading 4 Reading 5","title":"Midterm preparation"},{"location":"NFS284/midterm_prep/#midterm-preparation","text":"","title":"Midterm preparation"},{"location":"NFS284/midterm_prep/#lecture-material","text":"Intro to nutrition Dietary Referance Intakes Canada's food guide Food labelling Nutrition Research Digestive System Food Safety Food intake assessment natural health products carbohydrates","title":"Lecture Material"},{"location":"NFS284/midterm_prep/#supporting-documents","text":"Physiology Fundamentals Natural Health Products Lipids: Chemistry & Digestion(lipids lectures are not included in the test, but supporting document listed here is)","title":"Supporting documents"},{"location":"NFS284/midterm_prep/#textbook-readings","text":"Reading 1 Reading 2 Reading 3 Reading 4 Reading 5","title":"Textbook readings"},{"location":"NFS284/week5_carbohydrates/","text":"Week 5: Carbohydrates Chesmistry of Carbohydrates Summary of Structures Monosaccharides: simplest unit of carbohydrates Disaccharide: 2 monosaccharide Oligosaccharide: 3-10 monosaccharides Polysaccharides(10+) monosaccharides Monosaccharides Simplest units of carbohydrates (simple sugars) Cannot by hydrolyzed Examples: Glucose , Galactose , Fructose Disaccharides 2 covalently bonded monosaccharides Examples: Maltose (2 glucose), Sucrose (1 glucose + 1 fructose), Lactose (1 galactose + 1 glucose) Condensation forms covalent bonds and hydrolysis breaks covalent bonds down. Condensation forms a covalent bond , by releasing water(and that's why it's condensation, because you suddently have more water) Hydrolysis breaks down a covalent bond between sugars, by adding water Covalent bond(molecular bond) : chemical bond where atoms share electron pairs. Oligosaccharides Disaccharides contain 2 monosaccharide Oligosaccharides contain 3-10 monosaccharides (most often beans ) Polysaccharides 11+ monosaccharides Digestible(starches, amylose, amylpoectin) They are broken down by enzymes and absorbed Indigestible(dietary fibre, resistant starch) Examples of Polysaccharide Glycogen : a form of polysaccharide produced by body and stored in the liver. One of our best friend, nutritionally When we consume carbohydrates, body breaks them down and stores as glycogen . Any time somebody needs sugar, body breaks down glycogen. glycogen is produced by the body. Our body can store up to 500g of glycogen(will get us through 24 hours if we're very sedentary) Starches : come from food and body can digest them. Most carbohydrates in our diets are starches. Amylopectin : branched polysaccharide Amylose : linear polysaccharide Fiber : come from food and are not digestible . Fiber(on the note of fiber, an important type of Polysaccharide) 2 categories: Dietary Fiber (naturally found in foods: beans, fruits, etc). This is the main one. Functional Fiber (added to foods, isolated from plant sources) Both types of fiber are a mixture of: soluble and insoluble fiber(does not dissolve in water) Dietary fibre is found in fruits, vegetables, whole grains, and legumes. Our body can break down fats, starches, fiber isn't digested by the body . It passes through the stomach, small intestine, and out of the body. A high fiber diet: Aids in achieving a healthy weight . High fiber foods are more filling than low-fiber foods so you will eat less and stay satisfied longer.**** Normalizes bowel movement and maintains bowel health. Dietary fiber increases the weight and size of your stool and softens it. Lowers cholesterol levels and helps control blood sugar levels. Best fiber sources: Whole-grain products Beans, peas and other legumes Nuts and seeds Fruits and vegetables Cellulose is a type of dietary fibre. It looks like a long line of monosaccharides. Polysaccharides of glucose Glyc","title":"Week 5: Carbohydrates"},{"location":"NFS284/week5_carbohydrates/#week-5-carbohydrates","text":"","title":"Week 5: Carbohydrates"},{"location":"NFS284/week5_carbohydrates/#chesmistry-of-carbohydrates","text":"","title":"Chesmistry of Carbohydrates"},{"location":"NFS284/week5_carbohydrates/#summary-of-structures","text":"Monosaccharides: simplest unit of carbohydrates Disaccharide: 2 monosaccharide Oligosaccharide: 3-10 monosaccharides Polysaccharides(10+) monosaccharides","title":"Summary of Structures"},{"location":"NFS284/week5_carbohydrates/#monosaccharides","text":"Simplest units of carbohydrates (simple sugars) Cannot by hydrolyzed Examples: Glucose , Galactose , Fructose","title":"Monosaccharides"},{"location":"NFS284/week5_carbohydrates/#disaccharides","text":"2 covalently bonded monosaccharides Examples: Maltose (2 glucose), Sucrose (1 glucose + 1 fructose), Lactose (1 galactose + 1 glucose) Condensation forms covalent bonds and hydrolysis breaks covalent bonds down. Condensation forms a covalent bond , by releasing water(and that's why it's condensation, because you suddently have more water) Hydrolysis breaks down a covalent bond between sugars, by adding water Covalent bond(molecular bond) : chemical bond where atoms share electron pairs.","title":"Disaccharides"},{"location":"NFS284/week5_carbohydrates/#oligosaccharides","text":"Disaccharides contain 2 monosaccharide Oligosaccharides contain 3-10 monosaccharides (most often beans )","title":"Oligosaccharides"},{"location":"NFS284/week5_carbohydrates/#polysaccharides","text":"11+ monosaccharides Digestible(starches, amylose, amylpoectin) They are broken down by enzymes and absorbed Indigestible(dietary fibre, resistant starch)","title":"Polysaccharides"},{"location":"NFS284/week5_carbohydrates/#examples-of-polysaccharide","text":"Glycogen : a form of polysaccharide produced by body and stored in the liver. One of our best friend, nutritionally When we consume carbohydrates, body breaks them down and stores as glycogen . Any time somebody needs sugar, body breaks down glycogen. glycogen is produced by the body. Our body can store up to 500g of glycogen(will get us through 24 hours if we're very sedentary) Starches : come from food and body can digest them. Most carbohydrates in our diets are starches. Amylopectin : branched polysaccharide Amylose : linear polysaccharide Fiber : come from food and are not digestible .","title":"Examples of Polysaccharide"},{"location":"NFS284/week5_carbohydrates/#fiberon-the-note-of-fiber-an-important-type-of-polysaccharide","text":"2 categories: Dietary Fiber (naturally found in foods: beans, fruits, etc). This is the main one. Functional Fiber (added to foods, isolated from plant sources) Both types of fiber are a mixture of: soluble and insoluble fiber(does not dissolve in water) Dietary fibre is found in fruits, vegetables, whole grains, and legumes. Our body can break down fats, starches, fiber isn't digested by the body . It passes through the stomach, small intestine, and out of the body. A high fiber diet: Aids in achieving a healthy weight . High fiber foods are more filling than low-fiber foods so you will eat less and stay satisfied longer.**** Normalizes bowel movement and maintains bowel health. Dietary fiber increases the weight and size of your stool and softens it. Lowers cholesterol levels and helps control blood sugar levels. Best fiber sources: Whole-grain products Beans, peas and other legumes Nuts and seeds Fruits and vegetables Cellulose is a type of dietary fibre. It looks like a long line of monosaccharides.","title":"Fiber(on the note of fiber, an important type of Polysaccharide)"},{"location":"NFS284/week5_carbohydrates/#polysaccharides-of-glucose","text":"Glyc","title":"Polysaccharides of glucose"},{"location":"NFS284/week_1_nutrition_guidelines/","text":"Chapter 2: Nutrition Guidelines Nutrient-based approach : how much of a nutrient is required to maintain health. Food-based approach: types and amounts of foods to maintain health Dietary Reference Intake(DRI) For planning and assessing diets of healthy i ndividuals. Values for different life stages and males or females: infants, children, teens, young, middle, older adults, pregnancy/lactation. Statistics Estimated Average Requirement(EAR) : Nutrient intake that meets requirement of 50% of individuals in a group. used to estimate probability that an individual's usual intake is meeting their requirement estimate what proportion of a group is meeting their requirement Determined by selecting a biochemical/physiological criterion that allows you to determine the intake at which an individual's requirement is being met e.g Consider Hypothetical Vitamin X. Vitamin X requirement is met when the level of Vitamin X in serum reaches saturation Depletion-Repletion experiment Depletion Feed a vitamin X-free(i.e no vitamin in this diet) diet Track level of vitamin X in blood Eventually levels decline until no vitamin X is detected( the individual is deficient) Repletion Begin by re-feeding vitamin X What happens? Blod levels of vitamin X begins to rise Eventually each individual reaches an intake where there is no corresponding rise in blood levels(blood is saturated with vitamin X) That intake(where vitamin X concentration stops rising, i.e you reach saturation) is the individual vitamin X requirement Probability Individuals are meeting their requirements based on the requirement distribution Normal Distribution: EAR = 100 mg 100 mg is an estimated Average Requirement, i.e the intake level that meets requirements of 50% of subjects. Nutrient intake : amount of nutrient consumed, determined by composition of the diet. Nutrient requirement : experimentally-determined amount required of nutrient to maintain health. Can determine EAR from Vitamin X requirement distribution. EAR represents the average daily nutrient intake that meets the requirements of half the healthy individuals in given group. Area under the curve for a specific individual is the probability that he is meeting the EAR Recommended Dietary Allowance(RDA) RDA: EAR + 2 Standard Deviations. . Esnures 98% probability of meeting your requirement. It is a goal for an individual's usual intake, because it's almost certainly adequate. . Probability proportions of a population are meeting their requirements based on the requirement distribution EAR cut point method : estimates what proportion of a group is meeting their nutrient requirement. Health Canada Considers a population to have an adequate intake if proportion of population whose intake is below EAR is 10% or less . Adequate intake - Insufficient data to calculate an EAR. Based on estimate of average nutrient intake by healthy population. Example: Recommendations for calcium intake for young infants(0-6 months) = 200mg. Adequate intake: 200mg If your intake > AI, then intake OK. If intake < AI, intake may or may not be OK **** Tolerable Upper Intake Level (UL) Tolerable Upper Intale Level(UL) Highest level of habitual nutrient intake that is unlikely to pose risk of adverse effect. If UL = 1 g then you can consume 1 g of nutrient daily without adverse effect. UL is not a recommended level of intake . No additional benefit above RDA. Energy Balance IF Energy content of food consumer > > energy content expanded for metabolism & physical activity \\rightarrow \\rightarrow weight gain IF energy content of food consumed = = energy content expended for metabolism \\rightarrow \\rightarrow weight is unchanged IF energy content of food consumed < < energy content expended for metabolism \\rightarrow \\rightarrow weight loss Know how to use the formula!","title":"Chapter 2: Nutrition Guidelines"},{"location":"NFS284/week_1_nutrition_guidelines/#chapter-2-nutrition-guidelines","text":"Nutrient-based approach : how much of a nutrient is required to maintain health. Food-based approach: types and amounts of foods to maintain health","title":"Chapter 2: Nutrition Guidelines"},{"location":"NFS284/week_1_nutrition_guidelines/#dietary-reference-intakedri","text":"For planning and assessing diets of healthy i ndividuals. Values for different life stages and males or females: infants, children, teens, young, middle, older adults, pregnancy/lactation.","title":"Dietary Reference Intake(DRI)"},{"location":"NFS284/week_1_nutrition_guidelines/#statistics","text":"Estimated Average Requirement(EAR) : Nutrient intake that meets requirement of 50% of individuals in a group. used to estimate probability that an individual's usual intake is meeting their requirement estimate what proportion of a group is meeting their requirement Determined by selecting a biochemical/physiological criterion that allows you to determine the intake at which an individual's requirement is being met e.g Consider Hypothetical Vitamin X. Vitamin X requirement is met when the level of Vitamin X in serum reaches saturation","title":"Statistics"},{"location":"NFS284/week_1_nutrition_guidelines/#depletion-repletion-experiment","text":"","title":"Depletion-Repletion experiment"},{"location":"NFS284/week_1_nutrition_guidelines/#depletion","text":"Feed a vitamin X-free(i.e no vitamin in this diet) diet Track level of vitamin X in blood Eventually levels decline until no vitamin X is detected( the individual is deficient)","title":"Depletion"},{"location":"NFS284/week_1_nutrition_guidelines/#repletion","text":"Begin by re-feeding vitamin X What happens? Blod levels of vitamin X begins to rise Eventually each individual reaches an intake where there is no corresponding rise in blood levels(blood is saturated with vitamin X) That intake(where vitamin X concentration stops rising, i.e you reach saturation) is the individual vitamin X requirement","title":"Repletion"},{"location":"NFS284/week_1_nutrition_guidelines/#probability-individuals-are-meeting-their-requirements-based-on-the-requirement-distribution","text":"Normal Distribution: EAR = 100 mg 100 mg is an estimated Average Requirement, i.e the intake level that meets requirements of 50% of subjects. Nutrient intake : amount of nutrient consumed, determined by composition of the diet. Nutrient requirement : experimentally-determined amount required of nutrient to maintain health. Can determine EAR from Vitamin X requirement distribution. EAR represents the average daily nutrient intake that meets the requirements of half the healthy individuals in given group. Area under the curve for a specific individual is the probability that he is meeting the EAR","title":"Probability Individuals are meeting their requirements based on the requirement distribution"},{"location":"NFS284/week_1_nutrition_guidelines/#recommended-dietary-allowancerda","text":"RDA: EAR + 2 Standard Deviations. . Esnures 98% probability of meeting your requirement. It is a goal for an individual's usual intake, because it's almost certainly adequate. .","title":"Recommended Dietary Allowance(RDA)"},{"location":"NFS284/week_1_nutrition_guidelines/#probability-proportions-of-a-population-are-meeting-their-requirements-based-on-the-requirement-distribution","text":"EAR cut point method : estimates what proportion of a group is meeting their nutrient requirement. Health Canada Considers a population to have an adequate intake if proportion of population whose intake is below EAR is 10% or less . Adequate intake - Insufficient data to calculate an EAR. Based on estimate of average nutrient intake by healthy population. Example: Recommendations for calcium intake for young infants(0-6 months) = 200mg. Adequate intake: 200mg If your intake > AI, then intake OK. If intake < AI, intake may or may not be OK ****","title":"Probability proportions of a population are meeting their requirements based on the requirement distribution"},{"location":"NFS284/week_1_nutrition_guidelines/#tolerable-upper-intake-level-ul","text":"Tolerable Upper Intale Level(UL) Highest level of habitual nutrient intake that is unlikely to pose risk of adverse effect. If UL = 1 g then you can consume 1 g of nutrient daily without adverse effect. UL is not a recommended level of intake . No additional benefit above RDA.","title":"Tolerable Upper Intake Level (UL)"},{"location":"NFS284/week_1_nutrition_guidelines/#energy-balance","text":"IF Energy content of food consumer > > energy content expanded for metabolism & physical activity \\rightarrow \\rightarrow weight gain IF energy content of food consumed = = energy content expended for metabolism \\rightarrow \\rightarrow weight is unchanged IF energy content of food consumed < < energy content expended for metabolism \\rightarrow \\rightarrow weight loss Know how to use the formula!","title":"Energy Balance"},{"location":"NFS284/week_1_readings/","text":"Focus on Phytochemicals Pages(402-408) Textbook Readings Functional foods : Demonstrated to have physiological benefits and/or reduce the risk of chronic disease beyond basic nutritional functions. Phytochemicals : Health-promoting substances in plant foods Zoochemicals : Health-promoting substances in animal foods (i.e meat, dairy, tc) Phytochemicals in the canadian diet Include hundreds, thousands of active non-nutritive chemicals found in plants. Some plant chemicals can be toxic(chemicals in rhubarb leaves can cause symptoms including: abdominal pain, nausea, vomiting. Stems have lower toxins and are safe to eat.) Phytoestrogens : (soy) structure similar to 4estrogen and block or mimic estrogen action. Phylosterol : resemble cholesterol in structure, competes with it for absorption from gastrointestinal tract and thus reduces the presence of blod cholesterol Carotenoids Caretonoid gives fruits/vegetables a yellow-orange colour(carrots, sweet potatoes, acorn squash, apricots, mangoes). Other caretonoid-containing fruits are masked by green colour of leafy greens. High intake of carotenoid-containing fruits and vegetables has been associated with reduced risk of certain cancers, cardiovascular diseases, and age-related eye diseases. Macular degeneration is Leading cause of blindness in adults over 55. Caretonoids help with that. cause of blindness in adult Have antioxidant properties, some have vitamin A activity. Polyphenols characterized structurally by presence of phenolic rings. Give blue and red colours to blueberries, raspberries, and red cabbage. Give pale yellow colour to potatoes, onions and orange rind. Polyphenolic compounds of green tea have been widely studied and may protect against cancer and heart disease. Polyphenolic effect of berries may have proactive effect on cardiovascular health. Polyphenolic compound in grapes and wine, resveratrol, may be linked to increased longevity and reduced risk of cancer and heart disease Found in fruits, vegetables, wine, grape juice, chocolate and green tea. Phytoestrogen Special polyophenolic compounds in plants, that have chemical structures simular to human hormone estrogen, especially after modification by human gut flora. Believed to interrupt cancer developemnt and affect health by binding to estrogen receptors on cells and blocking or altering estrogen functions. Include isoflavones which are found in soybeans, flaxseed, and barley, and may protect against cancer and osteoporosis. Indoles, Isiothiocyanates, and Alliums Cruciferous vegetables cruciferous vegetables such as broccoli, cauliflower, brussel sprouts, cabbage, and greens like mustard, collards are a good source of sulfur-containing phytochemicals. Stimulate activity of enzymes that detoxify carcinogens Sulfur compounds Garlic, onions, leeks, chives, and shallots contain sulfur compounds. Boost activity of cancer-destroyng enzyme systems, protect against oxidative damage, defend against heart disease by lowering blood cholesterol, blood pressure, and platelet activity. Prevents bacteria in the gut from converting nitrates into nitrites, which can form carcinogens. Chocolate Constains chemical compounds that can give a mood boost. Causes brain to produce natural opiates, which dull pain and increase well-being. Can mimic effects of THC - causing a chocolate high. Has compounds which raise blood pressure and blood sugar, which can incresae alertness and contenment. Contains caffeeine and related compounds that make us feel more alert. Dark chocolate contains polyphenolic antixodiants, which may protect against heart disease and other health problems. COntains more antioxidants than red wine or blueberries. POlyphenols in dark chocolate improve arterial function, lower blood pressure, and improve insulin sensitivity. Added sugar and cocoa butter dilutes concentration of phytochemicals, and increases caloric content. Half of the fat in cocoa butter is saturated far, which may increase the risk of cardiovascular disease. Light chocolate doesn't contain as many phytochemicals as dark chocolate, and white chocolate contains no phytochemicals at all, since it doesn't have any cocoa. Dark chocolate, then, made from 70% or more cocoa, provides minerals and antioxidants that may reduce disease risk. If additional research confirms this beneficial effect, then dark chocolate would qualify as a functional food. Choosing a Phytochemical-rich Diet Difficult to make quantitative recommendations for intake of specific phytochemicals, since Choose diet based on plant foods. Impact of the total diet is more significant than that of any single phytochemical. A diet high in plant sterols, soy, almonds, and foods like oats, barley, psyllium, okra and eggplant(high in soluble fibre) lowered cholesterol as much as prescription medication. Eat green and orange vegetables daily Grains Grain contains as many if not more phytochemicals and antioxidantas than fruits and vegetables. Whole grains are rich in antioxidant phytochemicals, Plant Proteins Phytochemical-rich soybeans and flaxseeds are great sources of protein, and legumes like nuts, and seeds are high-protein foods that make important fibre and phytochemical contributions. Recommend to choose beans, peas, nuts, and seeds more often. Lecture Slides","title":"Focus on Phytochemicals"},{"location":"NFS284/week_1_readings/#focus-on-phytochemicals","text":"Pages(402-408)","title":"Focus on Phytochemicals"},{"location":"NFS284/week_1_readings/#textbook-readings","text":"Functional foods : Demonstrated to have physiological benefits and/or reduce the risk of chronic disease beyond basic nutritional functions. Phytochemicals : Health-promoting substances in plant foods Zoochemicals : Health-promoting substances in animal foods (i.e meat, dairy, tc)","title":"Textbook Readings"},{"location":"NFS284/week_1_readings/#phytochemicals-in-the-canadian-diet","text":"Include hundreds, thousands of active non-nutritive chemicals found in plants. Some plant chemicals can be toxic(chemicals in rhubarb leaves can cause symptoms including: abdominal pain, nausea, vomiting. Stems have lower toxins and are safe to eat.) Phytoestrogens : (soy) structure similar to 4estrogen and block or mimic estrogen action. Phylosterol : resemble cholesterol in structure, competes with it for absorption from gastrointestinal tract and thus reduces the presence of blod cholesterol","title":"Phytochemicals in the canadian diet"},{"location":"NFS284/week_1_readings/#carotenoids","text":"Caretonoid gives fruits/vegetables a yellow-orange colour(carrots, sweet potatoes, acorn squash, apricots, mangoes). Other caretonoid-containing fruits are masked by green colour of leafy greens. High intake of carotenoid-containing fruits and vegetables has been associated with reduced risk of certain cancers, cardiovascular diseases, and age-related eye diseases. Macular degeneration is Leading cause of blindness in adults over 55. Caretonoids help with that. cause of blindness in adult Have antioxidant properties, some have vitamin A activity.","title":"Carotenoids"},{"location":"NFS284/week_1_readings/#polyphenols","text":"characterized structurally by presence of phenolic rings. Give blue and red colours to blueberries, raspberries, and red cabbage. Give pale yellow colour to potatoes, onions and orange rind. Polyphenolic compounds of green tea have been widely studied and may protect against cancer and heart disease. Polyphenolic effect of berries may have proactive effect on cardiovascular health. Polyphenolic compound in grapes and wine, resveratrol, may be linked to increased longevity and reduced risk of cancer and heart disease Found in fruits, vegetables, wine, grape juice, chocolate and green tea.","title":"Polyphenols"},{"location":"NFS284/week_1_readings/#phytoestrogen","text":"Special polyophenolic compounds in plants, that have chemical structures simular to human hormone estrogen, especially after modification by human gut flora. Believed to interrupt cancer developemnt and affect health by binding to estrogen receptors on cells and blocking or altering estrogen functions. Include isoflavones which are found in soybeans, flaxseed, and barley, and may protect against cancer and osteoporosis.","title":"Phytoestrogen"},{"location":"NFS284/week_1_readings/#indoles-isiothiocyanates-and-alliums","text":"","title":"Indoles, Isiothiocyanates, and Alliums"},{"location":"NFS284/week_1_readings/#cruciferous-vegetables","text":"cruciferous vegetables such as broccoli, cauliflower, brussel sprouts, cabbage, and greens like mustard, collards are a good source of sulfur-containing phytochemicals. Stimulate activity of enzymes that detoxify carcinogens","title":"Cruciferous vegetables"},{"location":"NFS284/week_1_readings/#sulfur-compounds","text":"Garlic, onions, leeks, chives, and shallots contain sulfur compounds. Boost activity of cancer-destroyng enzyme systems, protect against oxidative damage, defend against heart disease by lowering blood cholesterol, blood pressure, and platelet activity. Prevents bacteria in the gut from converting nitrates into nitrites, which can form carcinogens.","title":"Sulfur compounds"},{"location":"NFS284/week_1_readings/#chocolate","text":"Constains chemical compounds that can give a mood boost. Causes brain to produce natural opiates, which dull pain and increase well-being. Can mimic effects of THC - causing a chocolate high. Has compounds which raise blood pressure and blood sugar, which can incresae alertness and contenment. Contains caffeeine and related compounds that make us feel more alert. Dark chocolate contains polyphenolic antixodiants, which may protect against heart disease and other health problems. COntains more antioxidants than red wine or blueberries. POlyphenols in dark chocolate improve arterial function, lower blood pressure, and improve insulin sensitivity. Added sugar and cocoa butter dilutes concentration of phytochemicals, and increases caloric content. Half of the fat in cocoa butter is saturated far, which may increase the risk of cardiovascular disease. Light chocolate doesn't contain as many phytochemicals as dark chocolate, and white chocolate contains no phytochemicals at all, since it doesn't have any cocoa. Dark chocolate, then, made from 70% or more cocoa, provides minerals and antioxidants that may reduce disease risk. If additional research confirms this beneficial effect, then dark chocolate would qualify as a functional food.","title":"Chocolate"},{"location":"NFS284/week_1_readings/#choosing-a-phytochemical-rich-diet","text":"Difficult to make quantitative recommendations for intake of specific phytochemicals, since Choose diet based on plant foods. Impact of the total diet is more significant than that of any single phytochemical. A diet high in plant sterols, soy, almonds, and foods like oats, barley, psyllium, okra and eggplant(high in soluble fibre) lowered cholesterol as much as prescription medication. Eat green and orange vegetables daily","title":"Choosing a Phytochemical-rich Diet"},{"location":"NFS284/week_1_readings/#grains","text":"Grain contains as many if not more phytochemicals and antioxidantas than fruits and vegetables. Whole grains are rich in antioxidant phytochemicals,","title":"Grains"},{"location":"NFS284/week_1_readings/#plant-proteins","text":"Phytochemical-rich soybeans and flaxseeds are great sources of protein, and legumes like nuts, and seeds are high-protein foods that make important fibre and phytochemical contributions. Recommend to choose beans, peas, nuts, and seeds more often.","title":"Plant Proteins"},{"location":"NFS284/week_1_readings/#lecture","text":"","title":"Lecture"},{"location":"NFS284/week_1_readings/#slides","text":"","title":"Slides"},{"location":"NFS284/week_2_food_guide/","text":"Canada's Food Guide Controversies about Canada's Food Guide 2007 Not enough emphasis on whole grains Food groups may be industry-influenced(Beef and dairy industry) Includes Includes fruit juice Emphasizes total fat intake instead of type of fat. Poor messaging on fat: types of fat(saturated vs unsaturated) are actually more important than total fat intake Not enough emphasis on whole grains Uses prescriptive serving sizes. Consumers prefer proportions instead of absolute amounts. New Canadian FoodGuide 3 main ideas Nutritious foods are the foundation for healthy living. Vegetables, fruits, whole grains, and protein should be consumed regularly. Among protein foods, consume plant-based more often. Protein foods include: legumes, nuts, seeds, tofu, fortified soy beverages, fish, shellfish, eggs, poultry, lean red meat, lower fat milk, lower fat yogurts, lower fat kefir, cheeses lower in fat and sodium Foods that contain mostly unsaturated fats should replace foods that contain mostly saturated fats . Water should be the beverage of choice. Processed or prepared foods and beverages contribute to excess sodium , free sugars , or saturated fat undermine healthy eating and should not be consumed regularly. Food skills are needed to navigate the complex food environment and support healthy eating. Food labels should be promoted as a tool to help Canadians make informed food choices Cooking and food preparation using nutritious foods should be promoted as a practical way to support heatlhy eating. Food Choices Key Points Eat vegetables and fruits Eat whole grains Choose protein foods that come from plants more often Choose foods with healthy fats instead of saturated fats Limit highly processed foods . Prepare meals and snacks with ingredients that have little to no sodium, sugars or saturated fats Choose healthier options when eating out. Make water your drink of choice Use food labels Be aware that food marketing can influence your choices Vegetables: Vegetables and fruits have important nutrients such as: fibre, vitamins, minerals. Include half of vegetables and fruits in your meals. Replace juice with water. Fruit juice and fruit juice concentrates are high in sugars. Eating variety of vegetables and fruits may lower risk of heart disease . How to eat more vegetables Wash, chop and refrigerate extra vegetables so you have some ready for next day Use pre-bagged vegetables that can be quickly tossed in a salad, stir-fry or casserole Serve raw vegetables with meals Whole grain foods Whole grain foods have important nutrients such as: fibre, vitamins, minerals. Whole grain are a healthier choice than refined grains because they include ALL PARTS of the grain. Whole grain have more fibre than refined grains. Eating foods higher in fibre can lower your risk of: Stroke Colon Cancer Heart disease Type 2 diabetes Examples of whole grain: farro, oats, quinoa, brown rice, whole grain pasta, whole grain bread. Read ingredient list and choose foods that have the word \"whole grain\" Protein Foods Have important nutrients such as: protein, vitamins, minerals. Most often Choose proteins that come from plants . They can provide more fibre and less saturated fat than other types of protein foods. Eat protein foods such as: eggs, lean meats , nuts and seeds, fish and shellfish, lower fat dairy products , beans, peas and lentils, soy beverages, tofu Healthy Fats Choosing fats with healthy fats instead of saturated fats can lower your risk of heart disease . Heart disease is 1 of the leading causes of death in Canada. The type of fat you eat over time is more important for health than the total amount of fat you eat Foods containing saturated fats: Fatty meats , h igh fat dairy products , highly processed foods , tropical oils like palm and coconut, ice cream , deep fried foods like French Fries , pizza and other foods containing lots of cheese Choose lean cuts of meat and skinless poultry. Trim off as much of the visible fat as possible Drain fat from cooked ground meat. Drinks Make water the drink of your choice Healthy drink options other than water can include: ### Limiting highly processed foods Processed or prepared foods and drinks that add excess sodium, sugars, or saturated fat to the diets of Canadians. Highly processed foods include: Sugary Drinks, chocolates and candies, ice cream Fast foods like French Fries and burgers Frozen entrees like pasta dishes and pizzas Bakery products like muffins, buns and cakes","title":"Canada's Food Guide"},{"location":"NFS284/week_2_food_guide/#canadas-food-guide","text":"","title":"Canada's Food Guide"},{"location":"NFS284/week_2_food_guide/#controversies-about-canadas-food-guide-2007","text":"Not enough emphasis on whole grains Food groups may be industry-influenced(Beef and dairy industry) Includes Includes fruit juice Emphasizes total fat intake instead of type of fat. Poor messaging on fat: types of fat(saturated vs unsaturated) are actually more important than total fat intake Not enough emphasis on whole grains Uses prescriptive serving sizes. Consumers prefer proportions instead of absolute amounts.","title":"Controversies about Canada's Food Guide 2007"},{"location":"NFS284/week_2_food_guide/#new-canadian-foodguide","text":"","title":"New Canadian FoodGuide"},{"location":"NFS284/week_2_food_guide/#3-main-ideas","text":"Nutritious foods are the foundation for healthy living. Vegetables, fruits, whole grains, and protein should be consumed regularly. Among protein foods, consume plant-based more often. Protein foods include: legumes, nuts, seeds, tofu, fortified soy beverages, fish, shellfish, eggs, poultry, lean red meat, lower fat milk, lower fat yogurts, lower fat kefir, cheeses lower in fat and sodium Foods that contain mostly unsaturated fats should replace foods that contain mostly saturated fats . Water should be the beverage of choice. Processed or prepared foods and beverages contribute to excess sodium , free sugars , or saturated fat undermine healthy eating and should not be consumed regularly. Food skills are needed to navigate the complex food environment and support healthy eating. Food labels should be promoted as a tool to help Canadians make informed food choices Cooking and food preparation using nutritious foods should be promoted as a practical way to support heatlhy eating.","title":"3 main ideas"},{"location":"NFS284/week_2_food_guide/#food-choices-key-points","text":"Eat vegetables and fruits Eat whole grains Choose protein foods that come from plants more often Choose foods with healthy fats instead of saturated fats Limit highly processed foods . Prepare meals and snacks with ingredients that have little to no sodium, sugars or saturated fats Choose healthier options when eating out. Make water your drink of choice Use food labels Be aware that food marketing can influence your choices","title":"Food Choices Key Points"},{"location":"NFS284/week_2_food_guide/#vegetables","text":"Vegetables and fruits have important nutrients such as: fibre, vitamins, minerals. Include half of vegetables and fruits in your meals. Replace juice with water. Fruit juice and fruit juice concentrates are high in sugars. Eating variety of vegetables and fruits may lower risk of heart disease . How to eat more vegetables Wash, chop and refrigerate extra vegetables so you have some ready for next day Use pre-bagged vegetables that can be quickly tossed in a salad, stir-fry or casserole Serve raw vegetables with meals","title":"Vegetables:"},{"location":"NFS284/week_2_food_guide/#whole-grain-foods","text":"Whole grain foods have important nutrients such as: fibre, vitamins, minerals. Whole grain are a healthier choice than refined grains because they include ALL PARTS of the grain. Whole grain have more fibre than refined grains. Eating foods higher in fibre can lower your risk of: Stroke Colon Cancer Heart disease Type 2 diabetes Examples of whole grain: farro, oats, quinoa, brown rice, whole grain pasta, whole grain bread. Read ingredient list and choose foods that have the word \"whole grain\"","title":"Whole grain foods"},{"location":"NFS284/week_2_food_guide/#protein-foods","text":"Have important nutrients such as: protein, vitamins, minerals. Most often Choose proteins that come from plants . They can provide more fibre and less saturated fat than other types of protein foods. Eat protein foods such as: eggs, lean meats , nuts and seeds, fish and shellfish, lower fat dairy products , beans, peas and lentils, soy beverages, tofu","title":"Protein Foods"},{"location":"NFS284/week_2_food_guide/#healthy-fats","text":"Choosing fats with healthy fats instead of saturated fats can lower your risk of heart disease . Heart disease is 1 of the leading causes of death in Canada. The type of fat you eat over time is more important for health than the total amount of fat you eat Foods containing saturated fats: Fatty meats , h igh fat dairy products , highly processed foods , tropical oils like palm and coconut, ice cream , deep fried foods like French Fries , pizza and other foods containing lots of cheese Choose lean cuts of meat and skinless poultry. Trim off as much of the visible fat as possible Drain fat from cooked ground meat.","title":"Healthy Fats"},{"location":"NFS284/week_2_food_guide/#drinks","text":"Make water the drink of your choice Healthy drink options other than water can include:","title":"Drinks"},{"location":"NFS284/week_2_food_guide/#limiting-highly-processed-foods","text":"Processed or prepared foods and drinks that add excess sodium, sugars, or saturated fat to the diets of Canadians. Highly processed foods include: Sugary Drinks, chocolates and candies, ice cream Fast foods like French Fries and burgers Frozen entrees like pasta dishes and pizzas Bakery products like muffins, buns and cakes","title":"### Limiting highly processed foods"},{"location":"NFS284/week_2_food_labels/","text":"Food Labels(PP): How to read and Understand Food labels Requirements on a food label today Product Name Product amount Product manufacturer or distributor Best before date of perishable items List of ingredients Nutrition facts table Use food labels to select foods low in Saturated fat, sugars, sodium and kcalories Daily Value Standard nutrient amount %DV indicates how much of nutrient is in a food out of how much you need in a day. Analyzing nutrition facts with Daily Value <=5% DV(daily value )is a little. 5% - 15% DV is decent 15%+ DV is a lot Nutrients to limit (Fat, Sat/Trans fat, Sodium, Sugars) Avoid more than 15% Aim for less than 5% All nutrients with a mandatory Daily Value should be limited( Fat, Saturated & Trans Fats, Sugars, Sodium ) Nutrients to get enough Vitamin A, Vitamin C, Calcium, Iron Avoid less than 5% - too little Aim for a lot : >= 15% Ingredients List In Canada, you can add a nutrient content claim ( product contains specific nutrient ) without approval from Health Canada In Canada you can add a nutrient function claim ( nutrient does specific thing ) without approval from Health Canada Disease reduction claim(including therapeutic claims) require prior approval from Health Canada Nutrient Content Claims Source of contains 5% source of DV. Good source of contains 15% of DV. Excellent source of contains 25% of DV except for Vitamin C, where it must contain 50% or more. Synonyms: rich in , high Free means contains no amount of, or trivial amount of saturated fat, trans fat, cholesterol, sodium, sugars, kcalopries, etc. Trans fat free means less than 0.2g of trans fat + less than 2g of saturated fat per serving. Nutrient Function Claims Foods must contain at least 5% of DV Claim must mention food + nutrient Health CLaims Disease Reduction claims Must request permission from Health Canada Scientific evidence must strongly support the claim How to use NFT(Nutrition Facts Table) to Compare products","title":"Food Labels(PP): *How to read and Understand Food labels*"},{"location":"NFS284/week_2_food_labels/#food-labelspp-how-to-read-and-understand-food-labels","text":"","title":"Food Labels(PP): How to read and Understand Food labels"},{"location":"NFS284/week_2_food_labels/#requirements-on-a-food-label-today","text":"Product Name Product amount Product manufacturer or distributor Best before date of perishable items List of ingredients Nutrition facts table Use food labels to select foods low in Saturated fat, sugars, sodium and kcalories","title":"Requirements on a food label today"},{"location":"NFS284/week_2_food_labels/#daily-value","text":"Standard nutrient amount %DV indicates how much of nutrient is in a food out of how much you need in a day. Analyzing nutrition facts with Daily Value <=5% DV(daily value )is a little. 5% - 15% DV is decent 15%+ DV is a lot","title":"Daily Value"},{"location":"NFS284/week_2_food_labels/#nutrients-to-limit","text":"(Fat, Sat/Trans fat, Sodium, Sugars) Avoid more than 15% Aim for less than 5% All nutrients with a mandatory Daily Value should be limited( Fat, Saturated & Trans Fats, Sugars, Sodium )","title":"Nutrients to limit"},{"location":"NFS284/week_2_food_labels/#nutrients-to-get-enough","text":"Vitamin A, Vitamin C, Calcium, Iron Avoid less than 5% - too little Aim for a lot : >= 15%","title":"Nutrients to get enough"},{"location":"NFS284/week_2_food_labels/#ingredients-list","text":"In Canada, you can add a nutrient content claim ( product contains specific nutrient ) without approval from Health Canada In Canada you can add a nutrient function claim ( nutrient does specific thing ) without approval from Health Canada Disease reduction claim(including therapeutic claims) require prior approval from Health Canada","title":"Ingredients List"},{"location":"NFS284/week_2_food_labels/#nutrient-content-claims","text":"Source of contains 5% source of DV. Good source of contains 15% of DV. Excellent source of contains 25% of DV except for Vitamin C, where it must contain 50% or more. Synonyms: rich in , high Free means contains no amount of, or trivial amount of saturated fat, trans fat, cholesterol, sodium, sugars, kcalopries, etc. Trans fat free means less than 0.2g of trans fat + less than 2g of saturated fat per serving.","title":"Nutrient Content Claims"},{"location":"NFS284/week_2_food_labels/#nutrient-function-claims","text":"Foods must contain at least 5% of DV Claim must mention food + nutrient","title":"Nutrient Function Claims"},{"location":"NFS284/week_2_food_labels/#health-claims-disease-reduction-claims","text":"Must request permission from Health Canada Scientific evidence must strongly support the claim","title":"Health CLaims Disease Reduction claims"},{"location":"NFS284/week_2_food_labels/#how-to-use-nftnutrition-facts-table-to-compare-products","text":"","title":"How to use NFT(Nutrition Facts Table) to Compare products"},{"location":"NFS284/week_3_nutrition_research/","text":"Week 3: Nutrition Reasearch Get subject specific research from PubMed @ UofT Studies There are 2 types of studies: Observational studies and Randomized controlled trials . Observational studies (checks statistical significance in low exposure vs high exposure): Are the differences in disease outcome between low and high exposure statistically significant? Randomized Control trial (checks statistical significance in control vs intervention): Are differences between control group and treatment group statistically significant? Observational studies/ Prospective Cohort studies Observational studies do not establish causality They study association beteen exposure and outcome . Association can be: +ve, -ve. There can exist confounding factors (related to both the outcome and the exposure). If cancer cases are outcomes and the exposure is dietary outcome, we can also have exercise as a confoudning factor. We need to always correct for confounding factors, however we will still be left with residual confounding(uncorrected or unknown confounding). It's because of residual confounding, that we cannot establish causality. However, we can still establish association between exposure(high/low exposure to something) and outcomes. Advantages: Can measure hard disease outcomes if follow-up is long enough Disadvantages: Show association but not causal links, between exposure and outcome Vulnerable to confounding & residual confounding Measuring exposure: How to capture intake Food frequency questionnaire(FFQ) 3 or 7 day food records 24-hour dietary recalls Mobile devices, photography Biomarkers of intake The order of this is from low cost to high cost and from low accuracy to high accuracy Randomized Controlled Trials(RCT) Advantages Show causation Evidence is considered stronger than observational studies Disadvantages Difficult to sustain , especially if it requires any big changes Measures risk factors for disease rather than disease outcome. Let's consider nutrition research We have a control group(typical diet population) and an intervention group(reserachers decide on changes in diet) Control group gets dummy treatment in order so that both control group and intervention groups have equal levels of placebo. Assignment to control or treatment group is random . Because the only difference btn control and treatment is the treatment of intervention(confounding factors are equally distributed between both gorups, since they're assigned randomly), we can establish a causal link between treatment and outcome can be established. Binding Double bind: Both participants and researcher don't know which group a participant is in Single bine: Participant or researcher don't know which group participant is in. Binding not always possible in diet study Nutrition intervention Nutrition education(you're taught frequently about health effects.) Supplement(you're given a supplement) Metabolic diet(you're given your meals) Statistical Concepts Hypothesis We have Null Hypothesis(no effect) and alternative hypothesis Probability or p-value determines probaiblity that an observed difference would occur assuming the null hypothesis is true(that there is no effect). Therefore, what's the chance of this occuring? \"Given that our null hypothesis(base hypothesis: there is no difference) is true, what's the chance of this outcome happening?\" If < 5% reject it. 3* Relative risk Use to determine risk between 2 groups(one with high exposure, annother one with low expsure), relative to one of them. If RR > 1, then risk is increased. Confidence Interval (CI) for relative risk: 95% confidence interval: There is a 95% chance that interval contains the \"true\" population value.95% CI indicates statistical significance and likely range of risk Assume High Intake Group: RR=1.5(95%CI:1.38-1.65). Statistically significant difference from reference group(RR=1) because interval doesn't include 1. Evaluating observational studies. Outcomes: the things that are measured Comparison/Control: e.g low-fat diet, with nutritient education or 1-2 mediterranian diets. Systematic Review Summarize results of multiple studies on the same topic Meta-analysis is a \"weighted average\" of results of multiple studies Results are not considrered in the process, just that they meet certain criteria(population, exposure,outcome,etc)","title":"Week 3: Nutrition Reasearch"},{"location":"NFS284/week_3_nutrition_research/#week-3-nutrition-reasearch","text":"Get subject specific research from PubMed @ UofT","title":"Week 3: Nutrition Reasearch"},{"location":"NFS284/week_3_nutrition_research/#studies","text":"There are 2 types of studies: Observational studies and Randomized controlled trials . Observational studies (checks statistical significance in low exposure vs high exposure): Are the differences in disease outcome between low and high exposure statistically significant? Randomized Control trial (checks statistical significance in control vs intervention): Are differences between control group and treatment group statistically significant?","title":"Studies"},{"location":"NFS284/week_3_nutrition_research/#observational-studies-prospective-cohort-studies","text":"Observational studies do not establish causality They study association beteen exposure and outcome . Association can be: +ve, -ve. There can exist confounding factors (related to both the outcome and the exposure). If cancer cases are outcomes and the exposure is dietary outcome, we can also have exercise as a confoudning factor. We need to always correct for confounding factors, however we will still be left with residual confounding(uncorrected or unknown confounding). It's because of residual confounding, that we cannot establish causality. However, we can still establish association between exposure(high/low exposure to something) and outcomes.","title":"Observational studies/ Prospective Cohort studies"},{"location":"NFS284/week_3_nutrition_research/#advantages","text":"Can measure hard disease outcomes if follow-up is long enough","title":"Advantages:"},{"location":"NFS284/week_3_nutrition_research/#disadvantages","text":"Show association but not causal links, between exposure and outcome Vulnerable to confounding & residual confounding","title":"Disadvantages:"},{"location":"NFS284/week_3_nutrition_research/#measuring-exposure-how-to-capture-intake","text":"Food frequency questionnaire(FFQ) 3 or 7 day food records 24-hour dietary recalls Mobile devices, photography Biomarkers of intake The order of this is from low cost to high cost and from low accuracy to high accuracy","title":"Measuring exposure: How to capture intake"},{"location":"NFS284/week_3_nutrition_research/#randomized-controlled-trialsrct","text":"","title":"Randomized Controlled Trials(RCT)"},{"location":"NFS284/week_3_nutrition_research/#advantages_1","text":"Show causation Evidence is considered stronger than observational studies","title":"Advantages"},{"location":"NFS284/week_3_nutrition_research/#disadvantages_1","text":"Difficult to sustain , especially if it requires any big changes Measures risk factors for disease rather than disease outcome. Let's consider nutrition research We have a control group(typical diet population) and an intervention group(reserachers decide on changes in diet) Control group gets dummy treatment in order so that both control group and intervention groups have equal levels of placebo. Assignment to control or treatment group is random . Because the only difference btn control and treatment is the treatment of intervention(confounding factors are equally distributed between both gorups, since they're assigned randomly), we can establish a causal link between treatment and outcome can be established.","title":"Disadvantages"},{"location":"NFS284/week_3_nutrition_research/#binding","text":"Double bind: Both participants and researcher don't know which group a participant is in Single bine: Participant or researcher don't know which group participant is in. Binding not always possible in diet study","title":"Binding"},{"location":"NFS284/week_3_nutrition_research/#nutrition-intervention","text":"Nutrition education(you're taught frequently about health effects.) Supplement(you're given a supplement) Metabolic diet(you're given your meals)","title":"Nutrition intervention"},{"location":"NFS284/week_3_nutrition_research/#statistical-concepts","text":"Hypothesis We have Null Hypothesis(no effect) and alternative hypothesis Probability or p-value determines probaiblity that an observed difference would occur assuming the null hypothesis is true(that there is no effect). Therefore, what's the chance of this occuring? \"Given that our null hypothesis(base hypothesis: there is no difference) is true, what's the chance of this outcome happening?\" If < 5% reject it. 3* Relative risk Use to determine risk between 2 groups(one with high exposure, annother one with low expsure), relative to one of them. If RR > 1, then risk is increased. Confidence Interval (CI) for relative risk: 95% confidence interval: There is a 95% chance that interval contains the \"true\" population value.95% CI indicates statistical significance and likely range of risk Assume High Intake Group: RR=1.5(95%CI:1.38-1.65). Statistically significant difference from reference group(RR=1) because interval doesn't include 1.","title":"Statistical Concepts"},{"location":"NFS284/week_3_nutrition_research/#evaluating-observational-studies","text":"Outcomes: the things that are measured Comparison/Control: e.g low-fat diet, with nutritient education or 1-2 mediterranian diets.","title":"Evaluating observational studies."},{"location":"NFS284/week_3_nutrition_research/#systematic-review","text":"Summarize results of multiple studies on the same topic Meta-analysis is a \"weighted average\" of results of multiple studies Results are not considrered in the process, just that they meet certain criteria(population, exposure,outcome,etc)","title":"Systematic Review"},{"location":"NFS284/week_4_food_assessment/","text":"Week 4: Food Intake Assessment Most popular ways 3-day food record 24-hour recall Food Frequency Questionnaire(FFQ) 24-hour recall Individuals asked about their food intakes. Participant asked to recall everything consumed day( type + quantity ) before the interview. Interview can be on phone, in group setting, or in person. 4 parts: meal/time eaten Food name Method of preparation Amount Advantages Does not alter eating patterns( 3-day record may alter it cause you have to recall it ) Most work done by the interviewer , 3 day food record requires commitment from the participant. Disadvantages Relies on participants memory, Participant can forget certain foods. Provides information for only one day Food Frequency Questionnaire(FFQ)-> Survey Determines food patterns over period of time Survey can be completed with trained interviewer or independently(1hour or less) Props/ Photos used to estimate amount consumed Advantages If FFQ is comprehensive(includes all foods with their portions), can estimate nutrient intake . It's a lot more reliable as relative measure of nutrient r food intake(comparing high vs low intakes). Can be validated by comparing with multiple 24-hour recalls Disadvantages Relies on memory of participants Participants require higher degree of literacy than 24-hour recall(interviewer asks them question) Natural Health Products Try to achieve balance between tradition and scientific evidence Often don't include all ingredients. Fine for natural products: $5,000. Fine for drugs: 5,000,000\\ 5,000,000\\ Tradition: In use for > 50 years Scientific Use Need scientific evidence of effectiveness(one RCT/few RCT's enough)","title":"Week 4: Food Intake Assessment"},{"location":"NFS284/week_4_food_assessment/#week-4-food-intake-assessment","text":"","title":"Week 4: Food Intake Assessment"},{"location":"NFS284/week_4_food_assessment/#most-popular-ways","text":"3-day food record 24-hour recall Food Frequency Questionnaire(FFQ)","title":"Most popular ways"},{"location":"NFS284/week_4_food_assessment/#24-hour-recall","text":"Individuals asked about their food intakes. Participant asked to recall everything consumed day( type + quantity ) before the interview. Interview can be on phone, in group setting, or in person. 4 parts: meal/time eaten Food name Method of preparation Amount","title":"24-hour recall"},{"location":"NFS284/week_4_food_assessment/#advantages","text":"Does not alter eating patterns( 3-day record may alter it cause you have to recall it ) Most work done by the interviewer , 3 day food record requires commitment from the participant.","title":"Advantages"},{"location":"NFS284/week_4_food_assessment/#disadvantages","text":"Relies on participants memory, Participant can forget certain foods. Provides information for only one day","title":"Disadvantages"},{"location":"NFS284/week_4_food_assessment/#food-frequency-questionnaireffq-survey","text":"Determines food patterns over period of time Survey can be completed with trained interviewer or independently(1hour or less) Props/ Photos used to estimate amount consumed","title":"Food Frequency Questionnaire(FFQ)-&gt; Survey"},{"location":"NFS284/week_4_food_assessment/#advantages_1","text":"If FFQ is comprehensive(includes all foods with their portions), can estimate nutrient intake . It's a lot more reliable as relative measure of nutrient r food intake(comparing high vs low intakes). Can be validated by comparing with multiple 24-hour recalls","title":"Advantages"},{"location":"NFS284/week_4_food_assessment/#disadvantages_1","text":"Relies on memory of participants Participants require higher degree of literacy than 24-hour recall(interviewer asks them question)","title":"Disadvantages"},{"location":"NFS284/week_4_food_assessment/#natural-health-products","text":"Try to achieve balance between tradition and scientific evidence Often don't include all ingredients. Fine for natural products: $5,000. Fine for drugs: 5,000,000\\ 5,000,000\\","title":"Natural Health Products"},{"location":"NFS284/week_4_food_assessment/#tradition","text":"In use for > 50 years","title":"Tradition:"},{"location":"NFS284/week_4_food_assessment/#scientific-use","text":"Need scientific evidence of effectiveness(one RCT/few RCT's enough)","title":"Scientific Use"}]}