{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"ddl/","text":"Data Definition Language(DDL) Types Each column must have a type. List of possible types: Char(n): fixed-length string of n characters, padded with blanks if necessary Varchar(n): variable-length string of up to n characters Text: variable-length, unlimited . PSQL and other implementations support it, but it's not in SQL standard. Int: just integer Float: Real number(+/-, decimal places, etc) e.g: 1.49, 37.96e2 Boolean e.g: TRUE, FALSE Time-related: Date : just the date, no time in hrs, minuts, e.g: \u20182011-09-22\u2019 Time : just the time in hrs, minutes, etc, no Date, e.g: '15:00:02.5' TimeStamp : you know both the time + the date, e.g: 'Jan-12-2011 10:25' User-defined types Can define your own types, where you can set constraints : create domain Grade as int default null check (value >= 0 and value <= 100); create domain Campus as varchar(4) default 'StG' check (value in ('StG','UTM','UTSC')); domain is a data type with optional constraints constraints are checked every time new value is added. Constraints Primary key, foreign key, checks, unique, they're all constraints. Can give them a name(except for primary key) by adding constraint <<name>> before check (<<condition>>) constraint gradeInRange check (value >= 0); constraint validCourseReference foreign key (cNum, dept) references Course; Check Constraints A check constraint is the most generic constraint type. It allows you to specify that the value in a certain column must satisfy a Boolean (truth-value) expression. A check constraint is satisfied if the check expression evaluates to true or the null value. Since most expressions will evaluate to the null value if any operand is null, they will not prevent null values in the constrained columns Check constraint can check across the column, OR across the entire row( in PSQL ). It can also check across the entire table( not in PSQL ). # this one gives the check a name CREATE TABLE products ( product_no integer, name text, price numeric CONSTRAINT positive_price CHECK (price > 0) ); # this one does a general check on the row. CREATE TABLE products ( product_no integer, name text, price numeric CHECK (price > 0), discounted_price numeric CHECK (discounted_price > 0), CHECK (price > discounted_price) ); Not null Constraints A not-null constraint simply specifies that a column must not assume the null value. A syntax example: # must always be written as column constraint CREATE TABLE products ( product_no integer NOT NULL, name text NULL, price numeric NOT NULL CHECK (price > 0) ); ### Unique * same format as primary key declaration * set of attributes form a key(they are unique) * 1 value + can be null(or all of them). two null values are never considered equal in this comparison(you can think of NULL as unknown). That means even in the presence of a unique constraint it is possible to store duplicate rows that contain a null value in at least one of the constrained columns. * Can be written as a column constraint or as a tqable constraint. * `UNIQUE NOT NULL` has same meaning as `Primary Key` except you can have as manu `unique not null` as you want but you can only have 1 `Primary Key` ```SQL CREATE TABLE products ( product_no integer UNIQUE, name text, price numeric ); # this specifies that the COMBINATION of prodcut_no and name MUST BE UNIQUE CREATE TABLE products ( product_no integer, name text, price numeric, UNIQUE (product_no, name) ); Primary Key Set of attributes forms a key( unique ) link Values are never null ( each one of the attributes is NOT NULL ) Very useful for optimizations Option 1 is if you only have 1 primary key create table Blah( age1 integer primary key; age2 integer; age3 integer ); Option 2 is if you want 1+ primary keys : add pk at the end of table definition(still inside): create table Blah( age1 integer; age2 integer; age3 integer; primary key (age1, age2); ) Foreign Key foreign key (SID) references Student Every value of sID in this table must occur in Student table Must be declared either primary key or unique in Student table Has same syntax as unique and Primary Key create table People ( SIN integer primary key, name text, OHIP text unique); create table Volunteers ( email text primary key, OHIPnum text references People(OHIP)); age int check (age > 0); Assertions Assertions can express ross-table constraints: create assertion (name) check (predicate); Expensive because have to be checked on every database updated Assertions are not supported by PostreSQL(or most other DBMS's) Triggers Triggers are compromise between checks AND Assertions They are powerful You control the cost by deciding when they are applied. Process Specify type of database even you want to respond to: (after delete on Courses, before update of grade on Took, etc) Specify the response: (insert into Winners values (sID)) as a function. Creating the function : create function RecordWinner() returns trigger as $$ begin if new.grade >= 85 then insert into Winners values (new.sid); end if; return new; end $$ language plpgsql The trigger : create trigger TookUpdate before insert on Took #specify the event for each row execute procedure RecordWinner(); # specify what function you want to u Reaction Policies Assume table R refers to table S You can define \"fixes\" propagate backwards from S to R. We define them in R because that's the table that will be affected Cannot define \"fixes\" that propagate forward from R to S. Events You can react to: on delete(when row deleted in S creates dangling reference) on update(when an update in S creates dangling reference(i.e maybe one of values of p.k is changed)) or both: on delete restrict on update cascade reactions restrict : don't allow the deletion/update in S. Therefore, if I delete a row from S which has a reference in R, DBMS won't let me.W cascade : make the same deletion/update in the referring tuple. if I delete row from S, also delete all rows from R which reference it. set null : set corresponding value (not entire tuple!!) in referring tuple to null. Semantics of Deletion Deletion proceeds in 2 stages: Marik all tuples for which the WHERE condition is satisfied Go back and delete the markwed tuples. Updating Schema itself Alter: alter a domain or table alter table Course add column numSections integer; alter table Course drop column breadth; Drop: remove a domain, table, or whole schema drop table course; delete from course removes all referring rows.","title":"Data Definition Language(DDL)"},{"location":"ddl/#data-definition-languageddl","text":"","title":"Data Definition Language(DDL)"},{"location":"ddl/#types","text":"Each column must have a type. List of possible types: Char(n): fixed-length string of n characters, padded with blanks if necessary Varchar(n): variable-length string of up to n characters Text: variable-length, unlimited . PSQL and other implementations support it, but it's not in SQL standard. Int: just integer Float: Real number(+/-, decimal places, etc) e.g: 1.49, 37.96e2 Boolean e.g: TRUE, FALSE Time-related: Date : just the date, no time in hrs, minuts, e.g: \u20182011-09-22\u2019 Time : just the time in hrs, minutes, etc, no Date, e.g: '15:00:02.5' TimeStamp : you know both the time + the date, e.g: 'Jan-12-2011 10:25'","title":"Types"},{"location":"ddl/#user-defined-types","text":"Can define your own types, where you can set constraints : create domain Grade as int default null check (value >= 0 and value <= 100); create domain Campus as varchar(4) default 'StG' check (value in ('StG','UTM','UTSC')); domain is a data type with optional constraints constraints are checked every time new value is added.","title":"User-defined types"},{"location":"ddl/#constraints","text":"Primary key, foreign key, checks, unique, they're all constraints. Can give them a name(except for primary key) by adding constraint <<name>> before check (<<condition>>) constraint gradeInRange check (value >= 0); constraint validCourseReference foreign key (cNum, dept) references Course;","title":"Constraints"},{"location":"ddl/#check-constraints","text":"A check constraint is the most generic constraint type. It allows you to specify that the value in a certain column must satisfy a Boolean (truth-value) expression. A check constraint is satisfied if the check expression evaluates to true or the null value. Since most expressions will evaluate to the null value if any operand is null, they will not prevent null values in the constrained columns Check constraint can check across the column, OR across the entire row( in PSQL ). It can also check across the entire table( not in PSQL ). # this one gives the check a name CREATE TABLE products ( product_no integer, name text, price numeric CONSTRAINT positive_price CHECK (price > 0) ); # this one does a general check on the row. CREATE TABLE products ( product_no integer, name text, price numeric CHECK (price > 0), discounted_price numeric CHECK (discounted_price > 0), CHECK (price > discounted_price) );","title":"Check Constraints"},{"location":"ddl/#not-null-constraints","text":"A not-null constraint simply specifies that a column must not assume the null value. A syntax example: # must always be written as column constraint CREATE TABLE products ( product_no integer NOT NULL, name text NULL, price numeric NOT NULL CHECK (price > 0) ); ### Unique * same format as primary key declaration * set of attributes form a key(they are unique) * 1 value + can be null(or all of them). two null values are never considered equal in this comparison(you can think of NULL as unknown). That means even in the presence of a unique constraint it is possible to store duplicate rows that contain a null value in at least one of the constrained columns. * Can be written as a column constraint or as a tqable constraint. * `UNIQUE NOT NULL` has same meaning as `Primary Key` except you can have as manu `unique not null` as you want but you can only have 1 `Primary Key` ```SQL CREATE TABLE products ( product_no integer UNIQUE, name text, price numeric ); # this specifies that the COMBINATION of prodcut_no and name MUST BE UNIQUE CREATE TABLE products ( product_no integer, name text, price numeric, UNIQUE (product_no, name) );","title":"Not null Constraints"},{"location":"ddl/#primary-key","text":"Set of attributes forms a key( unique ) link Values are never null ( each one of the attributes is NOT NULL ) Very useful for optimizations Option 1 is if you only have 1 primary key create table Blah( age1 integer primary key; age2 integer; age3 integer ); Option 2 is if you want 1+ primary keys : add pk at the end of table definition(still inside): create table Blah( age1 integer; age2 integer; age3 integer; primary key (age1, age2); )","title":"Primary Key"},{"location":"ddl/#foreign-key","text":"foreign key (SID) references Student Every value of sID in this table must occur in Student table Must be declared either primary key or unique in Student table Has same syntax as unique and Primary Key create table People ( SIN integer primary key, name text, OHIP text unique); create table Volunteers ( email text primary key, OHIPnum text references People(OHIP)); age int check (age > 0);","title":"Foreign Key"},{"location":"ddl/#assertions","text":"Assertions can express ross-table constraints: create assertion (name) check (predicate); Expensive because have to be checked on every database updated Assertions are not supported by PostreSQL(or most other DBMS's)","title":"Assertions"},{"location":"ddl/#triggers","text":"Triggers are compromise between checks AND Assertions They are powerful You control the cost by deciding when they are applied.","title":"Triggers"},{"location":"ddl/#process","text":"Specify type of database even you want to respond to: (after delete on Courses, before update of grade on Took, etc) Specify the response: (insert into Winners values (sID)) as a function. Creating the function : create function RecordWinner() returns trigger as $$ begin if new.grade >= 85 then insert into Winners values (new.sid); end if; return new; end $$ language plpgsql The trigger : create trigger TookUpdate before insert on Took #specify the event for each row execute procedure RecordWinner(); # specify what function you want to u","title":"Process"},{"location":"ddl/#reaction-policies","text":"Assume table R refers to table S You can define \"fixes\" propagate backwards from S to R. We define them in R because that's the table that will be affected Cannot define \"fixes\" that propagate forward from R to S.","title":"Reaction Policies"},{"location":"ddl/#events","text":"You can react to: on delete(when row deleted in S creates dangling reference) on update(when an update in S creates dangling reference(i.e maybe one of values of p.k is changed)) or both: on delete restrict on update cascade","title":"Events"},{"location":"ddl/#reactions","text":"restrict : don't allow the deletion/update in S. Therefore, if I delete a row from S which has a reference in R, DBMS won't let me.W cascade : make the same deletion/update in the referring tuple. if I delete row from S, also delete all rows from R which reference it. set null : set corresponding value (not entire tuple!!) in referring tuple to null.","title":"reactions"},{"location":"ddl/#semantics-of-deletion","text":"Deletion proceeds in 2 stages: Marik all tuples for which the WHERE condition is satisfied Go back and delete the markwed tuples.","title":"Semantics of Deletion"},{"location":"ddl/#updating-schema-itself","text":"Alter: alter a domain or table alter table Course add column numSections integer; alter table Course drop column breadth; Drop: remove a domain, table, or whole schema drop table course; delete from course removes all referring rows.","title":"Updating Schema itself"},{"location":"relational_algebra/","text":"Relational Algebra Definitions Relation : table in SQL Schema : structure of a relation(what columns does it have, what type are they, are there any constraints on its columns). e.g of schema: Teams (name, homefield, coach) Instance : particular data in a relation. Instances frequently change, schemas always never. Tuple : 1 row inside the relation. A row can have this format: {Nick, 21, UofT, CS}, where the attributes( see below ) are {surname, age, university, degree}. Attribute : column in SQL. Attribute of a relation. Every Every tuple must have a value for that in RA(relational algebra). This is not necessarily true for SQL. Database schema : a set of relation schemas Database instance : a set of relation instances All Relations are sets . A relation is a set** of tuples, which means: There can be no duplicate tuples Since it's a set, the order of the tuples doesn't matter . SQL is different since there, relations are bags (they allow duplicates. this will come later.) Constraining the data Superkeys Superkey is a set of attributes(1+) that uniquely identify a tuple in a relation/table key is a minimal superkey. Foreign keys An attribute is a foreign key because it refers to an attribute that is a key in another table . If a key in another table has multiple attributes, then foreign key must also have attributes(since it must contain all attributes of the primary key). R_1[X] \\subseteq R_2[Y] R_1[X] \\subseteq R_2[Y] , e.g: Roles[mID] \\subseteq Movies[mID] Roles[mID] \\subseteq Movies[mID] X and Y are a list of attributes, of same arity Y must be a key in R_2 R_2 : notice that it is a key, not the superkey(we want the minimal set of attributes that uniquely identify a tuple) Note: R_1[X] \\subseteq R_2[Y] R_1[X] \\subseteq R_2[Y] is a foreign key ifff Y is a key for relation R_2 R_2 . Otherwise, it's a normal referential integrity constraint, or inclusion dependency. e.g Artists[mID] \\subseteq Roles[mID] Artists[mID] \\subseteq Roles[mID] If here mID in Roles is not a key, then we can have multiple mID's in Roles in which case this is not a Foreign key constraint. R \\subseteq S R \\subseteq S is equivalent to $ R - S = \\emptyset$ , which essentially means that there is nothing in R that does not exist in S since (R - S only keeps the things that exist in R that do not exist in S). Relational Algebra Basics Assume following schema for our examples: Exercise Schema Movies ( mID , title, director, year, length) Artists ( aID , aName, nationality) Roles ( mID, aID, character ) underlined means that it's the key(not the superkey! technically all of the attributes in a row create a superkey here Foreign key constraints : Roles[mID] \\subseteq Movies[mID] Roles[mID] \\subseteq Movies[mID] Roles[aID] \\subseteq Artists[aID] Roles[aID] \\subseteq Artists[aID] Select operator \\sigma_c(R) \\sigma_c(R) : choose tuples R is a table c is a boolean expression: alive=true \\sigma \\sigma means Select and is used to select all tuples from relation R which satisfy boolean expression c . Result is a relation with same schema as operand, with all attributes from R, but only with tuples which satisfy condition Project operator \\pi_L(R) \\pi_L(R) : choose columns R is a table L is the subset of attributes of R that you want to see(i.e which columns of your relation do you want to see. ) Result is a relation , with all tuples from R , BUT only the attributes in L . Cartesian Product R_1 \\times R_2 R_1 \\times R_2 R1 and R2 are both relations Result is a relation , with every single combination of a tuple from R1 concatenated to a tuple from R2 How many tuples are there in R1 \\times R2 R1 \\times R2 ? That's $\\text{number of rows in R1 } \\times \\text{ number of tuples/rows in R2} Note: If an attribute occurs in both relations, it is prefixed by the relation name: e.g: Movies.mid, Roles.mid Cartesian product can be inconvenient. This is because it will generate a lot of rows that do not make sense. We want only the rows where some attributes from relation A match with some attributes from relation B . We call this operation: Natural Join Natural Join R \\bowtie S R \\bowtie S Result is defined by: taking the Cartesian product selecting to ensure equality on attributes that exist in both relations . projecting to remove duplicate attributes Artists \\bowtie Roles Artists \\bowtie Roles only keeps the tuples/rows where the aID is the same in both Roles and Artists(see the schema above). That means each row will represent information about an artist and a role he played, essentially showing all artists along with the roles that they played Properties Commutative: R \\bowtie S = S \\bowtie R R \\bowtie S = S \\bowtie R Associative: R \\bowtie (S \\bowtie T) = (R \\bowtie S) \\bowtie T R \\bowtie (S \\bowtie T) = (R \\bowtie S) \\bowtie T , which means that brackets are essentially irrelevant, can just do R \\bowtie S \\bowtie T R \\bowtie S \\bowtie T Special cases If no attributes in common: resulting relation is cartesian product of the 2 relations . If one attribute in common: the 2nd column is ommitted from the result(either one of them could be omitted). Different attribute in common: we need to rename the attribute first to have the same name, and then we're back to case 2. No tuples match: if no tuples match, the resulting relation is empty Problems with Natural Join It can over-match if it chooses to join on some attributes that we don't want(let's say it also joins on A.cake = B.cake, when we actually don't want that), so we lose some control over it. It can under-match if we want to join over some attributes that do not have to carry the same name. In that case we first have to rename the attribute, which can be a PITA. The solutions to these problems is a Theta Join Theta Join R \\bowtie_{condition} S R \\bowtie_{condition} S This is syntactic sugar for the following sequence: Perform Cartesian product(you join every row from R to every row from S creating R x S tuples). Select \\sigma \\sigma the rows which satisfy your condition, and in your condition you specify which attributes pairs you want to match. Assignment operator R := Expression R := Expression Alternate notation is R(A_1, A_2,...,A_n):= Expression R(A_1, A_2,...,A_n):= Expression , where you would rename attributes of Expression to A_1,...,A_n A_1,...,A_n and give the new relation the name R. Note : all of the tuples stay the same, just the attributes change + the relation changes. R must be a temporary variable, you will use it for a future query, it serves no permanent purpose. e.g: CSCOffering := \\sigma_{dept = 'csc'}Offering CSCOffering := \\sigma_{dept = 'csc'}Offering TookCSC(sid,grade) := \\pi_{sid, \\; grade} (CSCOffering \\bowtie Took) TookCSC(sid,grade) := \\pi_{sid, \\; grade} (CSCOffering \\bowtie Took) PassedCSC(sid) := \\pi_{sid} (\\sigma_{grade > 50}(TookCSC)) PassedCSC(sid) := \\pi_{sid} (\\sigma_{grade > 50}(TookCSC)) Rename Operator \\rho_{R_1}(R_2) \\rho_{R_1}(R_2) Alternate notation is \\rho_{R_1(A_1,...,A_n)} (R_2) \\rho_{R_1(A_1,...,A_n)} (R_2) : lets you rename all the attributes + the relation We use \\rho \\rho when we want to rename within an expression, and R := Expression R := Expression when we want to create a multi-step query. Set Operations Relations are sets, therefore we can use set operations on them: union, interesection, and difference. ONLY IF operands are relations over same attributes(in number of them, name and order) Summary of Operators Advanced Relational Algebra MAX (min is analogous): Find all tuples that are not max . (using select and projects) Subtract from all to find the maxes (using set operations) k or more : Make all combos of k different tuples that satisfy the condition exactly k \"k or more\" - \"(k+1) or more\" every : create all combinations that should have occurred. Find combinations that did not occur (by subtracting those that did occur from all possible) all - (failures) = every","title":"Relational Algebra"},{"location":"relational_algebra/#relational-algebra","text":"","title":"Relational Algebra"},{"location":"relational_algebra/#definitions","text":"Relation : table in SQL Schema : structure of a relation(what columns does it have, what type are they, are there any constraints on its columns). e.g of schema: Teams (name, homefield, coach) Instance : particular data in a relation. Instances frequently change, schemas always never. Tuple : 1 row inside the relation. A row can have this format: {Nick, 21, UofT, CS}, where the attributes( see below ) are {surname, age, university, degree}. Attribute : column in SQL. Attribute of a relation. Every Every tuple must have a value for that in RA(relational algebra). This is not necessarily true for SQL. Database schema : a set of relation schemas Database instance : a set of relation instances All Relations are sets . A relation is a set** of tuples, which means: There can be no duplicate tuples Since it's a set, the order of the tuples doesn't matter . SQL is different since there, relations are bags (they allow duplicates. this will come later.)","title":"Definitions"},{"location":"relational_algebra/#constraining-the-data","text":"Superkeys Superkey is a set of attributes(1+) that uniquely identify a tuple in a relation/table key is a minimal superkey. Foreign keys An attribute is a foreign key because it refers to an attribute that is a key in another table . If a key in another table has multiple attributes, then foreign key must also have attributes(since it must contain all attributes of the primary key). R_1[X] \\subseteq R_2[Y] R_1[X] \\subseteq R_2[Y] , e.g: Roles[mID] \\subseteq Movies[mID] Roles[mID] \\subseteq Movies[mID] X and Y are a list of attributes, of same arity Y must be a key in R_2 R_2 : notice that it is a key, not the superkey(we want the minimal set of attributes that uniquely identify a tuple) Note: R_1[X] \\subseteq R_2[Y] R_1[X] \\subseteq R_2[Y] is a foreign key ifff Y is a key for relation R_2 R_2 . Otherwise, it's a normal referential integrity constraint, or inclusion dependency. e.g Artists[mID] \\subseteq Roles[mID] Artists[mID] \\subseteq Roles[mID] If here mID in Roles is not a key, then we can have multiple mID's in Roles in which case this is not a Foreign key constraint. R \\subseteq S R \\subseteq S is equivalent to $ R - S = \\emptyset$ , which essentially means that there is nothing in R that does not exist in S since (R - S only keeps the things that exist in R that do not exist in S).","title":"Constraining the data"},{"location":"relational_algebra/#relational-algebra-basics","text":"Assume following schema for our examples: Exercise Schema Movies ( mID , title, director, year, length) Artists ( aID , aName, nationality) Roles ( mID, aID, character ) underlined means that it's the key(not the superkey! technically all of the attributes in a row create a superkey here Foreign key constraints : Roles[mID] \\subseteq Movies[mID] Roles[mID] \\subseteq Movies[mID] Roles[aID] \\subseteq Artists[aID] Roles[aID] \\subseteq Artists[aID]","title":"Relational Algebra Basics"},{"location":"relational_algebra/#select-operator-sigma_crsigma_cr-choose-tuples","text":"R is a table c is a boolean expression: alive=true \\sigma \\sigma means Select and is used to select all tuples from relation R which satisfy boolean expression c . Result is a relation with same schema as operand, with all attributes from R, but only with tuples which satisfy condition","title":"Select operator \\sigma_c(R)\\sigma_c(R): choose tuples"},{"location":"relational_algebra/#project-operator-pi_lrpi_lr-choose-columns","text":"R is a table L is the subset of attributes of R that you want to see(i.e which columns of your relation do you want to see. ) Result is a relation , with all tuples from R , BUT only the attributes in L .","title":"Project operator \\pi_L(R)\\pi_L(R): choose columns"},{"location":"relational_algebra/#cartesian-product-r_1-times-r_2r_1-times-r_2","text":"R1 and R2 are both relations Result is a relation , with every single combination of a tuple from R1 concatenated to a tuple from R2 How many tuples are there in R1 \\times R2 R1 \\times R2 ? That's $\\text{number of rows in R1 } \\times \\text{ number of tuples/rows in R2} Note: If an attribute occurs in both relations, it is prefixed by the relation name: e.g: Movies.mid, Roles.mid Cartesian product can be inconvenient. This is because it will generate a lot of rows that do not make sense. We want only the rows where some attributes from relation A match with some attributes from relation B . We call this operation: Natural Join","title":"Cartesian Product R_1 \\times R_2R_1 \\times R_2"},{"location":"relational_algebra/#natural-join-r-bowtie-sr-bowtie-s","text":"Result is defined by: taking the Cartesian product selecting to ensure equality on attributes that exist in both relations . projecting to remove duplicate attributes Artists \\bowtie Roles Artists \\bowtie Roles only keeps the tuples/rows where the aID is the same in both Roles and Artists(see the schema above). That means each row will represent information about an artist and a role he played, essentially showing all artists along with the roles that they played","title":"Natural Join R \\bowtie SR \\bowtie S"},{"location":"relational_algebra/#properties","text":"Commutative: R \\bowtie S = S \\bowtie R R \\bowtie S = S \\bowtie R Associative: R \\bowtie (S \\bowtie T) = (R \\bowtie S) \\bowtie T R \\bowtie (S \\bowtie T) = (R \\bowtie S) \\bowtie T , which means that brackets are essentially irrelevant, can just do R \\bowtie S \\bowtie T R \\bowtie S \\bowtie T","title":"Properties"},{"location":"relational_algebra/#special-cases","text":"If no attributes in common: resulting relation is cartesian product of the 2 relations . If one attribute in common: the 2nd column is ommitted from the result(either one of them could be omitted). Different attribute in common: we need to rename the attribute first to have the same name, and then we're back to case 2. No tuples match: if no tuples match, the resulting relation is empty","title":"Special cases"},{"location":"relational_algebra/#problems-with-natural-join","text":"It can over-match if it chooses to join on some attributes that we don't want(let's say it also joins on A.cake = B.cake, when we actually don't want that), so we lose some control over it. It can under-match if we want to join over some attributes that do not have to carry the same name. In that case we first have to rename the attribute, which can be a PITA. The solutions to these problems is a Theta Join","title":"Problems with Natural Join"},{"location":"relational_algebra/#theta-join-r-bowtie_condition-sr-bowtie_condition-s","text":"This is syntactic sugar for the following sequence: Perform Cartesian product(you join every row from R to every row from S creating R x S tuples). Select \\sigma \\sigma the rows which satisfy your condition, and in your condition you specify which attributes pairs you want to match.","title":"Theta Join R \\bowtie_{condition} SR \\bowtie_{condition} S"},{"location":"relational_algebra/#assignment-operator-r-expressionr-expression","text":"Alternate notation is R(A_1, A_2,...,A_n):= Expression R(A_1, A_2,...,A_n):= Expression , where you would rename attributes of Expression to A_1,...,A_n A_1,...,A_n and give the new relation the name R. Note : all of the tuples stay the same, just the attributes change + the relation changes. R must be a temporary variable, you will use it for a future query, it serves no permanent purpose. e.g: CSCOffering := \\sigma_{dept = 'csc'}Offering CSCOffering := \\sigma_{dept = 'csc'}Offering TookCSC(sid,grade) := \\pi_{sid, \\; grade} (CSCOffering \\bowtie Took) TookCSC(sid,grade) := \\pi_{sid, \\; grade} (CSCOffering \\bowtie Took) PassedCSC(sid) := \\pi_{sid} (\\sigma_{grade > 50}(TookCSC)) PassedCSC(sid) := \\pi_{sid} (\\sigma_{grade > 50}(TookCSC))","title":"Assignment operator R := ExpressionR := Expression"},{"location":"relational_algebra/#rename-operator-rho_r_1r_2rho_r_1r_2","text":"Alternate notation is \\rho_{R_1(A_1,...,A_n)} (R_2) \\rho_{R_1(A_1,...,A_n)} (R_2) : lets you rename all the attributes + the relation We use \\rho \\rho when we want to rename within an expression, and R := Expression R := Expression when we want to create a multi-step query.","title":"Rename Operator \\rho_{R_1}(R_2)\\rho_{R_1}(R_2)"},{"location":"relational_algebra/#set-operations","text":"Relations are sets, therefore we can use set operations on them: union, interesection, and difference. ONLY IF operands are relations over same attributes(in number of them, name and order)","title":"Set Operations"},{"location":"relational_algebra/#summary-of-operators","text":"","title":"Summary of Operators"},{"location":"relational_algebra/#advanced-relational-algebra","text":"MAX (min is analogous): Find all tuples that are not max . (using select and projects) Subtract from all to find the maxes (using set operations) k or more : Make all combos of k different tuples that satisfy the condition exactly k \"k or more\" - \"(k+1) or more\" every : create all combinations that should have occurred. Find combinations that did not occur (by subtracting those that did occur from all possible) all - (failures) = every","title":"Advanced Relational Algebra"},{"location":"schema/","text":"Schemas Think of a Schema the same as a database. With Schemas, you can create different namespaces. , useful to avoid name clashes. Think of it as a big pot, which contains everythihng inside of it(tables, types, etc). The Search Path See the search path: SHOW search_path Set the search path: SET search_path TO University, public; (set multiple paths in the search path) default search path is $user, public Schema $user is not created, but if you create it, it's already in the search path Schema public is created for you, and if you don't specify an alternate schema, everything is created in there by default. Working with a Schema Creating a schema Create your own schema: CREATE SCHEMA University . To refer to things inside of the schema: CREATE TABLE University.Student (...); SELECT * FROM University.Student; Note : If you refer to a name withouts pecifying what schema it is within: any new names you define will go to default schema (public). If you create table frindle, goes to (public.frindle) Removing a Schema remove a schema: DROP SCHEMA University cascade IF EXISTS cascade means everything inside is droped(recursively) IF EXISTS is there to avoid getting error message Usage Pattern Can put the following at the top of every DDL file(Data Definition Language, language used to describe database schemas, saved in a plain text format) DROP SCHEMA IF EXISTS University CASCADE; CREATE SCHEMA University; SET SEARCH_PATH TO University; Here's a good workflow: Create DDL file with the schema(Drop previous schema, create new schema, initialize all of your tables). Create a file(SQL dump) which inserts content in the database, and import them. Run queries directly in shell or by importing queries written in files.","title":"Schemas"},{"location":"schema/#schemas","text":"Think of a Schema the same as a database. With Schemas, you can create different namespaces. , useful to avoid name clashes. Think of it as a big pot, which contains everythihng inside of it(tables, types, etc).","title":"Schemas"},{"location":"schema/#the-search-path","text":"See the search path: SHOW search_path Set the search path: SET search_path TO University, public; (set multiple paths in the search path) default search path is $user, public Schema $user is not created, but if you create it, it's already in the search path Schema public is created for you, and if you don't specify an alternate schema, everything is created in there by default.","title":"The Search Path"},{"location":"schema/#working-with-a-schema","text":"","title":"Working with a Schema"},{"location":"schema/#creating-a-schema","text":"Create your own schema: CREATE SCHEMA University . To refer to things inside of the schema: CREATE TABLE University.Student (...); SELECT * FROM University.Student; Note : If you refer to a name withouts pecifying what schema it is within: any new names you define will go to default schema (public). If you create table frindle, goes to (public.frindle)","title":"Creating a schema"},{"location":"schema/#removing-a-schema","text":"remove a schema: DROP SCHEMA University cascade IF EXISTS cascade means everything inside is droped(recursively) IF EXISTS is there to avoid getting error message","title":"Removing a Schema"},{"location":"schema/#usage-pattern","text":"Can put the following at the top of every DDL file(Data Definition Language, language used to describe database schemas, saved in a plain text format) DROP SCHEMA IF EXISTS University CASCADE; CREATE SCHEMA University; SET SEARCH_PATH TO University; Here's a good workflow: Create DDL file with the schema(Drop previous schema, create new schema, initialize all of your tables). Create a file(SQL dump) which inserts content in the database, and import them. Run queries directly in shell or by importing queries written in files.","title":"Usage Pattern"},{"location":"sql_dml_1/","text":"Data Manipulation Language(DML) DDL: used for defining schemas DML: used for writing queries and modifying databases Order of Execution FROM clause & Joins determine initial table. WHERE filters rows individually according to data FROM 1 row satisfying a condition. GROUP BY combines rows after WHERE into groups Having filters the groups. Goes through the Groups and just like where filters rows, it filters groups according to each group satisfying a condition. ORDER BY arranges remaining rows/groups TOP only chooses N amount of rows. SELECT selects only the right columns. Basic queries Renaming tables: employee e renames table employee to e for duration of query SQL --table e renames table to e. SELECT e.name, d.name FROM employee e, department d WHERE d.name = \u2018marketing\u2019 AND e.name = \u2018Horton\u2019; Renaming attributes: Use: attribute AS new_name SQL select name AS title, dept FROM course; Order relations: add as final clause ORDER BY (attribute_list) [DESC/ASC] Ordering can include expressions : ORDER BY sales+rentals Ordering is last thing done before SELECT, so all attributes are still available. SELECT with expressions: SELECT sid, grade+10 AS adjusted FROM Took; SELECT dept||cnum FROM course;--Notice how every value in breadthRequirement column will be 'satisfies' SELECT dept, 'satisfies' AS breadthRequirement FROM Course WHERE breadth; Comparing string to a pattern: Patterns are: %(means any string, of 0+ length), _(any single character ) Comparisons are done with: attribute LIKE '%pattern_' and attribute NOT LIKE '%pattern_' SELECT * FROM COURSE WHERE name LIKE '%Comp%'; Aggregation and Grouping These include: SUM, AVG, COUNT, MIN, MAX, which can be applied to a column in a SELECT clause. When they are applied, they will only create 1 ROW, since by default they will take the aggregate function across the entire table. If we have a SELECT-FROM-WHERE with GROUP BY, tuples are grouped according to values of those attributes AND any aggregation gives us a single value per group SELECT : Each element of SELECT must be either an aggregate function(SUM, MAX, MIN, COUN), or an attribute on the GROUP BY list. HAVING : similar to select, HAVING can refer to attributes ONLY IF they're aggregate functions OR attributes of GROUP BY list. Union, Intersection and Difference (subquery) UNION/INTERSECT/EXCEPT/UNION ALL (subquery) --brackets are mandatory (SELECT sid FROM Took WHERE grade > 95) UNION (SELECT sid FROM Took WHERE grade < 50) Union ALL does not eliminate duplicates, but Union does. EXCEPT returns the distinct rows that do not appear in a second result set. ** Controlling Duplicate Elimination We remove duplicate rows with SELECT DISTINCT We force to keep duplicates by doing UNION ALL Views A view is a relation(table) defined in terms of stored table( base tables ) + other views. You can access a view like a base table. There are 2 types of views: Virtual : no tuples are stored, view is just a query constructed dynamically when needed(from base tables + other views) Materialized : constructed and stored. Problem is: Expensive to maintain! , because you need to modify memory every time. Views are used to: Break down a large query Provide another way of looking at the same data View for students who earned an 80 or higher in a CSC course. CREATE VIEW topresults AS -- this is the main line. The rest is a normal query. SELECT firstname, surname, cnum FROM Student, Took, Offering WHERE Student.sid = Took.sid AND Took.oid = Offering.oid AND grade >= 80 AND dept = 'CSC'; We will only use virtual views. psql only started supporting materialized views recently.","title":"Data Manipulation Language(DML)"},{"location":"sql_dml_1/#data-manipulation-languagedml","text":"DDL: used for defining schemas DML: used for writing queries and modifying databases","title":"Data Manipulation Language(DML)"},{"location":"sql_dml_1/#order-of-execution","text":"FROM clause & Joins determine initial table. WHERE filters rows individually according to data FROM 1 row satisfying a condition. GROUP BY combines rows after WHERE into groups Having filters the groups. Goes through the Groups and just like where filters rows, it filters groups according to each group satisfying a condition. ORDER BY arranges remaining rows/groups TOP only chooses N amount of rows. SELECT selects only the right columns.","title":"Order of Execution"},{"location":"sql_dml_1/#basic-queries","text":"Renaming tables: employee e renames table employee to e for duration of query SQL --table e renames table to e. SELECT e.name, d.name FROM employee e, department d WHERE d.name = \u2018marketing\u2019 AND e.name = \u2018Horton\u2019; Renaming attributes: Use: attribute AS new_name SQL select name AS title, dept FROM course; Order relations: add as final clause ORDER BY (attribute_list) [DESC/ASC] Ordering can include expressions : ORDER BY sales+rentals Ordering is last thing done before SELECT, so all attributes are still available. SELECT with expressions: SELECT sid, grade+10 AS adjusted FROM Took; SELECT dept||cnum FROM course;--Notice how every value in breadthRequirement column will be 'satisfies' SELECT dept, 'satisfies' AS breadthRequirement FROM Course WHERE breadth; Comparing string to a pattern: Patterns are: %(means any string, of 0+ length), _(any single character ) Comparisons are done with: attribute LIKE '%pattern_' and attribute NOT LIKE '%pattern_' SELECT * FROM COURSE WHERE name LIKE '%Comp%';","title":"Basic queries"},{"location":"sql_dml_1/#aggregation-and-grouping","text":"These include: SUM, AVG, COUNT, MIN, MAX, which can be applied to a column in a SELECT clause. When they are applied, they will only create 1 ROW, since by default they will take the aggregate function across the entire table. If we have a SELECT-FROM-WHERE with GROUP BY, tuples are grouped according to values of those attributes AND any aggregation gives us a single value per group SELECT : Each element of SELECT must be either an aggregate function(SUM, MAX, MIN, COUN), or an attribute on the GROUP BY list. HAVING : similar to select, HAVING can refer to attributes ONLY IF they're aggregate functions OR attributes of GROUP BY list.","title":"Aggregation and Grouping"},{"location":"sql_dml_1/#union-intersection-and-difference","text":"(subquery) UNION/INTERSECT/EXCEPT/UNION ALL (subquery) --brackets are mandatory (SELECT sid FROM Took WHERE grade > 95) UNION (SELECT sid FROM Took WHERE grade < 50) Union ALL does not eliminate duplicates, but Union does. EXCEPT returns the distinct rows that do not appear in a second result set. **","title":"Union, Intersection and Difference"},{"location":"sql_dml_1/#controlling-duplicate-elimination","text":"We remove duplicate rows with SELECT DISTINCT We force to keep duplicates by doing UNION ALL","title":"Controlling Duplicate Elimination"},{"location":"sql_dml_1/#views","text":"A view is a relation(table) defined in terms of stored table( base tables ) + other views. You can access a view like a base table. There are 2 types of views: Virtual : no tuples are stored, view is just a query constructed dynamically when needed(from base tables + other views) Materialized : constructed and stored. Problem is: Expensive to maintain! , because you need to modify memory every time. Views are used to: Break down a large query Provide another way of looking at the same data View for students who earned an 80 or higher in a CSC course. CREATE VIEW topresults AS -- this is the main line. The rest is a normal query. SELECT firstname, surname, cnum FROM Student, Took, Offering WHERE Student.sid = Took.sid AND Took.oid = Offering.oid AND grade >= 80 AND dept = 'CSC'; We will only use virtual views. psql only started supporting materialized views recently.","title":"Views"},{"location":"sql_dml_2/","text":"Outer Joins Traditional Joins FROM R, S FROM R cross join S FROM R natural join S FROM R join S on Condition Dangling tuples : With joins that require some attributes to match, tuples lacking a match are left out of the results. Outer join preserves dangling tuple by padding them with NULL in the other relation. Inner join(normal join) doesn't pad with NULL Outer joins A {LEFT|RIGHT|FULL} JOIN B ON C --Theta Outer Joins A NATURAL {LEFT|RIGHT|FULL} JOIN B --Natural Outer Joins Left/Right Join preserves dangling tuples on LHS/RHS, pads with nulls on opposite side. Full Join preserves dangling tuples on BOTH sides. Null Values Checking for null values : IS NULL and IS NOT NULL In SQL we have 3 truth-values: True, False, Unknown. Think of True = 1, False = 0, Unknown = 0.5 Boolean operators : AND is min, OR is max, NOT is (1-x) Null value Usage WHERE (and therefore NATURAL JOINS ) ignore Null values, so if you have any rows with Null's, you ignore them. Aggregation ignores NULL. Null never contributes to a sum, average or count, UNLESS every value is Null. In that case, count is 0. SELECT consideres 2 null values equal. So if you do select distinct on {[a,null], [a,null]} you just get 1 null Set operations consider 2 null values equal","title":"Outer Joins"},{"location":"sql_dml_2/#outer-joins","text":"Traditional Joins FROM R, S FROM R cross join S FROM R natural join S FROM R join S on Condition Dangling tuples : With joins that require some attributes to match, tuples lacking a match are left out of the results. Outer join preserves dangling tuple by padding them with NULL in the other relation. Inner join(normal join) doesn't pad with NULL Outer joins A {LEFT|RIGHT|FULL} JOIN B ON C --Theta Outer Joins A NATURAL {LEFT|RIGHT|FULL} JOIN B --Natural Outer Joins Left/Right Join preserves dangling tuples on LHS/RHS, pads with nulls on opposite side. Full Join preserves dangling tuples on BOTH sides.","title":"Outer Joins"},{"location":"sql_dml_2/#null-values","text":"Checking for null values : IS NULL and IS NOT NULL In SQL we have 3 truth-values: True, False, Unknown. Think of True = 1, False = 0, Unknown = 0.5 Boolean operators : AND is min, OR is max, NOT is (1-x)","title":"Null Values"},{"location":"sql_dml_2/#null-value-usage","text":"WHERE (and therefore NATURAL JOINS ) ignore Null values, so if you have any rows with Null's, you ignore them. Aggregation ignores NULL. Null never contributes to a sum, average or count, UNLESS every value is Null. In that case, count is 0. SELECT consideres 2 null values equal. So if you do select distinct on {[a,null], [a,null]} you just get 1 null Set operations consider 2 null values equal","title":"Null value Usage"},{"location":"subqueries/","text":"Subqueries We can use a (Subquery): In the FROM clause in the WHERE , provided it returns 1 result Subquery must be named, so we can refer to it from outer query. FROM : SELECT sid, dept||cnum as course, grade FROM (SELECT * FROM Offering WHERE instructor=\u2018Horton\u2019) Hoffering WHERE Took.oid = Hoffering.oid; WHERE : only if subquery guaranteed to produce exactly one value. SELECT sid, surname FROM Student WHERE cgpa > (SELECT cgpa FROM Student WHERE sid = 99999); Subquery is run first , and if it returns more than 1 value, SQL returns an error. If subquery reutrns null, then WHERE ignores it, beacuse a >, <, =, <> null is ignored. Any, All, IN,EXISTS When a subquery can return multiple values, we can use a quantifier --Comparisons x comparison ANY/SOME (subquery) -- comparison holds FOR AT LEAST ONE tuple in subquery result --Belonging to results x comparison ALL (subquery) -- TRUE iff comparison holds FOR EVERY tuple x IN (subquery) --TRUE iff x is in set of rows. --Existing EXISTS (subquery) --TRUE iff subquery has at least one tuple NOT EXISTS (subquery) --TRUE iff subquery doesn't exist Scope Queries are evaluated from inside out If a name refers to more than one thing, use the most closely nested one If subquery refers only to names defined inside of it, it can be evaluated once and then used repeatedly inthe query. Otherwise it's evaluated once for each tuple in the outer query.","title":"Subqueries"},{"location":"subqueries/#subqueries","text":"We can use a (Subquery): In the FROM clause in the WHERE , provided it returns 1 result Subquery must be named, so we can refer to it from outer query. FROM : SELECT sid, dept||cnum as course, grade FROM (SELECT * FROM Offering WHERE instructor=\u2018Horton\u2019) Hoffering WHERE Took.oid = Hoffering.oid; WHERE : only if subquery guaranteed to produce exactly one value. SELECT sid, surname FROM Student WHERE cgpa > (SELECT cgpa FROM Student WHERE sid = 99999); Subquery is run first , and if it returns more than 1 value, SQL returns an error. If subquery reutrns null, then WHERE ignores it, beacuse a >, <, =, <> null is ignored.","title":"Subqueries"},{"location":"subqueries/#any-all-inexists","text":"When a subquery can return multiple values, we can use a quantifier --Comparisons x comparison ANY/SOME (subquery) -- comparison holds FOR AT LEAST ONE tuple in subquery result --Belonging to results x comparison ALL (subquery) -- TRUE iff comparison holds FOR EVERY tuple x IN (subquery) --TRUE iff x is in set of rows. --Existing EXISTS (subquery) --TRUE iff subquery has at least one tuple NOT EXISTS (subquery) --TRUE iff subquery doesn't exist","title":"Any, All, IN,EXISTS"},{"location":"subqueries/#scope","text":"Queries are evaluated from inside out If a name refers to more than one thing, use the most closely nested one If subquery refers only to names defined inside of it, it can be evaluated once and then used repeatedly inthe query. Otherwise it's evaluated once for each tuple in the outer query.","title":"Scope"}]}